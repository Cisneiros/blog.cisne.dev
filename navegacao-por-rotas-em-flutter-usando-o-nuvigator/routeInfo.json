{"template":"__react_static_root__/src/containers/post","sharedHashesByProp":{},"data":{"postData":{"title":"Navega√ß√£o por rotas em Flutter usando o Nuvigator","date":"2020-08-12T00:00:00-03:00","slug":"navegacao-por-rotas-em-flutter-usando-o-nuvigator","tags":["flutter","mobile"],"filePath":"2020-08-12-navegacao-por-rotas-em-flutter-usando-o-nuvigator.md","content":"Um dos aspectos mais importantes de um app √© a **navega√ß√£o entre telas**. Na web, isso √© feito atrav√©s de links (e, com a alta dos frameworks de front-end JavaScript, reimplementando esta navega√ß√£o no cliente). Num app em Flutter, existem fun√ß√µes de navega√ß√£o para transicionar de uma tela para outra. Com elas √© poss√≠vel empilhar, substituir e remover telas criando o pr√≥prio widget da tela seguinte nestas fun√ß√µes.\n\nO **Nuvigator** surgiu como uma abstra√ß√£o em cima desse roteamento do Flutter para facilitar a declara√ß√£o e reutiliza√ß√£o destas rotas, o que √© bem √∫til conforme o app cresce e tem mais partes que interagem. Trouxe uma introdu√ß√£o a como ele funciona neste post!\n\n<!-- summary-break -->\n\nO [Nuvigator](https://github.com/nubank/nuvigator) √© uma biblioteca open source, criada no Nubank, para facilitar a declara√ß√£o de rotas e a navega√ß√£o entre elas em Flutter. Foi usada inicialmente em algumas se√ß√µes do app, moldada para facilitar o fluxo de desenvolvimento de navega√ß√£o. Eventualmente, ela chegou a um ponto que pode ser aberta para o p√∫blico e beneficiar a comunidade desenvolvedora. \n\n## Navega√ß√£o em Fluter 101\n\nVamos dar uma olhada em como funciona uma navega√ß√£o b√°sica em Flutter, seguindo os [exemplos da documenta√ß√£o](https://flutter.dev/docs/cookbook/navigation/navigation-basics), para depois entender no que o Nuvigator pode ajudar. No exemplo original, ele cria widgets como `FirstRoute`. Como vamos introduzir alguns widgets de rotas mais tarde, estou chamando de `FirstScreen` para facilitar. Al√©m disso, adicionei um argumento que a segunda tela recebe.\n\n```dart\n// first_screen.dart\n\nclass FirstScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('First Screen'),\n      ),\n      body: Center(\n        child: RaisedButton(\n          child: Text('Open route'),\n          onPressed: () {\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => SecondScreen(magicNumber: 42)),\n            );\n          }\n        ),\n      ),\n    );\n  }\n}\n```\n```dart\n// second_screen.dart\nclass SecondScreen extends StatelessWidget {\n  SecondScreen({this.magicNumber});\n\n  final int magicNumber;\n  // ...\n}\n```\n\nNo exemplo acima, a partir da tela `FirstScreen`, √© poss√≠vel clicar num bot√£o para abrir a tela `SecondScreen`. Como a tela de destino precisa receber algum par√¢metro, ele pode ser passado direto no construtor do widget `SecondScreen`. Note tamb√©m um widget `MaterialPageRoute`, usado para definir como a transi√ß√£o entre as telas vai acontecer. Se estiv√©ssemos um app com a interface do iOS, usar√≠amos um `CupertinoPageRoute` no lugar.\n\nApesar de bastante simples, esse exemplo tem um problema que √© o **acoplamento das duas telas**: a tela de origem precisa instanciar o widget da segunda tela, e para isso vai importar o arquivo em que ele for definido. Tamb√©m est√° nela o **tipo de rota** (material, no caso). Caso f√¥ssemos mudar o tipo de rota ou qual a tela de entrada no fluxo de destino, precisar√≠amos editar em todos os arquivos que possivelmente conseguem abrir esta rota.\n\nUma maneira de amenizar isso seria definir separadamente as rotas num arquivo que pode ser importado pelos widgets que querem navegar entre telas. Poder√≠amos ter um arquivo de navega√ß√£o como este:\n\n```dart\n// navigation.dart\n\ntoSecondRoute(BuildContext context, {int magicNumber}) => Navigator.push(\n    context,\n    MaterialPageRoute(builder: (context) => SecondScreen(magicNumber: magicNumber)),\n  );\n```\n```dart\n// first_screen.dart\n\nimport './navigation.dart';\n\nRaisedButton(\n  child: Text('Open route'),\n  onPressed: () => toSecondRoute(context, magicNumber: 42)\n),\n```\n\nCom isso, isolamos nossa navega√ß√£o da apresenta√ß√£o das telas. Se resolvermos mudar qual o widget que vai aparecer quando esta rota for chamada, s√≥ precisamos modificar na fun√ß√£o `toSecondRoute` e todos que a importam v√£o apontar para o widget correto. \n\nUma outra maneira de separar estes widgets seria usar uma **rota nomeada** do Flutter. Ao declarar a aplica√ß√£o, podemos listar as rotas que ela possui assim:\n\n```dart\n// main.dart\n\nMaterialApp(\n  // A rota que o app vai carregar ao iniciar\n  initialRoute: '/',\n  routes: {\n    '/': (context) => FirstScreen(),\n    '/second': (context) => SecondScreen(),\n  },\n);\n```\n```dart\n// first_screen.dart\n\nRaisedButton(\n  child: Text('Open route'),\n  onPressed: () => Navigator.pushNamed(context, '/second')\n),\n```\n\nEsta maneira permite declarar rotas num formato parecido com um link e abrir estes links de qualquer lugar do app. Por√©m, criamos mais uma vez um acoplamento, dessa vez com a string `/second`. Ela estar√° escrita literalmente em todas as telas que quiserem acessar esta rota, e, ao contr√°rio da fun√ß√£o que usamos no exemplo anterior, n√£o pode ser facilmente editada usando as ferramentas de refatora√ß√£o que as principais IDEs de Flutter suportam, como Visual Studio Code ou IntelliJ. Poder√≠amos resolver este problema externalizando uma classe ou enum que seriam mapeados para as string, para reduzir este acoplamento.\n\nOutra dificuldade que aparece ao usar rotas nomeadas √© a passagem de par√¢metros para elas. A documenta√ß√£o do Flutter tem um artigo s√≥ sobre [passagem de par√¢metros para rotas nomeadas](https://flutter.dev/docs/cookbook/navigation/navigate-with-arguments), que envolve criar uma classe separada para os argumentos que a rota recebe e instanciar esta classe ao chamar a rota nomeada. Isso traz algumas quest√µes por si s√≥ e, conforme a aplica√ß√£o cresce, lidar com este boilerplate fica mais dif√≠cil.\n\n## Entra o Nuvigator\n\nO Nuvigator n√£o substitui o roteamento do Flutter, mas sim **abstrai alguns conceitos** dele, como a cria√ß√£o de fun√ß√µes para chamar cada rota, cria√ß√£o de classes de argumentos usadas de maneira transparentes e hierarquia de _deep links_, para permitir acesso direto a uma parte do app, como nas rotas nomeadas.\n\nPara isso, o Nuvigator se vale de **gera√ß√£o de c√≥digo Dart**. Por isso, dizemos que ele fornece uma API declarativa em que voc√™ define as rotas e o Nuvigator gera c√≥digo para facilitar o uso delas.\n\n> O Nuvigator estava na vers√£o 0.6.0 quando este post foi escrito. Dependendo de qu√£o do futuro voc√™ √©, alguns conceitos ou exemplos abaixo podem estar desatualizados, pois o projeto est√° ativamente em desenvolvimento! üìà\n\nVamos definir as rotas que vimos acima em termos de um `Router` do Nuvigator:\n\n```dart\n// app_router.dart\n\npart 'app_router.g.dart';\n\n@NuRouter()\nclass AppRouter extends Router {\n  @NuRoute()\n  ScreenRoute<void> firstScreen() => ScreenRoute(\n    builder: (context) => FirstScreen()\n  )\n\n  @NuRoute()\n  ScreenRoute<void> secondScreen({int magicNumber}) => ScreenRoute(\n    builder: (context) => SecondScreen(magicNumber: magicNumber)\n  )\n\n  @override\n  Map<RouteDef, ScreenRouteBuilder> get screensMap => _$screensMap;\n}\n```\n\nAs classes `Router` e `ScreenRoute` do exemplo acima v√™m do Nuvigator. Este exemplo √© bem parecido com o segundo, em que criamos uma fun√ß√£o para chamar a segunda tela. As diferen√ßas s√£o que, neste caso, estas fun√ß√µes s√£o m√©todos de uma classe nova `AppRouter` que criamos, e que elas est√£o anotadas com `@NuRoute`. Estas anota√ß√µes servem para indicar ao Nuvigator que cada fun√ß√£o destas √© uma rota, e que ele deve gerar o c√≥digo necess√°rio para que ela funcione. Al√©m disso, h√° um getter `screensMap`, que vai ser usado pelo c√≥digo gerado, tamb√©m. Eu aproveitei j√° e criei uma rota para a primeira tela.\n\nEnfim, adicionamos o Nuvigator no nosso app:\n\n```dart\n// main.dart\n\nMaterialApp(\n  builder: Nuvigator(\n    router: AppRouter(), // O Router que criamos acima\n    screenType: materialScreenType, // O tipo de rota padr√£o\n    initialRoute: AppRoutes.firstScreen,\n  ), \n);\n```\n\nO widget `Nuvigator` recebe um `Router` e toma conta de lidar com a navega√ß√£o a partir de agora. Uma outra classe √© gerada a partir do nosso `AppRouter` que √© a `AppRoutes`. Usamos ela no exemplo acima para especificar a rota inicial sem usar uma string diretamente no c√≥digo.\n\nEu falei algumas vezes sobre **gerar c√≥digo**. Isso funciona usando um pacote chamado [build_runner](). Ele adiciona um comando que podemos executar no projeto que vai escanear o c√≥digo fonte da nossa aplica√ß√£o e gerar c√≥digo adicional de acordo com os pacotes que suportem essa fun√ß√£o. √â para isso que as anota√ß√µes servem. No topo do arquivo, colocamos uma diretriz `part`. Ela serve para dizer que h√° outro arquivo que estende a funcionalidade deste. Esse arquivo ainda n√£o existe, mas vai ser gerado ao rodar o comando abaixo:\n\n```html\n$ flutter pub run build_runner build --delete-conflicting-outputs\n```\n\nNeste exemplo, o Nuvigator vai gerar fun√ß√µes para abrir cada rota. Essas rotas, por padr√£o, v√£o abrir como um `push` (como nos primeiros exemplo), mas h√° suporte para definir m√∫ltiplas maneiras de abrir uma rota e o Nuvigator gerar√° um m√©todo para cada uma, como `pushReplacement` por exemplo. Nosso widget da primeira tela poderia buscar o Nuvigator no contexto para ter acesso a essas fun√ß√µes, mas como ele j√° √© criado dentro da classe do nuvigator, podemos passar as fun√ß√µes de navega√ß√£o que o widget precisa como argumentos no seu construtor, e deixando o widget totalmente desacoplado da navega√ß√£o.\n\n```dart\n// app_router.dart \n\n@NuRoute()\nScreenRoute<void> firstScreen() => ScreenRoute(\n  builder: (context) => FirstScreen(\n    // A fun√ß√£o `toSecondScreen` √© gerada automaticamente usando o\n    // tipo de rota padr√£o, `push`\n    toSecondScreen: toSecondScreen, \n  )\n)\n```\n```dart\n// first_screen.dart\n\nclass FirstScreen extends StatelessWidget {\n  FirstScreen({@required this.toSecondScreen});\n\n  final Function({int magicNumber}) toSecondScreen;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('First Screen'),\n      ),\n      body: Center(\n        child: RaisedButton(\n          child: Text('Open route'),\n          onPressed: () => toSecondScreen(magicNumber: 42)\n        ),\n      ),\n    );\n  }\n}\n```\n\nPassando a fun√ß√£o de navega√ß√£o para o widget, ao inv√©s de acess√°-la diretamente nele, nos permite fazer testes unit√°rios deste widget sem necessidade de navega√ß√£o. Por exemplo, podemos passar uma implementa√ß√£o que atualiza uma vari√°vel local no teste e verificamos se, ao tocar no bot√£o, essa vari√°vel foi atualizada.\n\n√â poss√≠vel tamb√©m acessar a segunda rota a partir de um deep link ao inv√©s de passar a fun√ß√£o para o widget. Para isso, precisamos nome√°-la. Na implementa√ß√£o de deep links do Nuvigator, √© poss√≠vel passar argumentos tanto como parte do path como via query string, sem configura√ß√£o adicional na rota. O gerador de c√≥digo verifica o nome dos argumentos que a rota recebe e sabe tratar automaticamente, inclusive convertendo para o tipo final (`int` neste caso) para alguns tipos simples como `String`, `int`, `double`, `bool` e `DateTime` a partir da vers√£o 0.6.0. \n\n```dart\n// app_router.dart\n\n@NuRoute(deepLink: '/second') // Adicionamos o link para esta rota\nScreenRoute<void> secondScreen({int magicNumber}) => ScreenRoute(\n  builder: (context) => FirstScreen(magicNumber: magicNumber)\n)\n```\n```dart\n// first_screen.dart\n\nclass FirstScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('First Screen'),\n      ),\n      body: Center(\n        child: RaisedButton(\n          child: Text('Open route'),\n          onPressed: () => \n            Nuvigator.of(context).openDeepLink(Uri.parse('/second?magicNumber=42')),\n        ),\n      ),\n    );\n  }\n}\n```\n\nO uso de deep links pode gerar algum acomplamento se eles ficarem espalhados pela aplica√ß√£o, mas √© bem √∫til para, por exemplo, definir no back-end da aplica√ß√£o qual rota abrir. O app recebe a string do deep link e pode abri-lo a partir de alguma intera√ß√£o do usu√°rio. Esse comportamento √© particularmente interessante em BFFs (back-ends for front-ends).\n\nEm algumas situa√ß√µes, voc√™ pode querer navegar para um **fluxo** ao inv√©s de uma tela. Um fluxo √© uma sequ√™ncia de telas que s√£o agrupadas entre si e que, em algum momento (usualmente no fim do fluxo), voc√™ pode fechar todas elas de uma vez s√≥ e voltar para onde estava antes de chamar o fluxo. O Nuvigator d√° suporte a defini√ß√£o de fluxos atrav√©s de **Nuvigators aninhados**, que √© criar uma rota cujo widget √© outro Nuvigator. Este √© um trecho de c√≥digo do app de exemplo no projeto do Nuvigator:\n\n```dart\n// sample_router.dart (do app de exemplo do Nuvigator)\n\n@NuRoute(deepLink: '/friendRequests')\nScreenRoute<String> friendRequests() =>\n    ScreenRoute(\n      builder: Nuvigator(\n        router: FriendRequestRouter(),\n        initialRoute: FriendRequestRoutes.listRequests,\n        screenType: materialScreenType,\n      ),\n    );\n```\n\nNeste caso, ao inv√©s de retornar um widget para a rota `/friendRequest`, estamos retornando um novo Nuvigator com um novo Router. O Nuvigator consegue lidar com esse aninhamento e, caso alguma tela dentro do fluxo chame a fun√ß√£o de navega√ß√£o `closeFlow()`, provida pelo Nuvigator, ela vai fechar todas as telas que fazem parte do mesmo fluxo, voltando para onde o usu√°rio estava antes de chamar o fluxo pela primeira vez. Para a tela que vai chamar o fluxo, nada muda. Ela apenas vai abrir uma rota via fun√ß√£o ou via deep link. A rota inclusive pode receber argumentos, se necess√°rio.\n\n## O que eu ganho com isso?\n\nO Nuvigator foi feito para automatizar tarefas como a cria√ß√£o de boilerplate para definir rotas. Originalmente, esse trabalho √© feito manualmente. Ele pode tamb√©m n√£o ser feito e o c√≥digo de roteamento ficar espalhado pela aplica√ß√£o.\n\nPara apps pequenos com fluxos simples, os benef√≠cios podem n√£o parecer relevantes junto a introdu√ß√£o de gera√ß√£o de c√≥digo, uma depend√™ncia nova e classes com anota√ß√µes. Mas onde o Nuvigator brilha s√£o em projetos maiores que t√™m multiplos fluxos, com suporte a Nuvigators e Routers aninhados, hierarquia de deep links, classes de argumentos autogeradas, cria√ß√£o de fun√ß√µes para diferentes tipos de roteamento para uma mesma tela, e gerenciamento de alguns comportamentos mais complicados de navega√ß√£o.\n\nIndependente de usar o Nuvigator ou n√£o, uma sugest√£o que deixo √© definir **algum padr√£o** para navega√ß√£o na aplica√ß√£o. O Nuvigator, apesar de razoavelmente gen√©rico, tem um pouco de opini√£o sobre como estruturar essa navega√ß√£o, e essa abordagem pode ser √∫til ou n√£o para o seu projeto.\n\n## Quero saber mais!\n\nNo reposit√≥rio do Nuvigator, h√° um [projeto de exemplo](https://github.com/nubank/nuvigator/tree/master/example) para demonstrar algumas dessas funcionalidades em uso. Inclusive, recentemente, eu subi um pull request para refatorar este projeto e facilitar o entendimento de cada demonstra√ß√£o. Nele h√° tamb√©m exemplos de usos mais complexos como um Bloc envelopando todas as telas de um Nuvigator aninhado usando o pacote [Provider](https://pub.dev/packages/provider) e a fun√ß√£o `wrapper` do Nuvigator. Experimente executar o projeto num simulador e olhar o c√≥digo-fonte dele.\n\nO [Readme](https://github.com/nubank/nuvigator/blob/master/README.md) do Nuvigator explica cada um dos conceitos que ele introduz com exemplos, tamb√©m. H√° uma sess√£o espec√≠fica sobre gera√ß√£o de c√≥digo que mostra quais classes e extens√µes s√£o geradas e para que cada uma serve. Se algo n√£o estiver claro, pode abrir uma issue no GitHub (em ingl√™s ou em portugu√™s) que algu√©m vai te ajudar!\n","readingTime":12,"summary":"Um dos aspectos mais importantes de um app √© a **navega√ß√£o entre telas**. Na web, isso √© feito atrav√©s de links (e, com a alta dos frameworks de front-end JavaScript, reimplementando esta navega√ß√£o no cliente). Num app em Flutter, existem fun√ß√µes de navega√ß√£o para transicionar de uma tela para outra. Com elas √© poss√≠vel empilhar, substituir e remover telas criando o pr√≥prio widget da tela seguinte nestas fun√ß√µes.\n\nO **Nuvigator** surgiu como uma abstra√ß√£o em cima desse roteamento do Flutter para facilitar a declara√ß√£o e reutiliza√ß√£o destas rotas, o que √© bem √∫til conforme o app cresce e tem mais partes que interagem. Trouxe uma introdu√ß√£o a como ele funciona neste post!\n\n"}},"path":"navegacao-por-rotas-em-flutter-usando-o-nuvigator"}
