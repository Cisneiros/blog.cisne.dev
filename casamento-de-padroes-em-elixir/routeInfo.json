{"template":"__react_static_root__/src/containers/post","sharedHashesByProp":{},"data":{"postData":{"title":"Casamento de padr√µes em Elixir","date":"2020-10-16T00:00:00-03:00","slug":"casamento-de-padroes-em-elixir","tags":["elixir"],"filePath":"2020-10-16-casamento-de-padroes-em-elixir.md","content":"Um desafio de programa√ß√£o √© conseguir escrever c√≥digo de maneira mais sucinta sem sacrificar a facilidade de compreens√£o. √â comum ver solu√ß√µes de uma linha que resolvem o problema e ningu√©m entende como elas funcionam. Pensando nisso, algumas linguagens trazem sintaxe que permite escrever, de maneira idiom√°tica, c√≥digo mais expressivo. Um exemplo disso √© **casamento de padr√µes**. Recentemente, comecei a estudar Elixir, e fiquei feliz em descobrir que _pattern matching_ √© uma parte importante da linguagem e resolvi trazer um pouco disso pra c√°!\n\n<!-- summary-break -->\n\nCasamento de padr√µes √© uma maneira de verificar se uma estrutura de dados tem um determinado formato. Nessa verifica√ß√£o, √© poss√≠vel extrair informa√ß√£o dessa estrutura. Um exemplo da intui√ß√£o de casamento de padr√µes √© o _destructuring_, bastante comum em JavaScript moderno:\n\n```js\nconst person = { name: 'Jane Doe', age: 31 }\nconst { name } = person\nconsole.log(name) // Imprime 'Jane Doe'\n```\n\nNeste exemplo, na segunda linha, n√≥s afirmamos que a estrutura de dados `person` tem o formato de um objeto com uma chave `name`. Como esse nome de vari√°vel est√° livre, atribuimos a ele o valor do atributo `name` do objeto. Destructuring por√©m apenas permite casar um objeto com uma lista de atributos, ou um array com uma lista de posi√ß√µes. Ele n√£o nos permite fazer afirma√ß√µes mais espec√≠ficas sobre o formato da estrutura de dados ou despachar de maneira condicional a este formato.\n\n## Casando padr√µes em Elixir\n\nElixir √© uma linguagem em que casamento de padr√µes faz parte de suas pr√°ticas idiom√°ticas. Nela, casamento de padr√µes nos permite fazer destructuring como no exemplo em JavaScript, por√©m tamb√©m nos permite ir bem al√©m. Vamos come√ßar com a sintaxe de casamento de padr√µes e depois ver algumas aplica√ß√µes.\n\nEm Elixir, o operador `=` √© chamado de operador de **match** (casamento), e n√£o de atribui√ß√£o como em outras linguagens. Ele executa um casamento de padr√µes entre o lado esquerdo e direito do operador.\n\n```elixir\nx = {:alice, :bob}\n# Note que, em Elixir, `{}` delimitam uma tupla e n√£o um objeto ou mapa, como em JavaScript. \n```\n\nNo exemplo acima, estamos fazendo um match de `x` com a tupla `{:alice, :bob}`. `x` √© um identificador e a tupla √© uma estrutura de dados. √â poss√≠vel que `x` tenha o mesmo formato que a tupla? Sim, se `x` tiver como valor `{:alice, :bob}`. E √© isso que vai acontecer a partir dessa linha. Quando colocamos apenas um identificador do lado esquerdo do match, o operador funciona exatamente como uma atribui√ß√£o.\n\n```elixir\n{:alice, other_name} = {:alice, :bob}\nIO.puts(other_name) # Imprime :bob\n```\n\nNeste exemplo, fazemos um destructuring usando casamento de padr√µes. N√≥s definimos, do lado direito, que temos uma tupla cujo formato √© ter `:alice` no primeiro elemento e um identificador `other_name` no segundo elemento. Em seguida, casamos isso com a tupla `{:alice, :bob}`. A √∫nica maneira de esse casamento dar certo √© se `other_name` tiver o valor `:bob`, e √© isso que vai acontecer nessa linha.\n\nNote que s√≥ podemos usar identificadores para atribuir vari√°veis em casamento de padr√µes do lado esquerdo do operador de match. Do contr√°rio recebemos um erro de compila√ß√£o.\n\n```elixir\n{:alice, :bob} = {:alice, other_name}\n# ** (CompileError) iex:1: undefined function other_name/0\n```\n\nSimilarmente, recebemos um erro se os padr√µes n√£o casarem:\n\n```elixir\n{:alice, other_name} = {:charlie, :bob}\n# ** (MatchError) no match of right hand side value: {:charlie, :bob}\n```\n\nPodemos casar outras estruturas de dados, tamb√©m. Mapas, delimitados com `%{}`, podem casar com um subconjunto das suas chaves e listas podem casar com outra lista de mesmo tamanho ou com uma representa√ß√£o no formato `[cabe√ßa_da_lista | resto_da_lista]`:\n\n```elixir\n%{first_name: name} = %{first_name: \"Jane\", last_name: \"Doe\"}\nIO.puts(name) # Imprime \"Jane\"\n\n[first_item | other_items] = [1, 2, 3, 4, 5]\nIO.puts(first_item) # Imprime 1\nIO.puts(other_items) # Imprime [2, 3, 4, 5]\n```\n\nComo comentei no come√ßo, identificadores no lado esquerdo do operador s√£o tratados como uma atribui√ß√£o de vari√°vel, usando o valor que casa do lado direito. √â poss√≠vel evitar essa atribui√ß√£o e usar uma vari√°vel do lado esquerdo do operador de **pin** (fixa√ß√£o), `^`. Com ele, podemos fixar o valor da vari√°vel do lado esquerdo e us√°-lo como parte do padr√£o a casar, e n√£o como um destino para uma atribui√ß√£o.\n\n```elixir\nresult = :ok\n{^result, message} = {:ok, \"Your request was processed\"}\nIO.puts(message) # Imprime \"Your request was processed\" e n√£o muda o valor de result\n\n{^result, message} = {:error, \"Your request was not processed\"}\n# ** (MatchError) no match of right hand side value: {:error, \"Your request was not processed\"}\n```\n\n## Despachando com casamento de padr√µes\n\nAt√© agora vimos como casar padr√µes em Elixir. Por√©m, com o que vimos n√≥s conseguimos apenas fazer atribui√ß√µes de vari√°veis e destrucutring, al√©m de gerar um erro quando o padr√£o n√£o casa. Tirando o erro, n√£o temos nada muito novo. Por√©m, podemos aplicar casamento de padr√µes a **condicionais e fun√ß√µes** para tomar caminhos diferentes no programa de acordo com o casamento ou n√£o de padr√µes.\n\n```elixir\n# Imagine uma consulta ao banco de dados que retorna quantos elementos existem.\n# O retorno √© uma tupla com um c√≥digo de status e um valor.\nresult = {:ok, 50}\n\nmessage = case result do\n  {:ok, element_count} -> \"There are #{element_count} elements\"\n  {:error, error_message} -> \"An error occurred: #{error_message}\"\nend\n\nIO.puts(message) # Imprime \"There are 50 elements\"\n```\n\nPodemos usar a estrutura de controle `case` para casar padr√µes. Ela recebe uma entrada, `result` no nosso exemplo, e uma lista de poss√≠veis padr√µes para tentar casar. Caso haja algum que d√™ match, o valor para que ele aponta (`->`) √© retornado pelo `case`. Note que a lista de padr√µes a casar √© equivalente ao **lado esquerdo** do operador de match. Ou seja, podemos colocar identificadores que se tornam vari√°veis no corpo ap√≥s o `->` e podem ser usados no valor retornado.\n\n√â poss√≠vel que o valor de entrada case com mais de um padr√£o, dependendo de como a lista seja especificada. Por isso, **a ordem importa**. Quando o primeiro padr√£o casar, os seguintes ser√£o ignorados.\n\nVamos re-escrever o exemplo acima numa fun√ß√£o para testar os diferentes retornos poss√≠veis:\n\n```elixir\ndefmodule MockDB do\n  def display_result(result) do\n    case result do\n      {:ok, element_count} -> \"There are #{element_count} elements\"\n      {:error, error_message} -> \"An error occurred: #{error_message}\"\n    end\n  end\nend\n\nMockDB.display_result({:ok, 42})\n# Imprime \"There are 42 elements\"\n\nMockDB.display_result({:error, \"DB is offline\"})\n# Imprime \"An error occurred: DB is offline\"\n\nMockDB.display_result({:palha_italiana, \"Really tasty\"})\n# ** (CaseClauseError) no case clause matching: {:palha_italiana, \"Really tasty\"}\n#     iex:10: MockDB.display_result/1\n```\n\nCaso n√£o haja um padr√£o que case, tomamos um erro. √â poss√≠vel tratar esse caso garantindo que, ao fim da lista, sempre haver√° um padr√£o que case. Podemos colocar um identificador qualquer (`x -> \"????\"`), mas isso vai criar uma vari√°vel local de que n√£o precisamos. Ao inv√©s de usar `x`, podemos usar o identificador especial `_`. N√£o √© poss√≠vel ler dessa vari√°vel, e podemos atribuir a ela sem nos importar.\n\nAl√©m disso, podemos ter casamentos com partes similares, desde que a mais espec√≠fica fique acima da mais geral. Por exemplo, podemos querer tratar separadamente o caso em que haja exatamente um elemento retornado.\n\n```elixir\ndefmodule MockDB do\n  def display_result(result) do\n    case result do\n      {:ok, 1} -> \"There is only one element\"\n      {:ok, element_count} -> \"There are #{element_count} elements\"\n      {:error, error_message} -> \"An error occurred: #{error_message}\"\n      _ -> \"????\"\n    end\n  end\nend\n\nMockDB.display_result({:ok, 1})\n# Imprime \"There is only one element\"\n\nMockDB.display_result({:palha_italiana, \"Really tasty\"})\n# Imprime \"????\"\n```\n\nO `case` n√£o √© a √∫nica maneira de despachar de acordo com casamento de padr√µes! Como comentei, Elixir define casamento de padr√µes como parte idiom√°tica da linguagem, e seu uso vai al√©m disso. Podemos usar casamento de padr√µes para **mudar a execu√ß√£o de uma fun√ß√£o**. Vamos re-escrever o exemplo acima mais uma vez, com essa ideia:\n\n```elixir\ndefmodule MockDB do\n  def display_result({:ok, 1}) do\n    \"There is only one element\"\n  end\n\n  def display_result({:ok, element_count}) do\n    \"There are #{element_count} elements\"\n  end\n\n  def display_result({:error, error_message}) do\n    \"An error occurred: #{error_message}\"\n  end\n\n  def display_result(_) do\n    \"????\"\n  end\nend\n\nMockDB.display_result({:ok, 1})\n# Imprime \"There is only one element\"\n\nMockDB.display_result({:ok, 42})\n# Imprime \"There are 42 elements\"\n\nMockDB.display_result({:error, \"DB is offline\"})\n# Imprime \"An error occurred: DB is offline\"\n\nMockDB.display_result({:palha_italiana, \"Really tasty\"})\n# Imprime \"????\"\n```\n\n**Podemos usar casamento de padr√µes nos argumentos de uma fun√ß√£o.** Declaramos mais de uma vez uma mesma fun√ß√£o, por√©m em cada declara√ß√£o, definimos um padr√£o diferente para o primeiro argumento. Cada vez que essa fun√ß√£o for chamada, Elixir vai, em ordem, tentar casar os argumentos com os padr√µes e, quando encontrar um casamento que d√™ match, o corpo dessa declara√ß√£o √© executado.\n\nNossas fun√ß√µes neste caso apenas retornam strings, mas nada impede que cada uma fa√ßa algo totalmente diferente. Isso nos permite, rapidamente, saber que formatos de dados essa fun√ß√£o est√° pronta para lidar. Como definimos um padr√£o que sempre vai casar com qualquer coisa (o `_`), essa fun√ß√£o nunca vai retornar um erro de casamento de padr√µes.\n\nVamos ver outro exemplo, dessa vez fazendo casamento um valor mais simples. Ao inv√©s de casar uma tupla, vamos casar um n√∫mero. Podemos fazer isso para implementar um [c√°lculo de fatorial](https://pt.wikipedia.org/wiki/Fatorial). O fatorial de um n√∫mero `n` √© o produto de todos os n√∫meros inteiros de 1 at√© `n`. Fora isso, por defini√ß√£o, o fatorial de zero √© 1. \n\n```elixir\n# Defini√ß√£o de como funciona o fatorial\nfactorial(0) == 1\nfactorial(n) == n * factorial(n - 1)\n```\n\nPodemos implementar esse fatorial, de maneira recursiva, usando casamento de padr√µes.\n\n```elixir\ndefmodule Math do\n  def factorial(number) do\n    factorial(number, 1)\n  end\n\n  defp factorial(0, current_product) do\n    current_product\n  end\n\n  defp factorial(number, current_product) do\n    factorial(number - 1, number * current_product)\n  end\nend\n\nMath.factorial(0) # Retorna 1\nMath.factorial(1) # Retorna 1\nMath.factorial(20) # Retorna 2432902008176640000\n```\n\nTemos duas fun√ß√µes: uma que recebe um argumento (tamb√©m chamada de `Math.factorial/1`) e outra que recebe dois argumentos (chamada `Math.factorial/2`). A primeira serve apenas de conveni√™ncia, e √© p√∫blica. Ela chama a segunda inicializando o produto com `1`. Na fun√ß√£o com dois argumentos √© que temos um casamento de padr√µes. Vamos tentar, primeiramente, casar o primeiro argumento com o padr√£o `0`. A √∫nica maneira desse casamento bater √© se o argumento for, de fato, `0`.\n\nSe o padr√£o casa, n√≥s retornamos o produto acumulado at√© agora (segundo argumento da fun√ß√£o). Se ele n√£o casa, n√≥s tentamos a segunda defini√ß√£o da fun√ß√£o. Na segunda defini√ß√£o, o casamento vai com certeza acontecer pois temos apenas identificadores em todos os argumentos. O que essa defini√ß√£o faz √© chamar, recursivamente, a fun√ß√£o subtraindo 1 do primeiro argumento e multiplicando o produto acumulado pelo primeiro argumento. \n\nLembre-se que a **ordem √© importante no casamento de padr√µes**. Se invert√™ssemos e coloc√°ssemos o caso em que o primeiro argumento √© `0` embaixo, ele nunca seria executado pois o valor `0` iria casar com o outro caso primeiro, o que √© apenas uma vari√°vel `number`.\n\nUm benef√≠cio adicional dessa implementa√ß√£o √© que ela √© uma [recurs√£o de cauda](https://pt.wikipedia.org/wiki/Recursividade_(ci√™ncia_da_computa√ß√£o)#Fun√ß√µes_recursivas_em_cauda) (_tail recursion_), ou seja, cada itera√ß√£o da recurs√£o n√£o precisa de espa√ßo adicional na pilha de chamadas de fun√ß√£o. Isso √© √∫til pois, do contr√°rio, ao tentar calcular um fatorial muito grande podemos ter um erro de estouro de pilha. Note tamb√©m que, caso voc√™ passe um valor negativo para a fun√ß√£o, ela vai executar infinitamente. Uma maneira de evitar isso √© usando [guards](https://hexdocs.pm/elixir/guards.html).\n\n## Pra onde vou agora?\n\nTrouxe aqui um pouco de como funciona casamento de padr√µes em Elixir e alguns exemplos de como utilizar para escrever condi√ß√µes mais claras. Com isso, conseguimos por exemplo separar fluxos de execu√ß√£o de acordo com o formato de uma estrutura de dados.\n\nA documenta√ß√£o oficial de Elixir √© bem detalhada e traz ainda mais conte√∫do sobre o assunto. Eu comecei a usar a linguagem para aprender, e os tutoriais da documenta√ß√£o ajudaram bastante. Se voc√™ quer come√ßar, sugiro partir do [guia de introdu√ß√£o](https://elixir-lang.org/getting-started/introduction.html) e seguir o passo a passo. Sobre esses assuntos que vimos, essas p√°ginas s√£o bem √∫teis:\n\n- [Pattern matching](https://elixir-lang.org/getting-started/pattern-matching.html)\n- [case, cond, and if](https://elixir-lang.org/getting-started/case-cond-and-if.html)\n- [Modules and functions](https://elixir-lang.org/getting-started/modules-and-functions.html)\n- [Recursion](https://elixir-lang.org/getting-started/recursion.html)\n\nE se esse post te trouxe ideias, ou se tem sugest√µes de como melhorar algum dos exemplos, [me d√° um oi no Twitter](https://twitter.com/Cisneiros)! üëã\n","readingTime":11,"summary":"Um desafio de programa√ß√£o √© conseguir escrever c√≥digo de maneira mais sucinta sem sacrificar a facilidade de compreens√£o. √â comum ver solu√ß√µes de uma linha que resolvem o problema e ningu√©m entende como elas funcionam. Pensando nisso, algumas linguagens trazem sintaxe que permite escrever, de maneira idiom√°tica, c√≥digo mais expressivo. Um exemplo disso √© **casamento de padr√µes**. Recentemente, comecei a estudar Elixir, e fiquei feliz em descobrir que _pattern matching_ √© uma parte importante da linguagem e resolvi trazer um pouco disso pra c√°!\n\n"}},"path":"casamento-de-padroes-em-elixir"}
