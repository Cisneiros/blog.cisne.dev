<!DOCTYPE html><html lang="pt-BR" class=" "><head><meta name="generator" content="React Static"/><title data-react-helmet="true">Casamento de padr√µes em Elixir ¬∑ Cisne.dev blog</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:creator" content="Cisneiros"/><meta data-react-helmet="true" property="og:title" content="Casamento de padr√µes em Elixir ¬∑ Cisne.dev blog"/><meta data-react-helmet="true" property="og:image" content="https://blog.cisne.dev/casamento-de-padroes-em-elixir/social-image.png"/><meta data-react-helmet="true" name="twitter:title" content="Casamento de padr√µes em Elixir ¬∑ Cisne.dev blog"/><meta data-react-helmet="true" name="twitter:image" content="https://blog.cisne.dev/casamento-de-padroes-em-elixir/social-image.png"/><link rel="preload" as="script" href="/templates/vendors~__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.207edc50.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.a04ea84b.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/post.d8dd52db.js"/><link rel="preload" as="script" href="/templates/vendors~main.272ae1d1.js"/><link rel="preload" as="script" href="/main.f19d4c14.js"/><link data-react-helmet="true" rel="stylesheet" href="//unpkg.com/dracula-prism/dist/css/dracula-prism.min.css"/><style data-styled="" data-styled-version="5.1.1">.CfxHf{max-width:960px;margin:0 auto;position:relative;}/*!sc*/
data-styled.g1[id="ui__Fit-prwz6b-0"]{content:"CfxHf,"}/*!sc*/
.iuDFSN{padding:1rem;color:var(--color-mid);text-align:center;font-size:1.5rem;}/*!sc*/
.iuDFSN a,.iuDFSN a:hover{-webkit-text-decoration:none;text-decoration:none;color:inherit;}/*!sc*/
data-styled.g2[id="Navigation__Container-sc-1yk0pqp-0"]{content:"iuDFSN,"}/*!sc*/
.izuwCZ{max-width:960px;margin:0 auto;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
data-styled.g3[id="Navigation__NavFit-sc-1yk0pqp-1"]{content:"izuwCZ,"}/*!sc*/
.TctaC{width:2.5rem;height:1.2em;overflow:hidden;--default-rotation:-180deg;}/*!sc*/
@media (prefers-color-scheme:dark){.TctaC{--default-rotation:0;}}/*!sc*/
data-styled.g4[id="Navigation__BrightnessContainer-sc-1yk0pqp-2"]{content:"TctaC,"}/*!sc*/
.sLeDt{-webkit-transform:rotate(var(--default-rotation));-ms-transform:rotate(var(--default-rotation));transform:rotate(var(--default-rotation));-webkit-transition:-webkit-transform 0.3s ease-out;-webkit-transition:transform 0.3s ease-out;transition:transform 0.3s ease-out;}/*!sc*/
html.light .sLeDt{-webkit-transform:rotate(-180deg);-ms-transform:rotate(-180deg);transform:rotate(-180deg);}/*!sc*/
html.dark .sLeDt{-webkit-transform:rotate(0);-ms-transform:rotate(0);transform:rotate(0);}/*!sc*/
data-styled.g5[id="Navigation__BrightnessSpinner-sc-1yk0pqp-3"]{content:"sLeDt,"}/*!sc*/
.frsARl{background:none;border:none;cursor:pointer;}/*!sc*/
.frsARl:last-child{-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg);}/*!sc*/
data-styled.g7[id="Navigation__BrightnessIcon-sc-1yk0pqp-5"]{content:"frsARl,"}/*!sc*/
.gdHjSq{margin-top:3rem;padding:1rem;background:var(--color-foreground);color:var(--color-background);}/*!sc*/
.gdHjSq a{color:var(--text-inverse-color-1);}/*!sc*/
.gdHjSq a:hover{color:var(--text-inverse-color-3);}/*!sc*/
data-styled.g8[id="Footer__Container-b3q04c-0"]{content:"gdHjSq,"}/*!sc*/
.layJcq{max-width:960px;margin:0 auto;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
data-styled.g9[id="Footer__FooterFit-b3q04c-1"]{content:"layJcq,"}/*!sc*/
*{box-sizing:border-box;margin:0;padding:0;border:0;font-size:inherit;font-weight:inherit;font-style:inherit;}/*!sc*/
:root{--color-1:#12c2e9;--color-2:#c471ed;--color-3:#f64f59;--color-1-darker:#0A7B94;--color-2-darker:#AE3CE7;--color-3-darker:#E90C1B;--color-light:#fefefe;--color-dark:#030303;--color-mid-dark:#747481;--color-mid-light:#818181;--font-weight-light:300;--font-weight-regular:400;--font-weight-heavy:500;--font-family-light:"HelveticaNeue-Light","Helvetica Neue Light",'Helvetica Neue',sans-serif;--font-family:'Helvetica Neue',sans-serif;}/*!sc*/
strong,h1,h2,h3,h4,h5,h6{font-family:var(--font-family);}/*!sc*/
html{font-family:var(--font-family-light);font-size:20px;line-height:1;color:var(--color-foreground);background-color:var(--color-background);text-rendering:optimizeLegibility;}/*!sc*/
@media (max-width:600px){html{font-size:16px;}}/*!sc*/
html,html.light{--color-background:var(--color-light);--color-foreground:var(--color-dark);--color-mid:var(--color-mid-dark);--text-color-1:var(--color-1-darker);--text-color-2:var(--color-2-darker);--text-color-3:var(--color-3-darker);--text-inverse-color-1:var(--color-1);--text-inverse-color-2:var(--color-2);--text-inverse-color-3:var(--color-3);}/*!sc*/
html.dark{--color-background:var(--color-dark);--color-foreground:var(--color-light);--color-mid:var(--color-mid-light);--text-color-1:var(--color-1);--text-color-2:var(--color-2);--text-color-3:var(--color-3);--text-inverse-color-1:var(--color-1-darker);--text-inverse-color-2:var(--color-2-darker);--text-inverse-color-3:var(--color-3-darker);}/*!sc*/
@media (prefers-color-scheme:dark){html{--color-background:var(--color-dark);--color-foreground:var(--color-light);--color-mid:var(--color-mid-light);}}/*!sc*/
body{font-size:1em;font-weight:var(--font-weight-light);}/*!sc*/
strong{font-weight:var(--font-weight-heavy);}/*!sc*/
em{font-style:italic;}/*!sc*/
main{padding:1rem;}/*!sc*/
hr{width:30%;margin:4rem auto;border:none;border-bottom:dotted 1px var(--color-1);}/*!sc*/
.pagination{text-align:center;}/*!sc*/
.pagination a{color:var(--text-color-1);}/*!sc*/
.pagination a:hover{color:var(--text-color-3);}/*!sc*/
a{color:var(--text-color-1);-webkit-text-decoration-color:#c471ed80;text-decoration-color:#c471ed80;-webkit-text-decoration-style:wavy;text-decoration-style:wavy;}/*!sc*/
a:hover{color:var(--text-color-3);-webkit-text-decoration-color:#12c2e980;text-decoration-color:#12c2e980;}/*!sc*/
.phone-mockup{max-width:15rem;margin:0 auto 1rem;position:relative;}/*!sc*/
.phone-mockup::before{content:'';width:100%;height:100%;position:absolute;pointer-events:none;background:url(/iphone-11-pro.png) no-repeat;background-size:contain;}/*!sc*/
.phone-mockup video,.phone-mockup img{width:100%;padding:9.3%;}/*!sc*/
data-styled.g14[id="sc-global-hFBrmQ1"]{content:"sc-global-hFBrmQ1,"}/*!sc*/
.tuaWG{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
@media (max-width:600px){.tuaWG{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}/*!sc*/
data-styled.g23[id="Poststyles__AfterPost-sc-12qb97v-0"]{content:"tuaWG,"}/*!sc*/
.gkeqUt{-webkit-flex:1;-ms-flex:1;flex:1;}/*!sc*/
@media (max-width:600px){.gkeqUt{text-align:center;margin-bottom:1rem;}}/*!sc*/
data-styled.g24[id="Poststyles__AfterPostChild-sc-12qb97v-1"]{content:"gkeqUt,"}/*!sc*/
.fAvgXR{-webkit-flex:1;-ms-flex:1;flex:1;text-align:right;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
@media (max-width:600px){.fAvgXR{text-align:center;margin-bottom:1rem;}}/*!sc*/
data-styled.g25[id="Poststyles__Tags-sc-12qb97v-2"]{content:"fAvgXR,"}/*!sc*/
.kSZCZX::before{content:' #';color:var(--color-mid);}/*!sc*/
data-styled.g26[id="Poststyles__Tag-sc-12qb97v-3"]{content:"kSZCZX,"}/*!sc*/
.kyWzPB{-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;hyphens:auto;}/*!sc*/
data-styled.g27[id="Poststyles__Container-sc-12qb97v-4"]{content:"kyWzPB,"}/*!sc*/
.hhBwVH{font-size:5rem;font-weight:var(--font-weight-regular);line-height:0.8;background:linear-gradient(var(--color-1),var(--color-2),var(--color-3));-webkit-text-fill-color:transparent;background-clip:text;-webkit-background-clip:text;padding-bottom:1rem;margin:1rem 0;}/*!sc*/
html.rainbow .hhBwVH{background-image:linear-gradient(124deg,#ff2400,#e81d1d,#e8b71d,#e3e81d,#1de840,#1ddde8,#2b1de8,#dd00f3,#dd00f3);-webkit-animation:hTUzwZ 9s ease infinite;animation:hTUzwZ 9s ease infinite;background-size:450% 450%;}/*!sc*/
@media (max-width:600px){.hhBwVH{font-size:3.5rem;}}/*!sc*/
.hhBwVH a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g28[id="Poststyles__Title-sc-12qb97v-5"]{content:"hhBwVH,"}/*!sc*/
.fonWHZ{color:var(--color-mid);text-align:center;margin-bottom:2rem;}/*!sc*/
data-styled.g29[id="Poststyles__Meta-sc-12qb97v-6"]{content:"fonWHZ,"}/*!sc*/
.jhgzPU{line-height:1.6;}/*!sc*/
.jhgzPU h2{font-size:2.5rem;}/*!sc*/
.jhgzPU h3{font-size:2rem;}/*!sc*/
.jhgzPU h4{font-size:1.5rem;}/*!sc*/
.jhgzPU h2,.jhgzPU h3,.jhgzPU h4,.jhgzPU h5,.jhgzPU h6{-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;hyphens:auto;font-weight:var(--font-weight-regular);line-height:0.8;padding-bottom:1rem;margin-top:2rem;}/*!sc*/
.jhgzPU img{max-width:100%;}/*!sc*/
.jhgzPU pre.refractor{margin-top:0;margin-left:0;padding-left:1rem;border-left:solid 0.25rem var(--color-1);border-radius:0;font-size:0.8rem;overflow-wrap:normal;overflow-x:auto;background-color:var(--color-dark);color:var(--color-light);padding-top:0.5rem;padding-bottom:0.5rem;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
.jhgzPU pre.refractor::-webkit-scrollbar{width:0.25rem;height:0.25rem;}/*!sc*/
.jhgzPU pre.refractor code,.jhgzPU code{font-family:'Fira Code','Menlo',monospace;}/*!sc*/
.jhgzPU p code{color:var(--text-color-3);}/*!sc*/
.jhgzPU p code,.jhgzPU h1 code,.jhgzPU h2 code,.jhgzPU h3 code,.jhgzPU h4 code,.jhgzPU h5 code,.jhgzPU h6 code{font-size:0.9em;}/*!sc*/
.jhgzPU p,.jhgzPU pre,.jhgzPU ul,.jhgzPU ol,.jhgzPU table,.jhgzPU blockquote,.jhgzPU .live-code-container{margin-bottom:1rem;}/*!sc*/
.jhgzPU twitter-widget{margin-bottom:1rem !important;}/*!sc*/
.jhgzPU p:last-child,.jhgzPU pre:last-child,.jhgzPU ul:last-child,.jhgzPU ol:last-child,.jhgzPU table:last-child,.jhgzPU blockquote:last-child,.jhgzPU .live-code-container:last-child{margin-bottom:0;}/*!sc*/
.jhgzPU ul,.jhgzPU ol{list-style:none;margin-left:1rem;counter-reset:li;}/*!sc*/
.jhgzPU li{counter-increment:li;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}/*!sc*/
.jhgzPU ul li::before{content:'‚Ä¢';margin-right:0.5rem;color:var(--color-2);}/*!sc*/
.jhgzPU ol li::before{content:"."counter(li);margin-right:0.5rem;color:var(--color-2);font-weight:var(--font-weight-regular);width:1em;display:inline-block;margin-left:-0.5em;margin-right:0.5em;text-align:right;direction:rtl;}/*!sc*/
.jhgzPU table{margin-left:auto;margin-right:auto;border-spacing:0;font-size:0.9em;}/*!sc*/
.jhgzPU td,.jhgzPU th{border-bottom:solid 1px var(--color-2);padding:0.5rem;}/*!sc*/
.jhgzPU th{font-weight:var(--font-weight-heavy);}/*!sc*/
.jhgzPU tr:hover{background:var(--color-2);}/*!sc*/
.jhgzPU tr:last-of-type td{border-bottom:0;}/*!sc*/
.jhgzPU blockquote{padding-left:1rem;border-left:solid 0.25rem var(--color-3);color:var(--color-mid);}/*!sc*/
data-styled.g30[id="Poststyles__Content-sc-12qb97v-7"]{content:"jhgzPU,"}/*!sc*/
.jjKdZc{position:fixed;top:0;left:0;right:0;height:0.25rem;background-color:var(--color-1);-webkit-transition:opacity 0.25s ease-out;transition:opacity 0.25s ease-out;z-index:2;}/*!sc*/
data-styled.g31[id="post__ScrollTrackerContainer-gh0jqu-0"]{content:"jjKdZc,"}/*!sc*/
@-webkit-keyframes hTUzwZ{0%{background-position:0% 82%;}50%{background-position:100% 19%;}100%{background-position:0% 82%;}}/*!sc*/
@keyframes hTUzwZ{0%{background-position:0% 82%;}50%{background-position:100% 19%;}100%{background-position:0% 82%;}}/*!sc*/
data-styled.g32[id="sc-keyframes-hTUzwZ"]{content:"hTUzwZ,"}/*!sc*/
</style><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml"/></head><body><div id="root"><nav class="Navigation__Container-sc-1yk0pqp-0 iuDFSN"><div class="ui__Fit-prwz6b-0 Navigation__NavFit-sc-1yk0pqp-1 izuwCZ"><p class="logo"><a href="/">Cisne.dev blog</a></p><div class="Navigation__BrightnessContainer-sc-1yk0pqp-2 TctaC"><div class="Navigation__BrightnessSpinner-sc-1yk0pqp-3 sLeDt"><button title="Mudar para modo diurno" aria-label="Mudar para modo diurno" class="Navigation__ClearButton-sc-1yk0pqp-4 Navigation__BrightnessIcon-sc-1yk0pqp-5 frsARl">üåô</button><button title="Mudar para modo noturno" aria-label="Mudar para modo noturno" class="Navigation__ClearButton-sc-1yk0pqp-4 Navigation__BrightnessIcon-sc-1yk0pqp-5 frsARl">‚òÄÔ∏è</button></div></div></div></nav><main><div class="ui__Fit-prwz6b-0 CfxHf"><div><div style="width:0%;opacity:0" class="post__ScrollTrackerContainer-gh0jqu-0 jjKdZc"></div><article class="Poststyles__Container-sc-12qb97v-4 kyWzPB"><h1 class="Poststyles__Title-sc-12qb97v-5 hhBwVH"><a href="/casamento-de-padroes-em-elixir/">Casamento de padr√µes em Elixir</a></h1><p class="Poststyles__Meta-sc-12qb97v-6 fonWHZ">Publicado em <!-- -->16 out 2020<!-- -->. Uns <!-- -->11<!-- --> minutos de leitura.</p><div class="Poststyles__Content-sc-12qb97v-7 jhgzPU content"><p>Um desafio de programa√ß√£o √© conseguir escrever c√≥digo de maneira mais sucinta sem sacrificar a facilidade de compreens√£o. √â comum ver solu√ß√µes de uma linha que resolvem o problema e ningu√©m entende como elas funcionam. Pensando nisso, algumas linguagens trazem sintaxe que permite escrever, de maneira idiom√°tica, c√≥digo mais expressivo. Um exemplo disso √© <strong>casamento de padr√µes</strong>. Recentemente, comecei a estudar Elixir, e fiquei feliz em descobrir que <em>pattern matching</em> √© uma parte importante da linguagem e resolvi trazer um pouco disso pra c√°!</p><span><!-- summary-break --></span><p>Casamento de padr√µes √© uma maneira de verificar se uma estrutura de dados tem um determinado formato. Nessa verifica√ß√£o, √© poss√≠vel extrair informa√ß√£o dessa estrutura. Um exemplo da intui√ß√£o de casamento de padr√µes √© o <em>destructuring</em>, bastante comum em JavaScript moderno:</p><pre class="refractor language-js"><code class="language-js"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#x27;Jane Doe&#x27;</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">31</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> person
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// Imprime &#x27;Jane Doe&#x27;</span></code></pre><p>Neste exemplo, na segunda linha, n√≥s afirmamos que a estrutura de dados <code>person</code> tem o formato de um objeto com uma chave <code>name</code>. Como esse nome de vari√°vel est√° livre, atribuimos a ele o valor do atributo <code>name</code> do objeto. Destructuring por√©m apenas permite casar um objeto com uma lista de atributos, ou um array com uma lista de posi√ß√µes. Ele n√£o nos permite fazer afirma√ß√µes mais espec√≠ficas sobre o formato da estrutura de dados ou despachar de maneira condicional a este formato.</p><h2>Casando padr√µes em Elixir</h2><p>Elixir √© uma linguagem em que casamento de padr√µes faz parte de suas pr√°ticas idiom√°ticas. Nela, casamento de padr√µes nos permite fazer destructuring como no exemplo em JavaScript, por√©m tamb√©m nos permite ir bem al√©m. Vamos come√ßar com a sintaxe de casamento de padr√µes e depois ver algumas aplica√ß√µes.</p><p>Em Elixir, o operador <code>=</code> √© chamado de operador de <strong>match</strong> (casamento), e n√£o de atribui√ß√£o como em outras linguagens. Ele executa um casamento de padr√µes entre o lado esquerdo e direito do operador.</p><pre class="refractor language-elixir"><code class="language-elixir">x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> <span class="token atom symbol">:bob</span><span class="token punctuation">}</span>
<span class="token comment"># Note que, em Elixir, `{}` delimitam uma tupla e n√£o um objeto ou mapa, como em JavaScript. </span></code></pre><p>No exemplo acima, estamos fazendo um match de <code>x</code> com a tupla <code>{:alice, :bob}</code>. <code>x</code> √© um identificador e a tupla √© uma estrutura de dados. √â poss√≠vel que <code>x</code> tenha o mesmo formato que a tupla? Sim, se <code>x</code> tiver como valor <code>{:alice, :bob}</code>. E √© isso que vai acontecer a partir dessa linha. Quando colocamos apenas um identificador do lado esquerdo do match, o operador funciona exatamente como uma atribui√ß√£o.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> other_name<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> <span class="token atom symbol">:bob</span><span class="token punctuation">}</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>other_name<span class="token punctuation">)</span> <span class="token comment"># Imprime :bob</span></code></pre><p>Neste exemplo, fazemos um destructuring usando casamento de padr√µes. N√≥s definimos, do lado direito, que temos uma tupla cujo formato √© ter <code>:alice</code> no primeiro elemento e um identificador <code>other_name</code> no segundo elemento. Em seguida, casamos isso com a tupla <code>{:alice, :bob}</code>. A √∫nica maneira de esse casamento dar certo √© se <code>other_name</code> tiver o valor <code>:bob</code>, e √© isso que vai acontecer nessa linha.</p><p>Note que s√≥ podemos usar identificadores para atribuir vari√°veis em casamento de padr√µes do lado esquerdo do operador de match. Do contr√°rio recebemos um erro de compila√ß√£o.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> <span class="token atom symbol">:bob</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> other_name<span class="token punctuation">}</span>
<span class="token comment"># ** (CompileError) iex:1: undefined function other_name/0</span></code></pre><p>Similarmente, recebemos um erro se os padr√µes n√£o casarem:</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> other_name<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:charlie</span><span class="token punctuation">,</span> <span class="token atom symbol">:bob</span><span class="token punctuation">}</span>
<span class="token comment"># ** (MatchError) no match of right hand side value: {:charlie, :bob}</span></code></pre><p>Podemos casar outras estruturas de dados, tamb√©m. Mapas, delimitados com <code>%{}</code>, podem casar com um subconjunto das suas chaves e listas podem casar com outra lista de mesmo tamanho ou com uma representa√ß√£o no formato <code>[cabe√ßa_da_lista | resto_da_lista]</code>:</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">first_name:</span> name<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">first_name:</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">last_name:</span> <span class="token string">&quot;Doe&quot;</span><span class="token punctuation">}</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment"># Imprime &quot;Jane&quot;</span>

<span class="token punctuation">[</span>first_item <span class="token operator">|</span> other_items<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>first_item<span class="token punctuation">)</span> <span class="token comment"># Imprime 1</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>other_items<span class="token punctuation">)</span> <span class="token comment"># Imprime [2, 3, 4, 5]</span></code></pre><p>Como comentei no come√ßo, identificadores no lado esquerdo do operador s√£o tratados como uma atribui√ß√£o de vari√°vel, usando o valor que casa do lado direito. √â poss√≠vel evitar essa atribui√ß√£o e usar uma vari√°vel do lado esquerdo do operador de <strong>pin</strong> (fixa√ß√£o), <code>^</code>. Com ele, podemos fixar o valor da vari√°vel do lado esquerdo e us√°-lo como parte do padr√£o a casar, e n√£o como um destino para uma atribui√ß√£o.</p><pre class="refractor language-elixir"><code class="language-elixir">result <span class="token operator">=</span> <span class="token atom symbol">:ok</span>
<span class="token punctuation">{</span><span class="token operator">^</span>result<span class="token punctuation">,</span> message<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token string">&quot;Your request was processed&quot;</span><span class="token punctuation">}</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token comment"># Imprime &quot;Your request was processed&quot; e n√£o muda o valor de result</span>

<span class="token punctuation">{</span><span class="token operator">^</span>result<span class="token punctuation">,</span> message<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> <span class="token string">&quot;Your request was not processed&quot;</span><span class="token punctuation">}</span>
<span class="token comment"># ** (MatchError) no match of right hand side value: {:error, &quot;Your request was not processed&quot;}</span></code></pre><h2>Despachando com casamento de padr√µes</h2><p>At√© agora vimos como casar padr√µes em Elixir. Por√©m, com o que vimos n√≥s conseguimos apenas fazer atribui√ß√µes de vari√°veis e destrucutring, al√©m de gerar um erro quando o padr√£o n√£o casa. Tirando o erro, n√£o temos nada muito novo. Por√©m, podemos aplicar casamento de padr√µes a <strong>condicionais e fun√ß√µes</strong> para tomar caminhos diferentes no programa de acordo com o casamento ou n√£o de padr√µes.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token comment"># Imagine uma consulta ao banco de dados que retorna quantos elementos existem.</span>
<span class="token comment"># O retorno √© uma tupla com um c√≥digo de status e um valor.</span>
result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span>

message <span class="token operator">=</span> <span class="token keyword">case</span> result <span class="token keyword">do</span>
  <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> element_count<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;There are <span class="token interpolation"><span class="token delimiter punctuation">#{</span>element_count<span class="token delimiter punctuation">}</span></span> elements&quot;</span>
  <span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> error_message<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;An error occurred: <span class="token interpolation"><span class="token delimiter punctuation">#{</span>error_message<span class="token delimiter punctuation">}</span></span>&quot;</span>
<span class="token keyword">end</span>

IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token comment"># Imprime &quot;There are 50 elements&quot;</span></code></pre><p>Podemos usar a estrutura de controle <code>case</code> para casar padr√µes. Ela recebe uma entrada, <code>result</code> no nosso exemplo, e uma lista de poss√≠veis padr√µes para tentar casar. Caso haja algum que d√™ match, o valor para que ele aponta (<code>-&gt;</code>) √© retornado pelo <code>case</code>. Note que a lista de padr√µes a casar √© equivalente ao <strong>lado esquerdo</strong> do operador de match. Ou seja, podemos colocar identificadores que se tornam vari√°veis no corpo ap√≥s o <code>-&gt;</code> e podem ser usados no valor retornado.</p><p>√â poss√≠vel que o valor de entrada case com mais de um padr√£o, dependendo de como a lista seja especificada. Por isso, <strong>a ordem importa</strong>. Quando o primeiro padr√£o casar, os seguintes ser√£o ignorados.</p><p>Vamos re-escrever o exemplo acima numa fun√ß√£o para testar os diferentes retornos poss√≠veis:</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> MockDB <span class="token keyword">do</span>
  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token keyword">case</span> result <span class="token keyword">do</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> element_count<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;There are <span class="token interpolation"><span class="token delimiter punctuation">#{</span>element_count<span class="token delimiter punctuation">}</span></span> elements&quot;</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> error_message<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;An error occurred: <span class="token interpolation"><span class="token delimiter punctuation">#{</span>error_message<span class="token delimiter punctuation">}</span></span>&quot;</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;There are 42 elements&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> <span class="token string">&quot;DB is offline&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;An error occurred: DB is offline&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:palha_italiana</span><span class="token punctuation">,</span> <span class="token string">&quot;Really tasty&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># ** (CaseClauseError) no case clause matching: {:palha_italiana, &quot;Really tasty&quot;}</span>
<span class="token comment">#     iex:10: MockDB.display_result/1</span></code></pre><p>Caso n√£o haja um padr√£o que case, tomamos um erro. √â poss√≠vel tratar esse caso garantindo que, ao fim da lista, sempre haver√° um padr√£o que case. Podemos colocar um identificador qualquer (<code>x -&gt; &quot;????&quot;</code>), mas isso vai criar uma vari√°vel local de que n√£o precisamos. Ao inv√©s de usar <code>x</code>, podemos usar o identificador especial <code>_</code>. N√£o √© poss√≠vel ler dessa vari√°vel, e podemos atribuir a ela sem nos importar.</p><p>Al√©m disso, podemos ter casamentos com partes similares, desde que a mais espec√≠fica fique acima da mais geral. Por exemplo, podemos querer tratar separadamente o caso em que haja exatamente um elemento retornado.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> MockDB <span class="token keyword">do</span>
  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token keyword">case</span> result <span class="token keyword">do</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;There is only one element&quot;</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> element_count<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;There are <span class="token interpolation"><span class="token delimiter punctuation">#{</span>element_count<span class="token delimiter punctuation">}</span></span> elements&quot;</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> error_message<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;An error occurred: <span class="token interpolation"><span class="token delimiter punctuation">#{</span>error_message<span class="token delimiter punctuation">}</span></span>&quot;</span>
      _ <span class="token operator">-&gt;</span> <span class="token string">&quot;????&quot;</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;There is only one element&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:palha_italiana</span><span class="token punctuation">,</span> <span class="token string">&quot;Really tasty&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;????&quot;</span></code></pre><p>O <code>case</code> n√£o √© a √∫nica maneira de despachar de acordo com casamento de padr√µes! Como comentei, Elixir define casamento de padr√µes como parte idiom√°tica da linguagem, e seu uso vai al√©m disso. Podemos usar casamento de padr√µes para <strong>mudar a execu√ß√£o de uma fun√ß√£o</strong>. Vamos re-escrever o exemplo acima mais uma vez, com essa ideia:</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> MockDB <span class="token keyword">do</span>
  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token string">&quot;There is only one element&quot;</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> element_count<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token string">&quot;There are <span class="token interpolation"><span class="token delimiter punctuation">#{</span>element_count<span class="token delimiter punctuation">}</span></span> elements&quot;</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> error_message<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token string">&quot;An error occurred: <span class="token interpolation"><span class="token delimiter punctuation">#{</span>error_message<span class="token delimiter punctuation">}</span></span>&quot;</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token string">&quot;????&quot;</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;There is only one element&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;There are 42 elements&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> <span class="token string">&quot;DB is offline&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;An error occurred: DB is offline&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:palha_italiana</span><span class="token punctuation">,</span> <span class="token string">&quot;Really tasty&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;????&quot;</span></code></pre><p><strong>Podemos usar casamento de padr√µes nos argumentos de uma fun√ß√£o.</strong> Declaramos mais de uma vez uma mesma fun√ß√£o, por√©m em cada declara√ß√£o, definimos um padr√£o diferente para o primeiro argumento. Cada vez que essa fun√ß√£o for chamada, Elixir vai, em ordem, tentar casar os argumentos com os padr√µes e, quando encontrar um casamento que d√™ match, o corpo dessa declara√ß√£o √© executado.</p><p>Nossas fun√ß√µes neste caso apenas retornam strings, mas nada impede que cada uma fa√ßa algo totalmente diferente. Isso nos permite, rapidamente, saber que formatos de dados essa fun√ß√£o est√° pronta para lidar. Como definimos um padr√£o que sempre vai casar com qualquer coisa (o <code>_</code>), essa fun√ß√£o nunca vai retornar um erro de casamento de padr√µes.</p><p>Vamos ver outro exemplo, dessa vez fazendo casamento um valor mais simples. Ao inv√©s de casar uma tupla, vamos casar um n√∫mero. Podemos fazer isso para implementar um <a href="https://pt.wikipedia.org/wiki/Fatorial">c√°lculo de fatorial</a>. O fatorial de um n√∫mero <code>n</code> √© o produto de todos os n√∫meros inteiros de 1 at√© <code>n</code>. Fora isso, por defini√ß√£o, o fatorial de zero √© 1. </p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token comment"># Defini√ß√£o de como funciona o fatorial</span>
factorial<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>
factorial<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>Podemos implementar esse fatorial, de maneira recursiva, usando casamento de padr√µes.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> Math <span class="token keyword">do</span>
  <span class="token keyword">def</span> factorial<span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token keyword">do</span>
    factorial<span class="token punctuation">(</span>number<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> factorial<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> current_product<span class="token punctuation">)</span> <span class="token keyword">do</span>
    current_product
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> factorial<span class="token punctuation">(</span>number<span class="token punctuation">,</span> current_product<span class="token punctuation">)</span> <span class="token keyword">do</span>
    factorial<span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> number <span class="token operator">*</span> current_product<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

Math<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment"># Retorna 1</span>
Math<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># Retorna 1</span>
Math<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment"># Retorna 2432902008176640000</span></code></pre><p>Temos duas fun√ß√µes: uma que recebe um argumento (tamb√©m chamada de <code>Math.factorial/1</code>) e outra que recebe dois argumentos (chamada <code>Math.factorial/2</code>). A primeira serve apenas de conveni√™ncia, e √© p√∫blica. Ela chama a segunda inicializando o produto com <code>1</code>. Na fun√ß√£o com dois argumentos √© que temos um casamento de padr√µes. Vamos tentar, primeiramente, casar o primeiro argumento com o padr√£o <code>0</code>. A √∫nica maneira desse casamento bater √© se o argumento for, de fato, <code>0</code>.</p><p>Se o padr√£o casa, n√≥s retornamos o produto acumulado at√© agora (segundo argumento da fun√ß√£o). Se ele n√£o casa, n√≥s tentamos a segunda defini√ß√£o da fun√ß√£o. Na segunda defini√ß√£o, o casamento vai com certeza acontecer pois temos apenas identificadores em todos os argumentos. O que essa defini√ß√£o faz √© chamar, recursivamente, a fun√ß√£o subtraindo 1 do primeiro argumento e multiplicando o produto acumulado pelo primeiro argumento. </p><p>Lembre-se que a <strong>ordem √© importante no casamento de padr√µes</strong>. Se invert√™ssemos e coloc√°ssemos o caso em que o primeiro argumento √© <code>0</code> embaixo, ele nunca seria executado pois o valor <code>0</code> iria casar com o outro caso primeiro, o que √© apenas uma vari√°vel <code>number</code>.</p><p>Um benef√≠cio adicional dessa implementa√ß√£o √© que ela √© uma <a href="https://pt.wikipedia.org/wiki/Recursividade_(ci√™ncia_da_computa√ß√£o)#Fun√ß√µes_recursivas_em_cauda">recurs√£o de cauda</a> (<em>tail recursion</em>), ou seja, cada itera√ß√£o da recurs√£o n√£o precisa de espa√ßo adicional na pilha de chamadas de fun√ß√£o. Isso √© √∫til pois, do contr√°rio, ao tentar calcular um fatorial muito grande podemos ter um erro de estouro de pilha. Note tamb√©m que, caso voc√™ passe um valor negativo para a fun√ß√£o, ela vai executar infinitamente. Uma maneira de evitar isso √© usando <a href="https://hexdocs.pm/elixir/guards.html">guards</a>.</p><h2>Pra onde vou agora?</h2><p>Trouxe aqui um pouco de como funciona casamento de padr√µes em Elixir e alguns exemplos de como utilizar para escrever condi√ß√µes mais claras. Com isso, conseguimos por exemplo separar fluxos de execu√ß√£o de acordo com o formato de uma estrutura de dados.</p><p>A documenta√ß√£o oficial de Elixir √© bem detalhada e traz ainda mais conte√∫do sobre o assunto. Eu comecei a usar a linguagem para aprender, e os tutoriais da documenta√ß√£o ajudaram bastante. Se voc√™ quer come√ßar, sugiro partir do <a href="https://elixir-lang.org/getting-started/introduction.html">guia de introdu√ß√£o</a> e seguir o passo a passo. Sobre esses assuntos que vimos, essas p√°ginas s√£o bem √∫teis:</p><ul><li><a href="https://elixir-lang.org/getting-started/pattern-matching.html">Pattern matching</a></li><li><a href="https://elixir-lang.org/getting-started/case-cond-and-if.html">case, cond, and if</a></li><li><a href="https://elixir-lang.org/getting-started/modules-and-functions.html">Modules and functions</a></li><li><a href="https://elixir-lang.org/getting-started/recursion.html">Recursion</a></li></ul><p>E se esse post te trouxe ideias, ou se tem sugest√µes de como melhorar algum dos exemplos, <a href="https://twitter.com/Cisneiros">me d√° um oi no Twitter</a>! üëã</p></div><hr/><div class="Poststyles__AfterPost-sc-12qb97v-0 tuaWG"><p class="Poststyles__AfterPostChild-sc-12qb97v-1 gkeqUt">Gostou? <a href="https://twitter.com/intent/tweet?text=%22Casamento%20de%20padr%C3%B5es%20em%20Elixir%22%20por%20%40Cisneiros%0A%0Ahttps%3A%2F%2Fblog.cisne.dev%2Fcasamento-de-padroes-em-elixir" target="_blank" rel="noopener noreferrer">Que tal compartilhar?</a></p><p class="Poststyles__AfterPostChild-sc-12qb97v-1 Poststyles__Tags-sc-12qb97v-2 fAvgXR">Tags: <span class="Poststyles__Tag-sc-12qb97v-3 kSZCZX"><a href="/tag/elixir">elixir</a></span></p></div></article></div></div></main><footer class="Footer__Container-b3q04c-0 gdHjSq"><div class="ui__Fit-prwz6b-0 Footer__FooterFit-b3q04c-1 layJcq"><p>¬© <a href="https://cisne.dev">Alexandre Cisneiros</a></p><p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a></p></div></footer></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/src/containers/post\",\"sharedHashesByProp\":{},\"data\":{\"postData\":{\"title\":\"Casamento de padr\u00F5es em Elixir\",\"date\":\"2020-10-16T00:00:00-03:00\",\"slug\":\"casamento-de-padroes-em-elixir\",\"tags\":[\"elixir\"],\"filePath\":\"2020-10-16-casamento-de-padroes-em-elixir.md\",\"content\":\"Um desafio de programa\u00E7\u00E3o \u00E9 conseguir escrever c\u00F3digo de maneira mais sucinta sem sacrificar a facilidade de compreens\u00E3o. \u00C9 comum ver solu\u00E7\u00F5es de uma linha que resolvem o problema e ningu\u00E9m entende como elas funcionam. Pensando nisso, algumas linguagens trazem sintaxe que permite escrever, de maneira idiom\u00E1tica, c\u00F3digo mais expressivo. Um exemplo disso \u00E9 **casamento de padr\u00F5es**. Recentemente, comecei a estudar Elixir, e fiquei feliz em descobrir que _pattern matching_ \u00E9 uma parte importante da linguagem e resolvi trazer um pouco disso pra c\u00E1!\\n\\n\u003C!-- summary-break -->\\n\\nCasamento de padr\u00F5es \u00E9 uma maneira de verificar se uma estrutura de dados tem um determinado formato. Nessa verifica\u00E7\u00E3o, \u00E9 poss\u00EDvel extrair informa\u00E7\u00E3o dessa estrutura. Um exemplo da intui\u00E7\u00E3o de casamento de padr\u00F5es \u00E9 o _destructuring_, bastante comum em JavaScript moderno:\\n\\n```js\\nconst person = { name: 'Jane Doe', age: 31 }\\nconst { name } = person\\nconsole.log(name) // Imprime 'Jane Doe'\\n```\\n\\nNeste exemplo, na segunda linha, n\u00F3s afirmamos que a estrutura de dados `person` tem o formato de um objeto com uma chave `name`. Como esse nome de vari\u00E1vel est\u00E1 livre, atribuimos a ele o valor do atributo `name` do objeto. Destructuring por\u00E9m apenas permite casar um objeto com uma lista de atributos, ou um array com uma lista de posi\u00E7\u00F5es. Ele n\u00E3o nos permite fazer afirma\u00E7\u00F5es mais espec\u00EDficas sobre o formato da estrutura de dados ou despachar de maneira condicional a este formato.\\n\\n## Casando padr\u00F5es em Elixir\\n\\nElixir \u00E9 uma linguagem em que casamento de padr\u00F5es faz parte de suas pr\u00E1ticas idiom\u00E1ticas. Nela, casamento de padr\u00F5es nos permite fazer destructuring como no exemplo em JavaScript, por\u00E9m tamb\u00E9m nos permite ir bem al\u00E9m. Vamos come\u00E7ar com a sintaxe de casamento de padr\u00F5es e depois ver algumas aplica\u00E7\u00F5es.\\n\\nEm Elixir, o operador `=` \u00E9 chamado de operador de **match** (casamento), e n\u00E3o de atribui\u00E7\u00E3o como em outras linguagens. Ele executa um casamento de padr\u00F5es entre o lado esquerdo e direito do operador.\\n\\n```elixir\\nx = {:alice, :bob}\\n# Note que, em Elixir, `{}` delimitam uma tupla e n\u00E3o um objeto ou mapa, como em JavaScript. \\n```\\n\\nNo exemplo acima, estamos fazendo um match de `x` com a tupla `{:alice, :bob}`. `x` \u00E9 um identificador e a tupla \u00E9 uma estrutura de dados. \u00C9 poss\u00EDvel que `x` tenha o mesmo formato que a tupla? Sim, se `x` tiver como valor `{:alice, :bob}`. E \u00E9 isso que vai acontecer a partir dessa linha. Quando colocamos apenas um identificador do lado esquerdo do match, o operador funciona exatamente como uma atribui\u00E7\u00E3o.\\n\\n```elixir\\n{:alice, other_name} = {:alice, :bob}\\nIO.puts(other_name) # Imprime :bob\\n```\\n\\nNeste exemplo, fazemos um destructuring usando casamento de padr\u00F5es. N\u00F3s definimos, do lado direito, que temos uma tupla cujo formato \u00E9 ter `:alice` no primeiro elemento e um identificador `other_name` no segundo elemento. Em seguida, casamos isso com a tupla `{:alice, :bob}`. A \u00FAnica maneira de esse casamento dar certo \u00E9 se `other_name` tiver o valor `:bob`, e \u00E9 isso que vai acontecer nessa linha.\\n\\nNote que s\u00F3 podemos usar identificadores para atribuir vari\u00E1veis em casamento de padr\u00F5es do lado esquerdo do operador de match. Do contr\u00E1rio recebemos um erro de compila\u00E7\u00E3o.\\n\\n```elixir\\n{:alice, :bob} = {:alice, other_name}\\n# ** (CompileError) iex:1: undefined function other_name/0\\n```\\n\\nSimilarmente, recebemos um erro se os padr\u00F5es n\u00E3o casarem:\\n\\n```elixir\\n{:alice, other_name} = {:charlie, :bob}\\n# ** (MatchError) no match of right hand side value: {:charlie, :bob}\\n```\\n\\nPodemos casar outras estruturas de dados, tamb\u00E9m. Mapas, delimitados com `%{}`, podem casar com um subconjunto das suas chaves e listas podem casar com outra lista de mesmo tamanho ou com uma representa\u00E7\u00E3o no formato `[cabe\u00E7a_da_lista | resto_da_lista]`:\\n\\n```elixir\\n%{first_name: name} = %{first_name: \\\"Jane\\\", last_name: \\\"Doe\\\"}\\nIO.puts(name) # Imprime \\\"Jane\\\"\\n\\n[first_item | other_items] = [1, 2, 3, 4, 5]\\nIO.puts(first_item) # Imprime 1\\nIO.puts(other_items) # Imprime [2, 3, 4, 5]\\n```\\n\\nComo comentei no come\u00E7o, identificadores no lado esquerdo do operador s\u00E3o tratados como uma atribui\u00E7\u00E3o de vari\u00E1vel, usando o valor que casa do lado direito. \u00C9 poss\u00EDvel evitar essa atribui\u00E7\u00E3o e usar uma vari\u00E1vel do lado esquerdo do operador de **pin** (fixa\u00E7\u00E3o), `^`. Com ele, podemos fixar o valor da vari\u00E1vel do lado esquerdo e us\u00E1-lo como parte do padr\u00E3o a casar, e n\u00E3o como um destino para uma atribui\u00E7\u00E3o.\\n\\n```elixir\\nresult = :ok\\n{^result, message} = {:ok, \\\"Your request was processed\\\"}\\nIO.puts(message) # Imprime \\\"Your request was processed\\\" e n\u00E3o muda o valor de result\\n\\n{^result, message} = {:error, \\\"Your request was not processed\\\"}\\n# ** (MatchError) no match of right hand side value: {:error, \\\"Your request was not processed\\\"}\\n```\\n\\n## Despachando com casamento de padr\u00F5es\\n\\nAt\u00E9 agora vimos como casar padr\u00F5es em Elixir. Por\u00E9m, com o que vimos n\u00F3s conseguimos apenas fazer atribui\u00E7\u00F5es de vari\u00E1veis e destrucutring, al\u00E9m de gerar um erro quando o padr\u00E3o n\u00E3o casa. Tirando o erro, n\u00E3o temos nada muito novo. Por\u00E9m, podemos aplicar casamento de padr\u00F5es a **condicionais e fun\u00E7\u00F5es** para tomar caminhos diferentes no programa de acordo com o casamento ou n\u00E3o de padr\u00F5es.\\n\\n```elixir\\n# Imagine uma consulta ao banco de dados que retorna quantos elementos existem.\\n# O retorno \u00E9 uma tupla com um c\u00F3digo de status e um valor.\\nresult = {:ok, 50}\\n\\nmessage = case result do\\n  {:ok, element_count} -> \\\"There are #{element_count} elements\\\"\\n  {:error, error_message} -> \\\"An error occurred: #{error_message}\\\"\\nend\\n\\nIO.puts(message) # Imprime \\\"There are 50 elements\\\"\\n```\\n\\nPodemos usar a estrutura de controle `case` para casar padr\u00F5es. Ela recebe uma entrada, `result` no nosso exemplo, e uma lista de poss\u00EDveis padr\u00F5es para tentar casar. Caso haja algum que d\u00EA match, o valor para que ele aponta (`->`) \u00E9 retornado pelo `case`. Note que a lista de padr\u00F5es a casar \u00E9 equivalente ao **lado esquerdo** do operador de match. Ou seja, podemos colocar identificadores que se tornam vari\u00E1veis no corpo ap\u00F3s o `->` e podem ser usados no valor retornado.\\n\\n\u00C9 poss\u00EDvel que o valor de entrada case com mais de um padr\u00E3o, dependendo de como a lista seja especificada. Por isso, **a ordem importa**. Quando o primeiro padr\u00E3o casar, os seguintes ser\u00E3o ignorados.\\n\\nVamos re-escrever o exemplo acima numa fun\u00E7\u00E3o para testar os diferentes retornos poss\u00EDveis:\\n\\n```elixir\\ndefmodule MockDB do\\n  def display_result(result) do\\n    case result do\\n      {:ok, element_count} -> \\\"There are #{element_count} elements\\\"\\n      {:error, error_message} -> \\\"An error occurred: #{error_message}\\\"\\n    end\\n  end\\nend\\n\\nMockDB.display_result({:ok, 42})\\n# Imprime \\\"There are 42 elements\\\"\\n\\nMockDB.display_result({:error, \\\"DB is offline\\\"})\\n# Imprime \\\"An error occurred: DB is offline\\\"\\n\\nMockDB.display_result({:palha_italiana, \\\"Really tasty\\\"})\\n# ** (CaseClauseError) no case clause matching: {:palha_italiana, \\\"Really tasty\\\"}\\n#     iex:10: MockDB.display_result/1\\n```\\n\\nCaso n\u00E3o haja um padr\u00E3o que case, tomamos um erro. \u00C9 poss\u00EDvel tratar esse caso garantindo que, ao fim da lista, sempre haver\u00E1 um padr\u00E3o que case. Podemos colocar um identificador qualquer (`x -> \\\"????\\\"`), mas isso vai criar uma vari\u00E1vel local de que n\u00E3o precisamos. Ao inv\u00E9s de usar `x`, podemos usar o identificador especial `_`. N\u00E3o \u00E9 poss\u00EDvel ler dessa vari\u00E1vel, e podemos atribuir a ela sem nos importar.\\n\\nAl\u00E9m disso, podemos ter casamentos com partes similares, desde que a mais espec\u00EDfica fique acima da mais geral. Por exemplo, podemos querer tratar separadamente o caso em que haja exatamente um elemento retornado.\\n\\n```elixir\\ndefmodule MockDB do\\n  def display_result(result) do\\n    case result do\\n      {:ok, 1} -> \\\"There is only one element\\\"\\n      {:ok, element_count} -> \\\"There are #{element_count} elements\\\"\\n      {:error, error_message} -> \\\"An error occurred: #{error_message}\\\"\\n      _ -> \\\"????\\\"\\n    end\\n  end\\nend\\n\\nMockDB.display_result({:ok, 1})\\n# Imprime \\\"There is only one element\\\"\\n\\nMockDB.display_result({:palha_italiana, \\\"Really tasty\\\"})\\n# Imprime \\\"????\\\"\\n```\\n\\nO `case` n\u00E3o \u00E9 a \u00FAnica maneira de despachar de acordo com casamento de padr\u00F5es! Como comentei, Elixir define casamento de padr\u00F5es como parte idiom\u00E1tica da linguagem, e seu uso vai al\u00E9m disso. Podemos usar casamento de padr\u00F5es para **mudar a execu\u00E7\u00E3o de uma fun\u00E7\u00E3o**. Vamos re-escrever o exemplo acima mais uma vez, com essa ideia:\\n\\n```elixir\\ndefmodule MockDB do\\n  def display_result({:ok, 1}) do\\n    \\\"There is only one element\\\"\\n  end\\n\\n  def display_result({:ok, element_count}) do\\n    \\\"There are #{element_count} elements\\\"\\n  end\\n\\n  def display_result({:error, error_message}) do\\n    \\\"An error occurred: #{error_message}\\\"\\n  end\\n\\n  def display_result(_) do\\n    \\\"????\\\"\\n  end\\nend\\n\\nMockDB.display_result({:ok, 1})\\n# Imprime \\\"There is only one element\\\"\\n\\nMockDB.display_result({:ok, 42})\\n# Imprime \\\"There are 42 elements\\\"\\n\\nMockDB.display_result({:error, \\\"DB is offline\\\"})\\n# Imprime \\\"An error occurred: DB is offline\\\"\\n\\nMockDB.display_result({:palha_italiana, \\\"Really tasty\\\"})\\n# Imprime \\\"????\\\"\\n```\\n\\n**Podemos usar casamento de padr\u00F5es nos argumentos de uma fun\u00E7\u00E3o.** Declaramos mais de uma vez uma mesma fun\u00E7\u00E3o, por\u00E9m em cada declara\u00E7\u00E3o, definimos um padr\u00E3o diferente para o primeiro argumento. Cada vez que essa fun\u00E7\u00E3o for chamada, Elixir vai, em ordem, tentar casar os argumentos com os padr\u00F5es e, quando encontrar um casamento que d\u00EA match, o corpo dessa declara\u00E7\u00E3o \u00E9 executado.\\n\\nNossas fun\u00E7\u00F5es neste caso apenas retornam strings, mas nada impede que cada uma fa\u00E7a algo totalmente diferente. Isso nos permite, rapidamente, saber que formatos de dados essa fun\u00E7\u00E3o est\u00E1 pronta para lidar. Como definimos um padr\u00E3o que sempre vai casar com qualquer coisa (o `_`), essa fun\u00E7\u00E3o nunca vai retornar um erro de casamento de padr\u00F5es.\\n\\nVamos ver outro exemplo, dessa vez fazendo casamento um valor mais simples. Ao inv\u00E9s de casar uma tupla, vamos casar um n\u00FAmero. Podemos fazer isso para implementar um [c\u00E1lculo de fatorial](https://pt.wikipedia.org/wiki/Fatorial). O fatorial de um n\u00FAmero `n` \u00E9 o produto de todos os n\u00FAmeros inteiros de 1 at\u00E9 `n`. Fora isso, por defini\u00E7\u00E3o, o fatorial de zero \u00E9 1. \\n\\n```elixir\\n# Defini\u00E7\u00E3o de como funciona o fatorial\\nfactorial(0) == 1\\nfactorial(n) == n * factorial(n - 1)\\n```\\n\\nPodemos implementar esse fatorial, de maneira recursiva, usando casamento de padr\u00F5es.\\n\\n```elixir\\ndefmodule Math do\\n  def factorial(number) do\\n    factorial(number, 1)\\n  end\\n\\n  defp factorial(0, current_product) do\\n    current_product\\n  end\\n\\n  defp factorial(number, current_product) do\\n    factorial(number - 1, number * current_product)\\n  end\\nend\\n\\nMath.factorial(0) # Retorna 1\\nMath.factorial(1) # Retorna 1\\nMath.factorial(20) # Retorna 2432902008176640000\\n```\\n\\nTemos duas fun\u00E7\u00F5es: uma que recebe um argumento (tamb\u00E9m chamada de `Math.factorial/1`) e outra que recebe dois argumentos (chamada `Math.factorial/2`). A primeira serve apenas de conveni\u00EAncia, e \u00E9 p\u00FAblica. Ela chama a segunda inicializando o produto com `1`. Na fun\u00E7\u00E3o com dois argumentos \u00E9 que temos um casamento de padr\u00F5es. Vamos tentar, primeiramente, casar o primeiro argumento com o padr\u00E3o `0`. A \u00FAnica maneira desse casamento bater \u00E9 se o argumento for, de fato, `0`.\\n\\nSe o padr\u00E3o casa, n\u00F3s retornamos o produto acumulado at\u00E9 agora (segundo argumento da fun\u00E7\u00E3o). Se ele n\u00E3o casa, n\u00F3s tentamos a segunda defini\u00E7\u00E3o da fun\u00E7\u00E3o. Na segunda defini\u00E7\u00E3o, o casamento vai com certeza acontecer pois temos apenas identificadores em todos os argumentos. O que essa defini\u00E7\u00E3o faz \u00E9 chamar, recursivamente, a fun\u00E7\u00E3o subtraindo 1 do primeiro argumento e multiplicando o produto acumulado pelo primeiro argumento. \\n\\nLembre-se que a **ordem \u00E9 importante no casamento de padr\u00F5es**. Se invert\u00EAssemos e coloc\u00E1ssemos o caso em que o primeiro argumento \u00E9 `0` embaixo, ele nunca seria executado pois o valor `0` iria casar com o outro caso primeiro, o que \u00E9 apenas uma vari\u00E1vel `number`.\\n\\nUm benef\u00EDcio adicional dessa implementa\u00E7\u00E3o \u00E9 que ela \u00E9 uma [recurs\u00E3o de cauda](https://pt.wikipedia.org/wiki/Recursividade_(ci\u00EAncia_da_computa\u00E7\u00E3o)#Fun\u00E7\u00F5es_recursivas_em_cauda) (_tail recursion_), ou seja, cada itera\u00E7\u00E3o da recurs\u00E3o n\u00E3o precisa de espa\u00E7o adicional na pilha de chamadas de fun\u00E7\u00E3o. Isso \u00E9 \u00FAtil pois, do contr\u00E1rio, ao tentar calcular um fatorial muito grande podemos ter um erro de estouro de pilha. Note tamb\u00E9m que, caso voc\u00EA passe um valor negativo para a fun\u00E7\u00E3o, ela vai executar infinitamente. Uma maneira de evitar isso \u00E9 usando [guards](https://hexdocs.pm/elixir/guards.html).\\n\\n## Pra onde vou agora?\\n\\nTrouxe aqui um pouco de como funciona casamento de padr\u00F5es em Elixir e alguns exemplos de como utilizar para escrever condi\u00E7\u00F5es mais claras. Com isso, conseguimos por exemplo separar fluxos de execu\u00E7\u00E3o de acordo com o formato de uma estrutura de dados.\\n\\nA documenta\u00E7\u00E3o oficial de Elixir \u00E9 bem detalhada e traz ainda mais conte\u00FAdo sobre o assunto. Eu comecei a usar a linguagem para aprender, e os tutoriais da documenta\u00E7\u00E3o ajudaram bastante. Se voc\u00EA quer come\u00E7ar, sugiro partir do [guia de introdu\u00E7\u00E3o](https://elixir-lang.org/getting-started/introduction.html) e seguir o passo a passo. Sobre esses assuntos que vimos, essas p\u00E1ginas s\u00E3o bem \u00FAteis:\\n\\n- [Pattern matching](https://elixir-lang.org/getting-started/pattern-matching.html)\\n- [case, cond, and if](https://elixir-lang.org/getting-started/case-cond-and-if.html)\\n- [Modules and functions](https://elixir-lang.org/getting-started/modules-and-functions.html)\\n- [Recursion](https://elixir-lang.org/getting-started/recursion.html)\\n\\nE se esse post te trouxe ideias, ou se tem sugest\u00F5es de como melhorar algum dos exemplos, [me d\u00E1 um oi no Twitter](https://twitter.com/Cisneiros)! \uD83D\uDC4B\\n\",\"readingTime\":11,\"summary\":\"Um desafio de programa\u00E7\u00E3o \u00E9 conseguir escrever c\u00F3digo de maneira mais sucinta sem sacrificar a facilidade de compreens\u00E3o. \u00C9 comum ver solu\u00E7\u00F5es de uma linha que resolvem o problema e ningu\u00E9m entende como elas funcionam. Pensando nisso, algumas linguagens trazem sintaxe que permite escrever, de maneira idiom\u00E1tica, c\u00F3digo mais expressivo. Um exemplo disso \u00E9 **casamento de padr\u00F5es**. Recentemente, comecei a estudar Elixir, e fiquei feliz em descobrir que _pattern matching_ \u00E9 uma parte importante da linguagem e resolvi trazer um pouco disso pra c\u00E1!\\n\\n\"}},\"path\":\"casamento-de-padroes-em-elixir\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/vendors~__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.207edc50.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.a04ea84b.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/post.d8dd52db.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.272ae1d1.js"></script><script defer="" type="text/javascript" src="/main.f19d4c14.js"></script></body></html>