<!DOCTYPE html><html lang="pt-BR" class=" "><head><meta name="generator" content="React Static"/><title data-react-helmet="true">Casamento de padrões em Elixir · Cisne.dev blog</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:creator" content="Cisneiros"/><meta data-react-helmet="true" property="og:title" content="Casamento de padrões em Elixir · Cisne.dev blog"/><meta data-react-helmet="true" property="og:image" content="https://blog.cisne.dev/casamento-de-padroes-em-elixir/social-image.png"/><meta data-react-helmet="true" name="twitter:title" content="Casamento de padrões em Elixir · Cisne.dev blog"/><meta data-react-helmet="true" name="twitter:image" content="https://blog.cisne.dev/casamento-de-padroes-em-elixir/social-image.png"/><link rel="preload" as="script" href="/templates/vendors~__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.207edc50.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.a04ea84b.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/post.d8dd52db.js"/><link rel="preload" as="script" href="/templates/vendors~main.272ae1d1.js"/><link rel="preload" as="script" href="/main.f19d4c14.js"/><link data-react-helmet="true" rel="stylesheet" href="//unpkg.com/dracula-prism/dist/css/dracula-prism.min.css"/><style data-styled="" data-styled-version="5.1.1">.CfxHf{max-width:960px;margin:0 auto;position:relative;}/*!sc*/
data-styled.g1[id="ui__Fit-prwz6b-0"]{content:"CfxHf,"}/*!sc*/
.iuDFSN{padding:1rem;color:var(--color-mid);text-align:center;font-size:1.5rem;}/*!sc*/
.iuDFSN a,.iuDFSN a:hover{-webkit-text-decoration:none;text-decoration:none;color:inherit;}/*!sc*/
data-styled.g2[id="Navigation__Container-sc-1yk0pqp-0"]{content:"iuDFSN,"}/*!sc*/
.izuwCZ{max-width:960px;margin:0 auto;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
data-styled.g3[id="Navigation__NavFit-sc-1yk0pqp-1"]{content:"izuwCZ,"}/*!sc*/
.TctaC{width:2.5rem;height:1.2em;overflow:hidden;--default-rotation:-180deg;}/*!sc*/
@media (prefers-color-scheme:dark){.TctaC{--default-rotation:0;}}/*!sc*/
data-styled.g4[id="Navigation__BrightnessContainer-sc-1yk0pqp-2"]{content:"TctaC,"}/*!sc*/
.sLeDt{-webkit-transform:rotate(var(--default-rotation));-ms-transform:rotate(var(--default-rotation));transform:rotate(var(--default-rotation));-webkit-transition:-webkit-transform 0.3s ease-out;-webkit-transition:transform 0.3s ease-out;transition:transform 0.3s ease-out;}/*!sc*/
html.light .sLeDt{-webkit-transform:rotate(-180deg);-ms-transform:rotate(-180deg);transform:rotate(-180deg);}/*!sc*/
html.dark .sLeDt{-webkit-transform:rotate(0);-ms-transform:rotate(0);transform:rotate(0);}/*!sc*/
data-styled.g5[id="Navigation__BrightnessSpinner-sc-1yk0pqp-3"]{content:"sLeDt,"}/*!sc*/
.frsARl{background:none;border:none;cursor:pointer;}/*!sc*/
.frsARl:last-child{-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg);}/*!sc*/
data-styled.g7[id="Navigation__BrightnessIcon-sc-1yk0pqp-5"]{content:"frsARl,"}/*!sc*/
.gdHjSq{margin-top:3rem;padding:1rem;background:var(--color-foreground);color:var(--color-background);}/*!sc*/
.gdHjSq a{color:var(--text-inverse-color-1);}/*!sc*/
.gdHjSq a:hover{color:var(--text-inverse-color-3);}/*!sc*/
data-styled.g8[id="Footer__Container-b3q04c-0"]{content:"gdHjSq,"}/*!sc*/
.layJcq{max-width:960px;margin:0 auto;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
data-styled.g9[id="Footer__FooterFit-b3q04c-1"]{content:"layJcq,"}/*!sc*/
*{box-sizing:border-box;margin:0;padding:0;border:0;font-size:inherit;font-weight:inherit;font-style:inherit;}/*!sc*/
:root{--color-1:#12c2e9;--color-2:#c471ed;--color-3:#f64f59;--color-1-darker:#0A7B94;--color-2-darker:#AE3CE7;--color-3-darker:#E90C1B;--color-light:#fefefe;--color-dark:#030303;--color-mid-dark:#747481;--color-mid-light:#818181;--font-weight-light:300;--font-weight-regular:400;--font-weight-heavy:500;--font-family-light:"HelveticaNeue-Light","Helvetica Neue Light",'Helvetica Neue',sans-serif;--font-family:'Helvetica Neue',sans-serif;}/*!sc*/
strong,h1,h2,h3,h4,h5,h6{font-family:var(--font-family);}/*!sc*/
html{font-family:var(--font-family-light);font-size:20px;line-height:1;color:var(--color-foreground);background-color:var(--color-background);text-rendering:optimizeLegibility;}/*!sc*/
@media (max-width:600px){html{font-size:16px;}}/*!sc*/
html,html.light{--color-background:var(--color-light);--color-foreground:var(--color-dark);--color-mid:var(--color-mid-dark);--text-color-1:var(--color-1-darker);--text-color-2:var(--color-2-darker);--text-color-3:var(--color-3-darker);--text-inverse-color-1:var(--color-1);--text-inverse-color-2:var(--color-2);--text-inverse-color-3:var(--color-3);}/*!sc*/
html.dark{--color-background:var(--color-dark);--color-foreground:var(--color-light);--color-mid:var(--color-mid-light);--text-color-1:var(--color-1);--text-color-2:var(--color-2);--text-color-3:var(--color-3);--text-inverse-color-1:var(--color-1-darker);--text-inverse-color-2:var(--color-2-darker);--text-inverse-color-3:var(--color-3-darker);}/*!sc*/
@media (prefers-color-scheme:dark){html{--color-background:var(--color-dark);--color-foreground:var(--color-light);--color-mid:var(--color-mid-light);}}/*!sc*/
body{font-size:1em;font-weight:var(--font-weight-light);}/*!sc*/
strong{font-weight:var(--font-weight-heavy);}/*!sc*/
em{font-style:italic;}/*!sc*/
main{padding:1rem;}/*!sc*/
hr{width:30%;margin:4rem auto;border:none;border-bottom:dotted 1px var(--color-1);}/*!sc*/
.pagination{text-align:center;}/*!sc*/
.pagination a{color:var(--text-color-1);}/*!sc*/
.pagination a:hover{color:var(--text-color-3);}/*!sc*/
a{color:var(--text-color-1);-webkit-text-decoration-color:#c471ed80;text-decoration-color:#c471ed80;-webkit-text-decoration-style:wavy;text-decoration-style:wavy;}/*!sc*/
a:hover{color:var(--text-color-3);-webkit-text-decoration-color:#12c2e980;text-decoration-color:#12c2e980;}/*!sc*/
.phone-mockup{max-width:15rem;margin:0 auto 1rem;position:relative;}/*!sc*/
.phone-mockup::before{content:'';width:100%;height:100%;position:absolute;pointer-events:none;background:url(/iphone-11-pro.png) no-repeat;background-size:contain;}/*!sc*/
.phone-mockup video,.phone-mockup img{width:100%;padding:9.3%;}/*!sc*/
data-styled.g14[id="sc-global-hFBrmQ1"]{content:"sc-global-hFBrmQ1,"}/*!sc*/
.tuaWG{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
@media (max-width:600px){.tuaWG{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}/*!sc*/
data-styled.g23[id="Poststyles__AfterPost-sc-12qb97v-0"]{content:"tuaWG,"}/*!sc*/
.gkeqUt{-webkit-flex:1;-ms-flex:1;flex:1;}/*!sc*/
@media (max-width:600px){.gkeqUt{text-align:center;margin-bottom:1rem;}}/*!sc*/
data-styled.g24[id="Poststyles__AfterPostChild-sc-12qb97v-1"]{content:"gkeqUt,"}/*!sc*/
.fAvgXR{-webkit-flex:1;-ms-flex:1;flex:1;text-align:right;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
@media (max-width:600px){.fAvgXR{text-align:center;margin-bottom:1rem;}}/*!sc*/
data-styled.g25[id="Poststyles__Tags-sc-12qb97v-2"]{content:"fAvgXR,"}/*!sc*/
.kSZCZX::before{content:' #';color:var(--color-mid);}/*!sc*/
data-styled.g26[id="Poststyles__Tag-sc-12qb97v-3"]{content:"kSZCZX,"}/*!sc*/
.kyWzPB{-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;hyphens:auto;}/*!sc*/
data-styled.g27[id="Poststyles__Container-sc-12qb97v-4"]{content:"kyWzPB,"}/*!sc*/
.hhBwVH{font-size:5rem;font-weight:var(--font-weight-regular);line-height:0.8;background:linear-gradient(var(--color-1),var(--color-2),var(--color-3));-webkit-text-fill-color:transparent;background-clip:text;-webkit-background-clip:text;padding-bottom:1rem;margin:1rem 0;}/*!sc*/
html.rainbow .hhBwVH{background-image:linear-gradient(124deg,#ff2400,#e81d1d,#e8b71d,#e3e81d,#1de840,#1ddde8,#2b1de8,#dd00f3,#dd00f3);-webkit-animation:hTUzwZ 9s ease infinite;animation:hTUzwZ 9s ease infinite;background-size:450% 450%;}/*!sc*/
@media (max-width:600px){.hhBwVH{font-size:3.5rem;}}/*!sc*/
.hhBwVH a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g28[id="Poststyles__Title-sc-12qb97v-5"]{content:"hhBwVH,"}/*!sc*/
.fonWHZ{color:var(--color-mid);text-align:center;margin-bottom:2rem;}/*!sc*/
data-styled.g29[id="Poststyles__Meta-sc-12qb97v-6"]{content:"fonWHZ,"}/*!sc*/
.jhgzPU{line-height:1.6;}/*!sc*/
.jhgzPU h2{font-size:2.5rem;}/*!sc*/
.jhgzPU h3{font-size:2rem;}/*!sc*/
.jhgzPU h4{font-size:1.5rem;}/*!sc*/
.jhgzPU h2,.jhgzPU h3,.jhgzPU h4,.jhgzPU h5,.jhgzPU h6{-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;hyphens:auto;font-weight:var(--font-weight-regular);line-height:0.8;padding-bottom:1rem;margin-top:2rem;}/*!sc*/
.jhgzPU img{max-width:100%;}/*!sc*/
.jhgzPU pre.refractor{margin-top:0;margin-left:0;padding-left:1rem;border-left:solid 0.25rem var(--color-1);border-radius:0;font-size:0.8rem;overflow-wrap:normal;overflow-x:auto;background-color:var(--color-dark);color:var(--color-light);padding-top:0.5rem;padding-bottom:0.5rem;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
.jhgzPU pre.refractor::-webkit-scrollbar{width:0.25rem;height:0.25rem;}/*!sc*/
.jhgzPU pre.refractor code,.jhgzPU code{font-family:'Fira Code','Menlo',monospace;}/*!sc*/
.jhgzPU p code{color:var(--text-color-3);}/*!sc*/
.jhgzPU p code,.jhgzPU h1 code,.jhgzPU h2 code,.jhgzPU h3 code,.jhgzPU h4 code,.jhgzPU h5 code,.jhgzPU h6 code{font-size:0.9em;}/*!sc*/
.jhgzPU p,.jhgzPU pre,.jhgzPU ul,.jhgzPU ol,.jhgzPU table,.jhgzPU blockquote,.jhgzPU .live-code-container{margin-bottom:1rem;}/*!sc*/
.jhgzPU twitter-widget{margin-bottom:1rem !important;}/*!sc*/
.jhgzPU p:last-child,.jhgzPU pre:last-child,.jhgzPU ul:last-child,.jhgzPU ol:last-child,.jhgzPU table:last-child,.jhgzPU blockquote:last-child,.jhgzPU .live-code-container:last-child{margin-bottom:0;}/*!sc*/
.jhgzPU ul,.jhgzPU ol{list-style:none;margin-left:1rem;counter-reset:li;}/*!sc*/
.jhgzPU li{counter-increment:li;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}/*!sc*/
.jhgzPU ul li::before{content:'•';margin-right:0.5rem;color:var(--color-2);}/*!sc*/
.jhgzPU ol li::before{content:"."counter(li);margin-right:0.5rem;color:var(--color-2);font-weight:var(--font-weight-regular);width:1em;display:inline-block;margin-left:-0.5em;margin-right:0.5em;text-align:right;direction:rtl;}/*!sc*/
.jhgzPU table{margin-left:auto;margin-right:auto;border-spacing:0;font-size:0.9em;}/*!sc*/
.jhgzPU td,.jhgzPU th{border-bottom:solid 1px var(--color-2);padding:0.5rem;}/*!sc*/
.jhgzPU th{font-weight:var(--font-weight-heavy);}/*!sc*/
.jhgzPU tr:hover{background:var(--color-2);}/*!sc*/
.jhgzPU tr:last-of-type td{border-bottom:0;}/*!sc*/
.jhgzPU blockquote{padding-left:1rem;border-left:solid 0.25rem var(--color-3);color:var(--color-mid);}/*!sc*/
data-styled.g30[id="Poststyles__Content-sc-12qb97v-7"]{content:"jhgzPU,"}/*!sc*/
.jjKdZc{position:fixed;top:0;left:0;right:0;height:0.25rem;background-color:var(--color-1);-webkit-transition:opacity 0.25s ease-out;transition:opacity 0.25s ease-out;z-index:2;}/*!sc*/
data-styled.g31[id="post__ScrollTrackerContainer-gh0jqu-0"]{content:"jjKdZc,"}/*!sc*/
@-webkit-keyframes hTUzwZ{0%{background-position:0% 82%;}50%{background-position:100% 19%;}100%{background-position:0% 82%;}}/*!sc*/
@keyframes hTUzwZ{0%{background-position:0% 82%;}50%{background-position:100% 19%;}100%{background-position:0% 82%;}}/*!sc*/
data-styled.g32[id="sc-keyframes-hTUzwZ"]{content:"hTUzwZ,"}/*!sc*/
</style><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml"/></head><body><div id="root"><nav class="Navigation__Container-sc-1yk0pqp-0 iuDFSN"><div class="ui__Fit-prwz6b-0 Navigation__NavFit-sc-1yk0pqp-1 izuwCZ"><p class="logo"><a href="/">Cisne.dev blog</a></p><div class="Navigation__BrightnessContainer-sc-1yk0pqp-2 TctaC"><div class="Navigation__BrightnessSpinner-sc-1yk0pqp-3 sLeDt"><button title="Mudar para modo diurno" aria-label="Mudar para modo diurno" class="Navigation__ClearButton-sc-1yk0pqp-4 Navigation__BrightnessIcon-sc-1yk0pqp-5 frsARl">🌙</button><button title="Mudar para modo noturno" aria-label="Mudar para modo noturno" class="Navigation__ClearButton-sc-1yk0pqp-4 Navigation__BrightnessIcon-sc-1yk0pqp-5 frsARl">☀️</button></div></div></div></nav><main><div class="ui__Fit-prwz6b-0 CfxHf"><div><div style="width:0%;opacity:0" class="post__ScrollTrackerContainer-gh0jqu-0 jjKdZc"></div><article class="Poststyles__Container-sc-12qb97v-4 kyWzPB"><h1 class="Poststyles__Title-sc-12qb97v-5 hhBwVH"><a href="/casamento-de-padroes-em-elixir/">Casamento de padrões em Elixir</a></h1><p class="Poststyles__Meta-sc-12qb97v-6 fonWHZ">Publicado em <!-- -->16 out 2020<!-- -->. Uns <!-- -->11<!-- --> minutos de leitura.</p><div class="Poststyles__Content-sc-12qb97v-7 jhgzPU content"><p>Um desafio de programação é conseguir escrever código de maneira mais sucinta sem sacrificar a facilidade de compreensão. É comum ver soluções de uma linha que resolvem o problema e ninguém entende como elas funcionam. Pensando nisso, algumas linguagens trazem sintaxe que permite escrever, de maneira idiomática, código mais expressivo. Um exemplo disso é <strong>casamento de padrões</strong>. Recentemente, comecei a estudar Elixir, e fiquei feliz em descobrir que <em>pattern matching</em> é uma parte importante da linguagem e resolvi trazer um pouco disso pra cá!</p><span><!-- summary-break --></span><p>Casamento de padrões é uma maneira de verificar se uma estrutura de dados tem um determinado formato. Nessa verificação, é possível extrair informação dessa estrutura. Um exemplo da intuição de casamento de padrões é o <em>destructuring</em>, bastante comum em JavaScript moderno:</p><pre class="refractor language-js"><code class="language-js"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#x27;Jane Doe&#x27;</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">31</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> person
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// Imprime &#x27;Jane Doe&#x27;</span></code></pre><p>Neste exemplo, na segunda linha, nós afirmamos que a estrutura de dados <code>person</code> tem o formato de um objeto com uma chave <code>name</code>. Como esse nome de variável está livre, atribuimos a ele o valor do atributo <code>name</code> do objeto. Destructuring porém apenas permite casar um objeto com uma lista de atributos, ou um array com uma lista de posições. Ele não nos permite fazer afirmações mais específicas sobre o formato da estrutura de dados ou despachar de maneira condicional a este formato.</p><h2>Casando padrões em Elixir</h2><p>Elixir é uma linguagem em que casamento de padrões faz parte de suas práticas idiomáticas. Nela, casamento de padrões nos permite fazer destructuring como no exemplo em JavaScript, porém também nos permite ir bem além. Vamos começar com a sintaxe de casamento de padrões e depois ver algumas aplicações.</p><p>Em Elixir, o operador <code>=</code> é chamado de operador de <strong>match</strong> (casamento), e não de atribuição como em outras linguagens. Ele executa um casamento de padrões entre o lado esquerdo e direito do operador.</p><pre class="refractor language-elixir"><code class="language-elixir">x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> <span class="token atom symbol">:bob</span><span class="token punctuation">}</span>
<span class="token comment"># Note que, em Elixir, `{}` delimitam uma tupla e não um objeto ou mapa, como em JavaScript. </span></code></pre><p>No exemplo acima, estamos fazendo um match de <code>x</code> com a tupla <code>{:alice, :bob}</code>. <code>x</code> é um identificador e a tupla é uma estrutura de dados. É possível que <code>x</code> tenha o mesmo formato que a tupla? Sim, se <code>x</code> tiver como valor <code>{:alice, :bob}</code>. E é isso que vai acontecer a partir dessa linha. Quando colocamos apenas um identificador do lado esquerdo do match, o operador funciona exatamente como uma atribuição.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> other_name<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> <span class="token atom symbol">:bob</span><span class="token punctuation">}</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>other_name<span class="token punctuation">)</span> <span class="token comment"># Imprime :bob</span></code></pre><p>Neste exemplo, fazemos um destructuring usando casamento de padrões. Nós definimos, do lado direito, que temos uma tupla cujo formato é ter <code>:alice</code> no primeiro elemento e um identificador <code>other_name</code> no segundo elemento. Em seguida, casamos isso com a tupla <code>{:alice, :bob}</code>. A única maneira de esse casamento dar certo é se <code>other_name</code> tiver o valor <code>:bob</code>, e é isso que vai acontecer nessa linha.</p><p>Note que só podemos usar identificadores para atribuir variáveis em casamento de padrões do lado esquerdo do operador de match. Do contrário recebemos um erro de compilação.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> <span class="token atom symbol">:bob</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> other_name<span class="token punctuation">}</span>
<span class="token comment"># ** (CompileError) iex:1: undefined function other_name/0</span></code></pre><p>Similarmente, recebemos um erro se os padrões não casarem:</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token punctuation">{</span><span class="token atom symbol">:alice</span><span class="token punctuation">,</span> other_name<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:charlie</span><span class="token punctuation">,</span> <span class="token atom symbol">:bob</span><span class="token punctuation">}</span>
<span class="token comment"># ** (MatchError) no match of right hand side value: {:charlie, :bob}</span></code></pre><p>Podemos casar outras estruturas de dados, também. Mapas, delimitados com <code>%{}</code>, podem casar com um subconjunto das suas chaves e listas podem casar com outra lista de mesmo tamanho ou com uma representação no formato <code>[cabeça_da_lista | resto_da_lista]</code>:</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">first_name:</span> name<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">first_name:</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">,</span> <span class="token attr-name">last_name:</span> <span class="token string">&quot;Doe&quot;</span><span class="token punctuation">}</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment"># Imprime &quot;Jane&quot;</span>

<span class="token punctuation">[</span>first_item <span class="token operator">|</span> other_items<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>first_item<span class="token punctuation">)</span> <span class="token comment"># Imprime 1</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>other_items<span class="token punctuation">)</span> <span class="token comment"># Imprime [2, 3, 4, 5]</span></code></pre><p>Como comentei no começo, identificadores no lado esquerdo do operador são tratados como uma atribuição de variável, usando o valor que casa do lado direito. É possível evitar essa atribuição e usar uma variável do lado esquerdo do operador de <strong>pin</strong> (fixação), <code>^</code>. Com ele, podemos fixar o valor da variável do lado esquerdo e usá-lo como parte do padrão a casar, e não como um destino para uma atribuição.</p><pre class="refractor language-elixir"><code class="language-elixir">result <span class="token operator">=</span> <span class="token atom symbol">:ok</span>
<span class="token punctuation">{</span><span class="token operator">^</span>result<span class="token punctuation">,</span> message<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token string">&quot;Your request was processed&quot;</span><span class="token punctuation">}</span>
IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token comment"># Imprime &quot;Your request was processed&quot; e não muda o valor de result</span>

<span class="token punctuation">{</span><span class="token operator">^</span>result<span class="token punctuation">,</span> message<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> <span class="token string">&quot;Your request was not processed&quot;</span><span class="token punctuation">}</span>
<span class="token comment"># ** (MatchError) no match of right hand side value: {:error, &quot;Your request was not processed&quot;}</span></code></pre><h2>Despachando com casamento de padrões</h2><p>Até agora vimos como casar padrões em Elixir. Porém, com o que vimos nós conseguimos apenas fazer atribuições de variáveis e destrucutring, além de gerar um erro quando o padrão não casa. Tirando o erro, não temos nada muito novo. Porém, podemos aplicar casamento de padrões a <strong>condicionais e funções</strong> para tomar caminhos diferentes no programa de acordo com o casamento ou não de padrões.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token comment"># Imagine uma consulta ao banco de dados que retorna quantos elementos existem.</span>
<span class="token comment"># O retorno é uma tupla com um código de status e um valor.</span>
result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span>

message <span class="token operator">=</span> <span class="token keyword">case</span> result <span class="token keyword">do</span>
  <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> element_count<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;There are <span class="token interpolation"><span class="token delimiter punctuation">#{</span>element_count<span class="token delimiter punctuation">}</span></span> elements&quot;</span>
  <span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> error_message<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;An error occurred: <span class="token interpolation"><span class="token delimiter punctuation">#{</span>error_message<span class="token delimiter punctuation">}</span></span>&quot;</span>
<span class="token keyword">end</span>

IO<span class="token punctuation">.</span>puts<span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token comment"># Imprime &quot;There are 50 elements&quot;</span></code></pre><p>Podemos usar a estrutura de controle <code>case</code> para casar padrões. Ela recebe uma entrada, <code>result</code> no nosso exemplo, e uma lista de possíveis padrões para tentar casar. Caso haja algum que dê match, o valor para que ele aponta (<code>-&gt;</code>) é retornado pelo <code>case</code>. Note que a lista de padrões a casar é equivalente ao <strong>lado esquerdo</strong> do operador de match. Ou seja, podemos colocar identificadores que se tornam variáveis no corpo após o <code>-&gt;</code> e podem ser usados no valor retornado.</p><p>É possível que o valor de entrada case com mais de um padrão, dependendo de como a lista seja especificada. Por isso, <strong>a ordem importa</strong>. Quando o primeiro padrão casar, os seguintes serão ignorados.</p><p>Vamos re-escrever o exemplo acima numa função para testar os diferentes retornos possíveis:</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> MockDB <span class="token keyword">do</span>
  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token keyword">case</span> result <span class="token keyword">do</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> element_count<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;There are <span class="token interpolation"><span class="token delimiter punctuation">#{</span>element_count<span class="token delimiter punctuation">}</span></span> elements&quot;</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> error_message<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;An error occurred: <span class="token interpolation"><span class="token delimiter punctuation">#{</span>error_message<span class="token delimiter punctuation">}</span></span>&quot;</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;There are 42 elements&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> <span class="token string">&quot;DB is offline&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;An error occurred: DB is offline&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:palha_italiana</span><span class="token punctuation">,</span> <span class="token string">&quot;Really tasty&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># ** (CaseClauseError) no case clause matching: {:palha_italiana, &quot;Really tasty&quot;}</span>
<span class="token comment">#     iex:10: MockDB.display_result/1</span></code></pre><p>Caso não haja um padrão que case, tomamos um erro. É possível tratar esse caso garantindo que, ao fim da lista, sempre haverá um padrão que case. Podemos colocar um identificador qualquer (<code>x -&gt; &quot;????&quot;</code>), mas isso vai criar uma variável local de que não precisamos. Ao invés de usar <code>x</code>, podemos usar o identificador especial <code>_</code>. Não é possível ler dessa variável, e podemos atribuir a ela sem nos importar.</p><p>Além disso, podemos ter casamentos com partes similares, desde que a mais específica fique acima da mais geral. Por exemplo, podemos querer tratar separadamente o caso em que haja exatamente um elemento retornado.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> MockDB <span class="token keyword">do</span>
  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token keyword">case</span> result <span class="token keyword">do</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;There is only one element&quot;</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> element_count<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;There are <span class="token interpolation"><span class="token delimiter punctuation">#{</span>element_count<span class="token delimiter punctuation">}</span></span> elements&quot;</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> error_message<span class="token punctuation">}</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;An error occurred: <span class="token interpolation"><span class="token delimiter punctuation">#{</span>error_message<span class="token delimiter punctuation">}</span></span>&quot;</span>
      _ <span class="token operator">-&gt;</span> <span class="token string">&quot;????&quot;</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;There is only one element&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:palha_italiana</span><span class="token punctuation">,</span> <span class="token string">&quot;Really tasty&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;????&quot;</span></code></pre><p>O <code>case</code> não é a única maneira de despachar de acordo com casamento de padrões! Como comentei, Elixir define casamento de padrões como parte idiomática da linguagem, e seu uso vai além disso. Podemos usar casamento de padrões para <strong>mudar a execução de uma função</strong>. Vamos re-escrever o exemplo acima mais uma vez, com essa ideia:</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> MockDB <span class="token keyword">do</span>
  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token string">&quot;There is only one element&quot;</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> element_count<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token string">&quot;There are <span class="token interpolation"><span class="token delimiter punctuation">#{</span>element_count<span class="token delimiter punctuation">}</span></span> elements&quot;</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> error_message<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token string">&quot;An error occurred: <span class="token interpolation"><span class="token delimiter punctuation">#{</span>error_message<span class="token delimiter punctuation">}</span></span>&quot;</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> display_result<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token string">&quot;????&quot;</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;There is only one element&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;There are 42 elements&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:error</span><span class="token punctuation">,</span> <span class="token string">&quot;DB is offline&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;An error occurred: DB is offline&quot;</span>

MockDB<span class="token punctuation">.</span>display_result<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:palha_italiana</span><span class="token punctuation">,</span> <span class="token string">&quot;Really tasty&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment"># Imprime &quot;????&quot;</span></code></pre><p><strong>Podemos usar casamento de padrões nos argumentos de uma função.</strong> Declaramos mais de uma vez uma mesma função, porém em cada declaração, definimos um padrão diferente para o primeiro argumento. Cada vez que essa função for chamada, Elixir vai, em ordem, tentar casar os argumentos com os padrões e, quando encontrar um casamento que dê match, o corpo dessa declaração é executado.</p><p>Nossas funções neste caso apenas retornam strings, mas nada impede que cada uma faça algo totalmente diferente. Isso nos permite, rapidamente, saber que formatos de dados essa função está pronta para lidar. Como definimos um padrão que sempre vai casar com qualquer coisa (o <code>_</code>), essa função nunca vai retornar um erro de casamento de padrões.</p><p>Vamos ver outro exemplo, dessa vez fazendo casamento um valor mais simples. Ao invés de casar uma tupla, vamos casar um número. Podemos fazer isso para implementar um <a href="https://pt.wikipedia.org/wiki/Fatorial">cálculo de fatorial</a>. O fatorial de um número <code>n</code> é o produto de todos os números inteiros de 1 até <code>n</code>. Fora isso, por definição, o fatorial de zero é 1. </p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token comment"># Definição de como funciona o fatorial</span>
factorial<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>
factorial<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>Podemos implementar esse fatorial, de maneira recursiva, usando casamento de padrões.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> Math <span class="token keyword">do</span>
  <span class="token keyword">def</span> factorial<span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token keyword">do</span>
    factorial<span class="token punctuation">(</span>number<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> factorial<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> current_product<span class="token punctuation">)</span> <span class="token keyword">do</span>
    current_product
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> factorial<span class="token punctuation">(</span>number<span class="token punctuation">,</span> current_product<span class="token punctuation">)</span> <span class="token keyword">do</span>
    factorial<span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> number <span class="token operator">*</span> current_product<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

Math<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment"># Retorna 1</span>
Math<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># Retorna 1</span>
Math<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment"># Retorna 2432902008176640000</span></code></pre><p>Temos duas funções: uma que recebe um argumento (também chamada de <code>Math.factorial/1</code>) e outra que recebe dois argumentos (chamada <code>Math.factorial/2</code>). A primeira serve apenas de conveniência, e é pública. Ela chama a segunda inicializando o produto com <code>1</code>. Na função com dois argumentos é que temos um casamento de padrões. Vamos tentar, primeiramente, casar o primeiro argumento com o padrão <code>0</code>. A única maneira desse casamento bater é se o argumento for, de fato, <code>0</code>.</p><p>Se o padrão casa, nós retornamos o produto acumulado até agora (segundo argumento da função). Se ele não casa, nós tentamos a segunda definição da função. Na segunda definição, o casamento vai com certeza acontecer pois temos apenas identificadores em todos os argumentos. O que essa definição faz é chamar, recursivamente, a função subtraindo 1 do primeiro argumento e multiplicando o produto acumulado pelo primeiro argumento. </p><p>Lembre-se que a <strong>ordem é importante no casamento de padrões</strong>. Se invertêssemos e colocássemos o caso em que o primeiro argumento é <code>0</code> embaixo, ele nunca seria executado pois o valor <code>0</code> iria casar com o outro caso primeiro, o que é apenas uma variável <code>number</code>.</p><p>Um benefício adicional dessa implementação é que ela é uma <a href="https://pt.wikipedia.org/wiki/Recursividade_(ciência_da_computação)#Funções_recursivas_em_cauda">recursão de cauda</a> (<em>tail recursion</em>), ou seja, cada iteração da recursão não precisa de espaço adicional na pilha de chamadas de função. Isso é útil pois, do contrário, ao tentar calcular um fatorial muito grande podemos ter um erro de estouro de pilha. Note também que, caso você passe um valor negativo para a função, ela vai executar infinitamente. Uma maneira de evitar isso é usando <a href="https://hexdocs.pm/elixir/guards.html">guards</a>.</p><h2>Pra onde vou agora?</h2><p>Trouxe aqui um pouco de como funciona casamento de padrões em Elixir e alguns exemplos de como utilizar para escrever condições mais claras. Com isso, conseguimos por exemplo separar fluxos de execução de acordo com o formato de uma estrutura de dados.</p><p>A documentação oficial de Elixir é bem detalhada e traz ainda mais conteúdo sobre o assunto. Eu comecei a usar a linguagem para aprender, e os tutoriais da documentação ajudaram bastante. Se você quer começar, sugiro partir do <a href="https://elixir-lang.org/getting-started/introduction.html">guia de introdução</a> e seguir o passo a passo. Sobre esses assuntos que vimos, essas páginas são bem úteis:</p><ul><li><a href="https://elixir-lang.org/getting-started/pattern-matching.html">Pattern matching</a></li><li><a href="https://elixir-lang.org/getting-started/case-cond-and-if.html">case, cond, and if</a></li><li><a href="https://elixir-lang.org/getting-started/modules-and-functions.html">Modules and functions</a></li><li><a href="https://elixir-lang.org/getting-started/recursion.html">Recursion</a></li></ul><p>E se esse post te trouxe ideias, ou se tem sugestões de como melhorar algum dos exemplos, <a href="https://twitter.com/Cisneiros">me dá um oi no Twitter</a>! 👋</p></div><hr/><div class="Poststyles__AfterPost-sc-12qb97v-0 tuaWG"><p class="Poststyles__AfterPostChild-sc-12qb97v-1 gkeqUt">Gostou? <a href="https://twitter.com/intent/tweet?text=%22Casamento%20de%20padr%C3%B5es%20em%20Elixir%22%20por%20%40Cisneiros%0A%0Ahttps%3A%2F%2Fblog.cisne.dev%2Fcasamento-de-padroes-em-elixir" target="_blank" rel="noopener noreferrer">Que tal compartilhar?</a></p><p class="Poststyles__AfterPostChild-sc-12qb97v-1 Poststyles__Tags-sc-12qb97v-2 fAvgXR">Tags: <span class="Poststyles__Tag-sc-12qb97v-3 kSZCZX"><a href="/tag/elixir">elixir</a></span></p></div></article></div></div></main><footer class="Footer__Container-b3q04c-0 gdHjSq"><div class="ui__Fit-prwz6b-0 Footer__FooterFit-b3q04c-1 layJcq"><p>© <a href="https://cisne.dev">Alexandre Cisneiros</a></p><p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a></p></div></footer></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/src/containers/post\",\"sharedHashesByProp\":{},\"data\":{\"postData\":{\"title\":\"Casamento de padr\u00F5es em Elixir\",\"date\":\"2020-10-16T00:00:00-03:00\",\"slug\":\"casamento-de-padroes-em-elixir\",\"tags\":[\"elixir\"],\"filePath\":\"2020-10-16-casamento-de-padroes-em-elixir.md\",\"content\":\"Um desafio de programa\u00E7\u00E3o \u00E9 conseguir escrever c\u00F3digo de maneira mais sucinta sem sacrificar a facilidade de compreens\u00E3o. \u00C9 comum ver solu\u00E7\u00F5es de uma linha que resolvem o problema e ningu\u00E9m entende como elas funcionam. Pensando nisso, algumas linguagens trazem sintaxe que permite escrever, de maneira idiom\u00E1tica, c\u00F3digo mais expressivo. Um exemplo disso \u00E9 **casamento de padr\u00F5es**. Recentemente, comecei a estudar Elixir, e fiquei feliz em descobrir que _pattern matching_ \u00E9 uma parte importante da linguagem e resolvi trazer um pouco disso pra c\u00E1!\\n\\n\u003C!-- summary-break -->\\n\\nCasamento de padr\u00F5es \u00E9 uma maneira de verificar se uma estrutura de dados tem um determinado formato. Nessa verifica\u00E7\u00E3o, \u00E9 poss\u00EDvel extrair informa\u00E7\u00E3o dessa estrutura. Um exemplo da intui\u00E7\u00E3o de casamento de padr\u00F5es \u00E9 o _destructuring_, bastante comum em JavaScript moderno:\\n\\n```js\\nconst person = { name: 'Jane Doe', age: 31 }\\nconst { name } = person\\nconsole.log(name) // Imprime 'Jane Doe'\\n```\\n\\nNeste exemplo, na segunda linha, n\u00F3s afirmamos que a estrutura de dados `person` tem o formato de um objeto com uma chave `name`. Como esse nome de vari\u00E1vel est\u00E1 livre, atribuimos a ele o valor do atributo `name` do objeto. Destructuring por\u00E9m apenas permite casar um objeto com uma lista de atributos, ou um array com uma lista de posi\u00E7\u00F5es. Ele n\u00E3o nos permite fazer afirma\u00E7\u00F5es mais espec\u00EDficas sobre o formato da estrutura de dados ou despachar de maneira condicional a este formato.\\n\\n## Casando padr\u00F5es em Elixir\\n\\nElixir \u00E9 uma linguagem em que casamento de padr\u00F5es faz parte de suas pr\u00E1ticas idiom\u00E1ticas. Nela, casamento de padr\u00F5es nos permite fazer destructuring como no exemplo em JavaScript, por\u00E9m tamb\u00E9m nos permite ir bem al\u00E9m. Vamos come\u00E7ar com a sintaxe de casamento de padr\u00F5es e depois ver algumas aplica\u00E7\u00F5es.\\n\\nEm Elixir, o operador `=` \u00E9 chamado de operador de **match** (casamento), e n\u00E3o de atribui\u00E7\u00E3o como em outras linguagens. Ele executa um casamento de padr\u00F5es entre o lado esquerdo e direito do operador.\\n\\n```elixir\\nx = {:alice, :bob}\\n# Note que, em Elixir, `{}` delimitam uma tupla e n\u00E3o um objeto ou mapa, como em JavaScript. \\n```\\n\\nNo exemplo acima, estamos fazendo um match de `x` com a tupla `{:alice, :bob}`. `x` \u00E9 um identificador e a tupla \u00E9 uma estrutura de dados. \u00C9 poss\u00EDvel que `x` tenha o mesmo formato que a tupla? Sim, se `x` tiver como valor `{:alice, :bob}`. E \u00E9 isso que vai acontecer a partir dessa linha. Quando colocamos apenas um identificador do lado esquerdo do match, o operador funciona exatamente como uma atribui\u00E7\u00E3o.\\n\\n```elixir\\n{:alice, other_name} = {:alice, :bob}\\nIO.puts(other_name) # Imprime :bob\\n```\\n\\nNeste exemplo, fazemos um destructuring usando casamento de padr\u00F5es. N\u00F3s definimos, do lado direito, que temos uma tupla cujo formato \u00E9 ter `:alice` no primeiro elemento e um identificador `other_name` no segundo elemento. Em seguida, casamos isso com a tupla `{:alice, :bob}`. A \u00FAnica maneira de esse casamento dar certo \u00E9 se `other_name` tiver o valor `:bob`, e \u00E9 isso que vai acontecer nessa linha.\\n\\nNote que s\u00F3 podemos usar identificadores para atribuir vari\u00E1veis em casamento de padr\u00F5es do lado esquerdo do operador de match. Do contr\u00E1rio recebemos um erro de compila\u00E7\u00E3o.\\n\\n```elixir\\n{:alice, :bob} = {:alice, other_name}\\n# ** (CompileError) iex:1: undefined function other_name/0\\n```\\n\\nSimilarmente, recebemos um erro se os padr\u00F5es n\u00E3o casarem:\\n\\n```elixir\\n{:alice, other_name} = {:charlie, :bob}\\n# ** (MatchError) no match of right hand side value: {:charlie, :bob}\\n```\\n\\nPodemos casar outras estruturas de dados, tamb\u00E9m. Mapas, delimitados com `%{}`, podem casar com um subconjunto das suas chaves e listas podem casar com outra lista de mesmo tamanho ou com uma representa\u00E7\u00E3o no formato `[cabe\u00E7a_da_lista | resto_da_lista]`:\\n\\n```elixir\\n%{first_name: name} = %{first_name: \\\"Jane\\\", last_name: \\\"Doe\\\"}\\nIO.puts(name) # Imprime \\\"Jane\\\"\\n\\n[first_item | other_items] = [1, 2, 3, 4, 5]\\nIO.puts(first_item) # Imprime 1\\nIO.puts(other_items) # Imprime [2, 3, 4, 5]\\n```\\n\\nComo comentei no come\u00E7o, identificadores no lado esquerdo do operador s\u00E3o tratados como uma atribui\u00E7\u00E3o de vari\u00E1vel, usando o valor que casa do lado direito. \u00C9 poss\u00EDvel evitar essa atribui\u00E7\u00E3o e usar uma vari\u00E1vel do lado esquerdo do operador de **pin** (fixa\u00E7\u00E3o), `^`. Com ele, podemos fixar o valor da vari\u00E1vel do lado esquerdo e us\u00E1-lo como parte do padr\u00E3o a casar, e n\u00E3o como um destino para uma atribui\u00E7\u00E3o.\\n\\n```elixir\\nresult = :ok\\n{^result, message} = {:ok, \\\"Your request was processed\\\"}\\nIO.puts(message) # Imprime \\\"Your request was processed\\\" e n\u00E3o muda o valor de result\\n\\n{^result, message} = {:error, \\\"Your request was not processed\\\"}\\n# ** (MatchError) no match of right hand side value: {:error, \\\"Your request was not processed\\\"}\\n```\\n\\n## Despachando com casamento de padr\u00F5es\\n\\nAt\u00E9 agora vimos como casar padr\u00F5es em Elixir. Por\u00E9m, com o que vimos n\u00F3s conseguimos apenas fazer atribui\u00E7\u00F5es de vari\u00E1veis e destrucutring, al\u00E9m de gerar um erro quando o padr\u00E3o n\u00E3o casa. Tirando o erro, n\u00E3o temos nada muito novo. Por\u00E9m, podemos aplicar casamento de padr\u00F5es a **condicionais e fun\u00E7\u00F5es** para tomar caminhos diferentes no programa de acordo com o casamento ou n\u00E3o de padr\u00F5es.\\n\\n```elixir\\n# Imagine uma consulta ao banco de dados que retorna quantos elementos existem.\\n# O retorno \u00E9 uma tupla com um c\u00F3digo de status e um valor.\\nresult = {:ok, 50}\\n\\nmessage = case result do\\n  {:ok, element_count} -> \\\"There are #{element_count} elements\\\"\\n  {:error, error_message} -> \\\"An error occurred: #{error_message}\\\"\\nend\\n\\nIO.puts(message) # Imprime \\\"There are 50 elements\\\"\\n```\\n\\nPodemos usar a estrutura de controle `case` para casar padr\u00F5es. Ela recebe uma entrada, `result` no nosso exemplo, e uma lista de poss\u00EDveis padr\u00F5es para tentar casar. Caso haja algum que d\u00EA match, o valor para que ele aponta (`->`) \u00E9 retornado pelo `case`. Note que a lista de padr\u00F5es a casar \u00E9 equivalente ao **lado esquerdo** do operador de match. Ou seja, podemos colocar identificadores que se tornam vari\u00E1veis no corpo ap\u00F3s o `->` e podem ser usados no valor retornado.\\n\\n\u00C9 poss\u00EDvel que o valor de entrada case com mais de um padr\u00E3o, dependendo de como a lista seja especificada. Por isso, **a ordem importa**. Quando o primeiro padr\u00E3o casar, os seguintes ser\u00E3o ignorados.\\n\\nVamos re-escrever o exemplo acima numa fun\u00E7\u00E3o para testar os diferentes retornos poss\u00EDveis:\\n\\n```elixir\\ndefmodule MockDB do\\n  def display_result(result) do\\n    case result do\\n      {:ok, element_count} -> \\\"There are #{element_count} elements\\\"\\n      {:error, error_message} -> \\\"An error occurred: #{error_message}\\\"\\n    end\\n  end\\nend\\n\\nMockDB.display_result({:ok, 42})\\n# Imprime \\\"There are 42 elements\\\"\\n\\nMockDB.display_result({:error, \\\"DB is offline\\\"})\\n# Imprime \\\"An error occurred: DB is offline\\\"\\n\\nMockDB.display_result({:palha_italiana, \\\"Really tasty\\\"})\\n# ** (CaseClauseError) no case clause matching: {:palha_italiana, \\\"Really tasty\\\"}\\n#     iex:10: MockDB.display_result/1\\n```\\n\\nCaso n\u00E3o haja um padr\u00E3o que case, tomamos um erro. \u00C9 poss\u00EDvel tratar esse caso garantindo que, ao fim da lista, sempre haver\u00E1 um padr\u00E3o que case. Podemos colocar um identificador qualquer (`x -> \\\"????\\\"`), mas isso vai criar uma vari\u00E1vel local de que n\u00E3o precisamos. Ao inv\u00E9s de usar `x`, podemos usar o identificador especial `_`. N\u00E3o \u00E9 poss\u00EDvel ler dessa vari\u00E1vel, e podemos atribuir a ela sem nos importar.\\n\\nAl\u00E9m disso, podemos ter casamentos com partes similares, desde que a mais espec\u00EDfica fique acima da mais geral. Por exemplo, podemos querer tratar separadamente o caso em que haja exatamente um elemento retornado.\\n\\n```elixir\\ndefmodule MockDB do\\n  def display_result(result) do\\n    case result do\\n      {:ok, 1} -> \\\"There is only one element\\\"\\n      {:ok, element_count} -> \\\"There are #{element_count} elements\\\"\\n      {:error, error_message} -> \\\"An error occurred: #{error_message}\\\"\\n      _ -> \\\"????\\\"\\n    end\\n  end\\nend\\n\\nMockDB.display_result({:ok, 1})\\n# Imprime \\\"There is only one element\\\"\\n\\nMockDB.display_result({:palha_italiana, \\\"Really tasty\\\"})\\n# Imprime \\\"????\\\"\\n```\\n\\nO `case` n\u00E3o \u00E9 a \u00FAnica maneira de despachar de acordo com casamento de padr\u00F5es! Como comentei, Elixir define casamento de padr\u00F5es como parte idiom\u00E1tica da linguagem, e seu uso vai al\u00E9m disso. Podemos usar casamento de padr\u00F5es para **mudar a execu\u00E7\u00E3o de uma fun\u00E7\u00E3o**. Vamos re-escrever o exemplo acima mais uma vez, com essa ideia:\\n\\n```elixir\\ndefmodule MockDB do\\n  def display_result({:ok, 1}) do\\n    \\\"There is only one element\\\"\\n  end\\n\\n  def display_result({:ok, element_count}) do\\n    \\\"There are #{element_count} elements\\\"\\n  end\\n\\n  def display_result({:error, error_message}) do\\n    \\\"An error occurred: #{error_message}\\\"\\n  end\\n\\n  def display_result(_) do\\n    \\\"????\\\"\\n  end\\nend\\n\\nMockDB.display_result({:ok, 1})\\n# Imprime \\\"There is only one element\\\"\\n\\nMockDB.display_result({:ok, 42})\\n# Imprime \\\"There are 42 elements\\\"\\n\\nMockDB.display_result({:error, \\\"DB is offline\\\"})\\n# Imprime \\\"An error occurred: DB is offline\\\"\\n\\nMockDB.display_result({:palha_italiana, \\\"Really tasty\\\"})\\n# Imprime \\\"????\\\"\\n```\\n\\n**Podemos usar casamento de padr\u00F5es nos argumentos de uma fun\u00E7\u00E3o.** Declaramos mais de uma vez uma mesma fun\u00E7\u00E3o, por\u00E9m em cada declara\u00E7\u00E3o, definimos um padr\u00E3o diferente para o primeiro argumento. Cada vez que essa fun\u00E7\u00E3o for chamada, Elixir vai, em ordem, tentar casar os argumentos com os padr\u00F5es e, quando encontrar um casamento que d\u00EA match, o corpo dessa declara\u00E7\u00E3o \u00E9 executado.\\n\\nNossas fun\u00E7\u00F5es neste caso apenas retornam strings, mas nada impede que cada uma fa\u00E7a algo totalmente diferente. Isso nos permite, rapidamente, saber que formatos de dados essa fun\u00E7\u00E3o est\u00E1 pronta para lidar. Como definimos um padr\u00E3o que sempre vai casar com qualquer coisa (o `_`), essa fun\u00E7\u00E3o nunca vai retornar um erro de casamento de padr\u00F5es.\\n\\nVamos ver outro exemplo, dessa vez fazendo casamento um valor mais simples. Ao inv\u00E9s de casar uma tupla, vamos casar um n\u00FAmero. Podemos fazer isso para implementar um [c\u00E1lculo de fatorial](https://pt.wikipedia.org/wiki/Fatorial). O fatorial de um n\u00FAmero `n` \u00E9 o produto de todos os n\u00FAmeros inteiros de 1 at\u00E9 `n`. Fora isso, por defini\u00E7\u00E3o, o fatorial de zero \u00E9 1. \\n\\n```elixir\\n# Defini\u00E7\u00E3o de como funciona o fatorial\\nfactorial(0) == 1\\nfactorial(n) == n * factorial(n - 1)\\n```\\n\\nPodemos implementar esse fatorial, de maneira recursiva, usando casamento de padr\u00F5es.\\n\\n```elixir\\ndefmodule Math do\\n  def factorial(number) do\\n    factorial(number, 1)\\n  end\\n\\n  defp factorial(0, current_product) do\\n    current_product\\n  end\\n\\n  defp factorial(number, current_product) do\\n    factorial(number - 1, number * current_product)\\n  end\\nend\\n\\nMath.factorial(0) # Retorna 1\\nMath.factorial(1) # Retorna 1\\nMath.factorial(20) # Retorna 2432902008176640000\\n```\\n\\nTemos duas fun\u00E7\u00F5es: uma que recebe um argumento (tamb\u00E9m chamada de `Math.factorial/1`) e outra que recebe dois argumentos (chamada `Math.factorial/2`). A primeira serve apenas de conveni\u00EAncia, e \u00E9 p\u00FAblica. Ela chama a segunda inicializando o produto com `1`. Na fun\u00E7\u00E3o com dois argumentos \u00E9 que temos um casamento de padr\u00F5es. Vamos tentar, primeiramente, casar o primeiro argumento com o padr\u00E3o `0`. A \u00FAnica maneira desse casamento bater \u00E9 se o argumento for, de fato, `0`.\\n\\nSe o padr\u00E3o casa, n\u00F3s retornamos o produto acumulado at\u00E9 agora (segundo argumento da fun\u00E7\u00E3o). Se ele n\u00E3o casa, n\u00F3s tentamos a segunda defini\u00E7\u00E3o da fun\u00E7\u00E3o. Na segunda defini\u00E7\u00E3o, o casamento vai com certeza acontecer pois temos apenas identificadores em todos os argumentos. O que essa defini\u00E7\u00E3o faz \u00E9 chamar, recursivamente, a fun\u00E7\u00E3o subtraindo 1 do primeiro argumento e multiplicando o produto acumulado pelo primeiro argumento. \\n\\nLembre-se que a **ordem \u00E9 importante no casamento de padr\u00F5es**. Se invert\u00EAssemos e coloc\u00E1ssemos o caso em que o primeiro argumento \u00E9 `0` embaixo, ele nunca seria executado pois o valor `0` iria casar com o outro caso primeiro, o que \u00E9 apenas uma vari\u00E1vel `number`.\\n\\nUm benef\u00EDcio adicional dessa implementa\u00E7\u00E3o \u00E9 que ela \u00E9 uma [recurs\u00E3o de cauda](https://pt.wikipedia.org/wiki/Recursividade_(ci\u00EAncia_da_computa\u00E7\u00E3o)#Fun\u00E7\u00F5es_recursivas_em_cauda) (_tail recursion_), ou seja, cada itera\u00E7\u00E3o da recurs\u00E3o n\u00E3o precisa de espa\u00E7o adicional na pilha de chamadas de fun\u00E7\u00E3o. Isso \u00E9 \u00FAtil pois, do contr\u00E1rio, ao tentar calcular um fatorial muito grande podemos ter um erro de estouro de pilha. Note tamb\u00E9m que, caso voc\u00EA passe um valor negativo para a fun\u00E7\u00E3o, ela vai executar infinitamente. Uma maneira de evitar isso \u00E9 usando [guards](https://hexdocs.pm/elixir/guards.html).\\n\\n## Pra onde vou agora?\\n\\nTrouxe aqui um pouco de como funciona casamento de padr\u00F5es em Elixir e alguns exemplos de como utilizar para escrever condi\u00E7\u00F5es mais claras. Com isso, conseguimos por exemplo separar fluxos de execu\u00E7\u00E3o de acordo com o formato de uma estrutura de dados.\\n\\nA documenta\u00E7\u00E3o oficial de Elixir \u00E9 bem detalhada e traz ainda mais conte\u00FAdo sobre o assunto. Eu comecei a usar a linguagem para aprender, e os tutoriais da documenta\u00E7\u00E3o ajudaram bastante. Se voc\u00EA quer come\u00E7ar, sugiro partir do [guia de introdu\u00E7\u00E3o](https://elixir-lang.org/getting-started/introduction.html) e seguir o passo a passo. Sobre esses assuntos que vimos, essas p\u00E1ginas s\u00E3o bem \u00FAteis:\\n\\n- [Pattern matching](https://elixir-lang.org/getting-started/pattern-matching.html)\\n- [case, cond, and if](https://elixir-lang.org/getting-started/case-cond-and-if.html)\\n- [Modules and functions](https://elixir-lang.org/getting-started/modules-and-functions.html)\\n- [Recursion](https://elixir-lang.org/getting-started/recursion.html)\\n\\nE se esse post te trouxe ideias, ou se tem sugest\u00F5es de como melhorar algum dos exemplos, [me d\u00E1 um oi no Twitter](https://twitter.com/Cisneiros)! \uD83D\uDC4B\\n\",\"readingTime\":11,\"summary\":\"Um desafio de programa\u00E7\u00E3o \u00E9 conseguir escrever c\u00F3digo de maneira mais sucinta sem sacrificar a facilidade de compreens\u00E3o. \u00C9 comum ver solu\u00E7\u00F5es de uma linha que resolvem o problema e ningu\u00E9m entende como elas funcionam. Pensando nisso, algumas linguagens trazem sintaxe que permite escrever, de maneira idiom\u00E1tica, c\u00F3digo mais expressivo. Um exemplo disso \u00E9 **casamento de padr\u00F5es**. Recentemente, comecei a estudar Elixir, e fiquei feliz em descobrir que _pattern matching_ \u00E9 uma parte importante da linguagem e resolvi trazer um pouco disso pra c\u00E1!\\n\\n\"}},\"path\":\"casamento-de-padroes-em-elixir\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/vendors~__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.207edc50.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.a04ea84b.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/post.d8dd52db.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.272ae1d1.js"></script><script defer="" type="text/javascript" src="/main.f19d4c14.js"></script></body></html>