{"template":"__react_static_root__/src/containers/post","sharedHashesByProp":{},"data":{"postData":{"title":"Animando um personagem com CSS e JavaScript","date":"2020-07-10T00:00:00-03:00","slug":"animando-um-personagem-com-css-e-javascript","tags":["css","javascript","frontend"],"filePath":"2020-07-10-animando-um-personagem-com-css-e-javascript.md","content":"CSS é uma parada poderosa. Apesar de, originalmente, servir para suportar o HTML e definir estilos para itens em um documento, a comunidade de desenvolvimento front-end mostrou que dá para fazer muito mais que isso e cria verdadeiras experiências com CSS, substituindo ferramentas de animação e imagens por linhas de código de folha de estilos. Juntando isso com o dinamismo de JavaScript, dá para criar interações bem legais diretamente na web, muitas vezes sem assets extra além do próprio código.\n\nEsse post é um experimento para criar algo que não é novo, mas que é divertido e mostra algumas das capacidades de criar animações interativas com CSS e JS. Minha ideia é tentar fazer uma animação para acompanhar um formulário de login sem usar imagens ou outros recursos além de HTML, CSS e JS. **Eu não sou um artista então não espere uma obra de arte.** A ideia é, com pouco código, fazer um efeito que fique legal.\n\n<!-- summary-break -->\n\n## Como ficou\n\nInteraja com os campos de nome de usuário e senha abaixo para animar o personagem.\n\n:::live result-first\n\n## O código\n\nEsse é o código final. Logo abaixo, vou comentar cada trecho de código, ressaltar os pontos mais interessantes e explicar algumas partes que não são tão claras de cara.\n\n```html\n<div id=\"login-form\">\n  <div class=\"character\">\n    <div class=\"eyes\">\n      <div class=\"eye\"></div>\n      <div class=\"eye\"></div>\n    </div>\n  </div>\n  <input class=\"username\" type=\"text\" placeholder=\"username\" maxlength=\"20\">\n  <input class=\"password\" type=\"password\" placeholder=\"password\">\n</div>\n```\n```css\n#login-form {\n  --size: 300px;\n  \n  display: flex;\n  flex-direction: column;\n  justify-content: space-around;\n  align-items: center;\n  padding: 10%;\n  width: var(--size);\n  min-height: var(--size);\n  border-radius: 10%;\n  background-color: #d9d1d1;\n}\n\n#login-form input {\n  padding: 0.25em;\n  border-radius: 0.5em;\n}\n\n.character {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-around;\n  align-items: center;\n  width: calc(var(--size) / 3);\n  height: calc(var(--size) / 3);\n  border-radius: 40% 40% 0 0;\n  background-color: #d95151;\n}\n\n.character .eyes {\n  --eye-ball-offset: 50%;\n  --eye-ball-size: 35%;\n\n  display: flex;\n  justify-content: space-evenly;\n  width: 80%;\n}\n\n.character .eyes .eye {\n  position: relative;\n  transition: height 0.2s ease-in;\n  overflow: hidden;\n  width: 35%;\n  border-radius: 50%;\n  background-color: #190000;\n}\n\n.character .eyes .eye::before {\n  content: '';\n  display: block;\n  transition: padding-top 0.2s ease-in;\n  padding-top: 100%;\n}\n\n.character .eyes.closed .eye::before {\n  padding-top: 2px;\n}\n\n.character .eyes .eye::after {\n  content: '';\n  position: absolute;\n  bottom: 5%;\n  left: var(--eye-ball-offset);\n  transform: translateX(-50%);\n  transition: all 0.2s ease-in;\n  width: var(--eye-ball-size);\n  height: var(--eye-ball-size);\n  border-radius: 50%;\n  background-color: #faffff;\n}\n\n.character .eyes.closed .eye::after {\n  height: 0;\n}\n```\n```js auto-run\nconst loginForm = document.querySelector('#login-form')\nconst characterEyes = loginForm.querySelector('.eyes')\nconst usernameInput = loginForm.querySelector('.username')\nconst passwordInput = loginForm.querySelector('.password')\n\nfunction updateEyeballPosition(value) {\n  if (typeof value !== 'number') {\n    const offset = usernameInput.value.length * (100 / usernameInput.maxLength)\n    value = Math.max(Math.min(offset, 90), 10)\n  }\n\n  characterEyes.style.setProperty('--eye-ball-offset', `${value}%`);\n}\n\nusernameInput.addEventListener('keyup', () => updateEyeballPosition())\nusernameInput.addEventListener('focus', () => updateEyeballPosition())\nusernameInput.addEventListener('blur', () => updateEyeballPosition(50))\n\npasswordInput.addEventListener('focus', () => characterEyes.classList.add('closed'))\npasswordInput.addEventListener('blur', () => characterEyes.classList.remove('closed'))\n```\n:::/live\n\n## Destrinchando o CSS\n\nO HTML é razoavelmente auto-explicativo: temos um um personagem e dois campos de texto, um deles para senha. Dentro do personagem, temos `div`s de estrutura com elementos necessários pra construir o desenho e a animação. Eu normalmente crio um elemento raíz e saio criando mais elementos quando vejo que vão ser necessários, como nesse caso foram os olhos (um container em volta deles e um `div` pra cada olho). As pupilas eu deixei para criar pseudoelementos com CSS.\n\nO grosso do código está no CSS. Eu tentei definir medidas relativas dentro do personagem sempre que possível, para que escalá-lo fosse mais fácil. Deixei como asboluto apenas o tamanho dele (300px).\n\nNo personagem, eu usei bastante **flexbox**. É um tipo de layout (`display: flex`) que permite que o elemento defina como os elementos diretamente descendentes vão se posicionar. No caso do elemento raíz do personagem, a direção dos elementos é na vertical (`flex-direction: column`). Eu tinha planos para por uma boca no início, mas terminei deixando sem. De toda maneira, colocar na vertical permite centralizar os olhos usando espaçamento em volta do (único) descendente (`justify-content: space-around`).\n\nDentro do elementos que contém os olhos do personagem (`.eyes`), vamos ter dois elementos, um para cada olho (`.eye`). Eles também estão alinhados dentro usando flex, mas dessa vez a direção é na horizontal (`row`). Como é o padrão, não precisa especificar.\n\nAgora vem um dos _pulos do gato_: os olhos. Eu queria fazer os olhos serem retangulares (redondos na verdade, mas para chegar no círculo começamos em um quadrado). Porém, não queria definir valores absolutos para a largura e altura de cada olho. Ao invés disso, queria definir uma largura proporcional a largura do personagem e que a altura do olho fosse igual a largura dele. **Só que não é tão fácil.**\n\nQuando a gente diz que um elemento tem `width: 50%`, a gente quer dizer que ele tem metade da **largura** (`width`) do parente. Quando a gente diz que ele tem `height: 50%`, ele vai ter metade da **altura** (`height`) do parente. A linha dos olhos não tem uma altura definida, então um percentual sobre a altura iria resultar em **zero**, se não tiver nenhum outro elemento dentro que defina uma altura.\n\nA solução pro meu problema era em teoria, simples: eu queria poder especificar a **altura** do olho em função da **largura** do parente, igual como fiz com a própria largura do olho. Mas não consigo fazer isso diretamente. Ora, se a largura do olho já está em função da largura do parente, se eu conseguir fazer a **altura do olho em função da largura do olho**, dá pra resolver o problema!\n\nVocê, querida pessoa que está lendo este post, sabe como é calculado um `padding` relativo (percentual)? Se você respondeu \"em função da largura do parente\", você acertou! Um `padding-top` de 50%, por exemplo, vai adicionar um espaçamento interno no topo do elemento do tamanho de **metade da largura do parente**. Isso me ajuda! Dá para criar um elemento **dentro do olho** e colocar o `padding-top` dele como 100%. Assim, eu vou ter um elemento filho do olho, sem conteúdo mas com padding, que vai resultar numa altura igual a 100% da largura do olho.\n\nParece complicado? **É porque é mesmo.** Isso seria facilmente resolvido se CSS tivesse uma propriedade como `aspect-ratio: 1:1` por exemplo. Mas enfim, isso funciona. Se você procurar no HTML, não vai encontrar um elemento dentro de `.eye`. Neste caso, eu usei um **pseudoelemento** via CSS, o `::before`. Ele representa um elemento dentro do olho, que vem antes do conteúdo filho do olho (que não existe, nesse caso). Para um pseudoelemento existir, ele precisa ter um valor no `content`, nem que seja a string vazia (`''`).\n\nPara o efeito de fechar o olho, vamos animar o `padding` do pseudoelemento também. Por isso, já deixei pronto um `transition`. Quando os olhos estiverem fechados, vamos adicionar a classe `.closed` no container dos olhos (para não ter que adicionar uma vez em cada olho). Assim, quando os olhos estiverem dentro de um `.eyes.closed`, seus pseudoelementos `::before` vão ter o padding fixo em `2px`. Resolvi usar um valor absoluto neste padding, para deixar o olho quase sumindo não importa o tamanho do personagem.\n\nEnfim, vem outra parte um pouco mais complicada que é **animar a pupila**. Para criar a pupila, eu usei outro pseudoelemento, o `::after`. Ele tem a mesma lógica do primeiro, mas vem depois do conteúdo do olho (que não existe), e depois do `::before` por consequência. Para animar sua posição, resolvi deixá-lo com `position: absolute`. Para que a posição seja em relação ao olho que contem a pupila, o olho tem `position: relative`.\n\nQuerendo facilitar minha vida, para não ter que levar em conta o tamanho da pupila na hora de animar sua posição, usei o `transform: translateX(-50%)` para deslocar a pupila para a esquerda em metade da sua largura. Isso não afeta a posição do elemento, apenas onde ele vai ser desenhado. Com isso, a posição `left` do elemento aponta para o centro da pupila, e não mais para o canto. Um `left` de 0% deixa a pupila metade dentro, metade fora do lado esquerdo do olho, e um `left` de 100% faz o mesmo só que na direita do olho. Para a pupila não aparecer fora do olho, ele tem `overflow: hidden`.\n\nComo a pupila vai ser animada tanto no `left`, como no `height` (para ela fechar junto com o olho), coloquei `transition: all` para facilitar minha vida, mas poderia ter escrito para as duas propriedades.\n\n## Destrinchando o JavaScript\n\nPara esse exemplo, usamos apenas JavaScript nativo do navegador, sem dependências ou bibliotecas, manipulando elementos do DOM diretamente. Refazer essa lógica com um Virtual DOM, como o do React, deixaria o código mais funcional (podendo criar um componente personagem sem estado), e quem sabe eu refaça uma versão desse exemplo com React.\n\nTemos dois comportamentos que queremos controlar: o movimento da pupila conforme o usuário digita e o abrir/fechar dos olhos quando o campo de senha é utilizado.\n\nComeçando pelos abrir e fechar dos olhos, que é mais simples: quando o `input` de senha recebe o foco (ou seja, é selecionado para digitação, e recebe o evento de `focus`), adicionamos a classe `.closed` no container dos olhos (`.eyes`). Isso vai mudar o `padding-top` do pseudoelemento `::before` de cada olho para 2px, que vai ser animado por conta da `transition`. Quando o usuário sair desse campo e ele perder o foco (o evento de `blur`), nós retiramos a classe. Simples assim.\n\nAgora, para movimentar as pupilas. Eu criei uma função que troca o `left` das pupilas através de uma **variável de CSS**, a `--eye-ball-offset`. Eu não precisava usar uma variável de CSS para isso, mas facilita para mudar o posicionamento nos dois olhos ao mesmo tempo. Mudar a variável em um elemento altera o valor para todos os descendentes deste elemento, por isso coloquei a variável no container dos olhos (`.eyes`).\n\nEssa função, se receber um parâmetro e ele for um número, vai interpretá-lo como um número percentual (0-100) e trocar o valor da variável por esse valor (com um `%` no fim). Essa versão com o argumento eu uso quando o usuário sai do campo de username (evento de `blur`), para centralizar as pupilas em 50% novamente.\n\nJá nos eventos de `focus` e `keyup` (quando uma tecla termina de ser pressionada dentro do campo), eu chamo a função acima sem argumentos. Nesse caso, ela vai pegar o campo de usuário e calcular quanto texto já foi entrado. Note que há uma leve \"trapaça\" para não termos que saber realmente onde o cursor do usuário está: o campo de texto tem um limite de caracteres. No caso do exemplo, no HTML, o limite está em 20. Assim, na função, nós pegamos o número de caracteres que o usuário digitou e dividimos por esse limite. O resultado é um número de 0 a 1, que nós multiplicamos por 100 e limitamos para que fique sempre entre 10 e 90 (valores arbitrários que achei que ficou visualmente agradável para limitar o movimento das pupilas).\n\nIsso tem algumas consequências: se o campo de texto for muito pequeno, a pupila vai continuar correndo quando o usuário chegar na borda da direita do campo e continuar digitando. Se o nome de usuário for feito por caracteres muito finos (como \"iiiiiiiii\"), a pupila vai se mover mais rápido que o cursor do campo de texto. Esses problemas podem ser mitigados usando uma fonte monoespaçada e garantindo que na largura vai caber o número de caracteres do limite do campo de texto, mas não me preocupei muito com isso pois, no caso medio, o efeito funciona bem o suficiente.\n\n**É isso que tem pra hoje!** Eu gostei do resultado, ficou um bonequinho razoavelmente agradável com pouco código. Dá para fazer muito mais com mais paciência (e noções de estética). Uma inspiração que eu tenho nessa linha é [Talita Oliveira](https://talitaoliveira.netlify.app/desenhando-nintendo-swicth/), que faz altos desenhos interessantes com CSS! Fica a recomendação de dar uma olhada e se inspirar também.\n","readingTime":10,"summary":"CSS é uma parada poderosa. Apesar de, originalmente, servir para suportar o HTML e definir estilos para itens em um documento, a comunidade de desenvolvimento front-end mostrou que dá para fazer muito mais que isso e cria verdadeiras experiências com CSS, substituindo ferramentas de animação e imagens por linhas de código de folha de estilos. Juntando isso com o dinamismo de JavaScript, dá para criar interações bem legais diretamente na web, muitas vezes sem assets extra além do próprio código.\n\nEsse post é um experimento para criar algo que não é novo, mas que é divertido e mostra algumas das capacidades de criar animações interativas com CSS e JS. Minha ideia é tentar fazer uma animação para acompanhar um formulário de login sem usar imagens ou outros recursos além de HTML, CSS e JS. **Eu não sou um artista então não espere uma obra de arte.** A ideia é, com pouco código, fazer um efeito que fique legal.\n\n"}},"path":"animando-um-personagem-com-css-e-javascript"}
