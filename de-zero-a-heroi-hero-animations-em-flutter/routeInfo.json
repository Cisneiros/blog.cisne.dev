{"template":"__react_static_root__/src/containers/post","sharedHashesByProp":{},"data":{"postData":{"title":"De zero a heroi: Hero animations em Flutter","date":"2020-08-31T00:00:00-03:00","slug":"de-zero-a-heroi-hero-animations-em-flutter","tags":["flutter","mobile"],"filePath":"2020-08-31-de-zero-a-heroi-hero-animations-em-flutter.md","content":"Animações são uma excelente maneira de tornar um app mais interativo e engajar os usuários. Flutter tem várias opções para criar animações, com diferentes níveis de complexididade. Uma das (se não a) mais simples são as **Hero animations**, que, com apenas um widget, permitem animar um componente durante a transição entre duas telas. Vamos ver como fazer uma animação super rápida e explorar possibilidades mais avançadas para criar animações mais complexas com essa ferramenta.\n\n<!-- summary-break -->\n\nAntes de começar, alguns exemplos de animações que vamos implementar neste post:\n\n:::flex\n\n:::phone-mockup\n![Vídeo mostrando uma imagem do Pokémon Charizard e um botão para avançar para a próxima tela. Ao tocar no botão, uma transição avança para a segunda tela, mas o Charizard voa de uma tela par a outra, terminando no meio da segunda tela. Ao puxar com o dedo para voltar para a tela anterior, o Charizard acompanha a transição. #autoplay#loop](/media/hero-3.mp4)\n:::/phone-mockup\n\n:::phone-mockup\n![Vídeo mostrando uma lista de Pokémon, com número, imagem e nome. Ao tocar no Charizard, uma nova tela de detalhes deste Pokémon aparece a imagem e o número dele voam da lista para essa nova tela. O mesmo acontece ao voltar para a lista e selecionar outro Pokémon, o Blastoise. #autoplay#loop](/media/hero-4.mp4)\n:::/phone-mockup\n\n:::phone-mockup\n![Vídeo mostrando uma tela com detalhes de uma compra de uma almofada do Pokémon Pikachu, com nome do produto, imagem, preço e data de entrega. Abaixo há um botão vermelho para finalizar a compra. Ao tocar nele, o botão fica cinza e o texto vira um indicador de carregamento. Após um tempo, o botão fica verde e um ícone de sucesso aparece nele. Em seguida, o botão começa a crescer até tomar a tela inteira, que fica toda verde. Aparece os textos da tela de sucesso da compra e um botão que, ao ser tocado, fecha e volta para o início do app. #autoplay#loop](/media/hero-5.mp4)\n:::/phone-mockup\n\n:::/flex\n\nTudo começa com o widget `Hero`. Ele serve para identificar, nas telas de origem e destino da transição, **qual é o widget que vai ser animado**. Ele recebe um atributo `child` que é o widget e um outro `tag`, que deve ser igual nas duas telas (isso permite ter mais de uma Hero animation ao mesmo tempo).\n\n```dart\nHero(\n  tag: 'charizard',\n  child: Image.network('https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/6.png'),\n)\n```\n\n## Animando um widget durante uma transição de telas\n\nNo exemplo acima, envolvemos um widget `Image` com um `Hero`. Agora, só precisamos colocar este `Hero` em duas telas e criar uma transição entre elas.\n\n:::phone-mockup\n![Vídeo mostrando uma imagem do Pokémon Charizard e um botão para avançar para a próxima tela. Ao tocar no botão, uma transição avança para a segunda tela, mas o Charizard voa de uma tela par a outra, terminando no meio da segunda tela. #autoplay#loop](/media/hero-1.mp4)\n:::/phone-mockup\n\n```dart\nclass FirstScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('First screen'),\n      ),\n      body: Column(\n        children: [\n          // O Hero na primeira tela\n          Hero(\n            tag: 'charizard',\n            child: Image.network(\n                'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/6.png'),\n          ),\n          RaisedButton(\n            child: Text('Go to next screen'),\n            onPressed: () {\n              Navigator.of(context).push(\n                MaterialPageRoute(builder: (_) => SecondScreen()),\n              );\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass SecondScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Second screen'),\n      ),\n      body: Center(\n        // O mesmo Hero na segunda tela\n        child: Hero(\n          tag: 'charizard',\n          child: Image.network(\n              'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/6.png'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nE é isso! Com apenas um widget em cada tela, temos essa animação na transição. Ela funciona tanto na ida como na volta e já dá um efeito legal.\n\nEm algumas plataformas, como no iOS, é costumeiro o usuário poder voltar para a tela anterior deslizando o dedo do canto da tela. Por padrão, Hero animations **não vão animar nesse tipo de transção**. Se você quiser que anime, é só adicionar o atributo `transitionOnUserGestures` nos dois `Hero`s, assim:\n\n```dart\nHero(\n  tag: 'charizard',\n  transitionOnUserGestures: true, // O novo atributo\n  child: Image.network('https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/6.png'),\n)\n```\n\nNos vídeos abaixo, temos um exemplo de usuário arrastando a tela para voltar sem e com `transitionOnUserGestures`, respectivamente.\n\n:::flex\n\n:::phone-mockup\n![Vídeo mostrando uma imagem do Pokémon Charizard e um botão para avançar para a próxima tela. Ao tocar no botão, uma transição avança para a segunda tela, mas o Charizard voa de uma tela par a outra, terminando no meio da segunda tela. Ao puxar com o dedo para voltar para a tela anterior, o Charizard não acompanha a transição, aparecendo separadamente nas duas telas. #autoplay#loop](/media/hero-2.mp4)\n:::/phone-mockup\n\n:::phone-mockup\n![Vídeo mostrando uma imagem do Pokémon Charizard e um botão para avançar para a próxima tela. Ao tocar no botão, uma transição avança para a segunda tela, mas o Charizard voa de uma tela par a outra, terminando no meio da segunda tela. Ao puxar com o dedo para voltar para a tela anterior, o Charizard acompanha a transição. #autoplay#loop](/media/hero-3.mp4)\n:::/phone-mockup\n\n:::/flex\n\nComo eu comentei antes, é possível ter mais de um `Hero` na mesma tela. E não necessariamente você precisa ter um correspondente nas duas telas, pois se uma transição encontrar um `Hero` de um lado só, ela não vai animar o elemento mas nenhum erro acontecerá. Podemos usar isso para fazer uma animação dos elementos de uma lista para uma tela de detalhes.\n\n:::phone-mockup\n![Vídeo mostrando uma lista de Pokémon, com número, imagem e nome. Ao tocar no Charizard, uma nova tela de detalhes deste Pokémon aparece a imagem e o número dele voam da lista para essa nova tela. O mesmo acontece ao voltar para a lista e selecionar outro Pokémon, o Blastoise. #autoplay#loop](/media/hero-4.mp4)\n:::/phone-mockup\n\nPara isso, precisamos apenas garantir que a `tag` vai ser **única entre os elementos** e que conseguimos **replicá-la na segunda tela**. Neste exemplo, vamos partir de uma classe `Pokemon` que tem um atributo `number`, único entre cada espécie de Pokémon. Para montar a lista, usei um `SliverGrid` que serve para montar uma lista em formato de Grid dentro de um `CustomScrollView`. Como Slivers funcionam é assunto pra outra conversa, mas o que é relevante é que ele recebe uma classe com um builder que, para cada item da lista, vai renderizar um widget.\n\n```dart\nSliverChildBuilderDelegate((context, index) {\n  final pokemon = pokedex.pokemonNumbered(index + 1);\n\n  return GestureDetector(\n    onTap: () => toPokemonDetail(pokemon),\n    child: Hero(\n      tag: 'sprite-${pokemon.number}',\n      transitionOnUserGestures: true,\n      child: Image.network(pokemon.spriteUrl),\n    ),\n  );\n})\n```\n\nNa `tag`, vamos gerar uma string usando o número do Pokémon. Na tela de detalhe, só precisamos repetir a mesma `tag` e a Hero animation vai funcionar. Como a tela de detalhe recebe como parâmetro o Pokémon para exibir, ela tem o número dele e pode criar um `Hero` com a mesma `tag`. Todos os outros `Hero`s na lista não vão ter um correspondente na tela de detalhe, então eles não serão animados.\n\nNo vídeo do exemplo, eu coloquei um segundo `Hero` para animar o número do Pokémon, também. É a mesma ideia, mas ao invés do `child` ser uma imagem, é um texto. A `tag` precisa ser diferente, e por isso eu coloquei o prefixo \"sprite\" na `tag` do primeiro exemplo. Para o número, você pode usar `'number-${pokemon.number}'`.\n\nNote que o estado inicial e final não precisam ter o mesmo tamanho. O `Hero` vai interpolar as dimensões automaticamente. Na maioria dos casos, isso é suficiente, mas existem maneiras de modificar o funcionamento das transições. Isso é particulamente interessante quando usamos uma Hero animation em que o estado inicial e final não são o mesmo widget, e eles podem ter filhos com layouts diferentes e que, se apenas interpolarmos as dimensões, podemos ter comportamentos estranhos.\n\n## Redefinindo o comportamento de transição\n\nVamos dar uma olhada num uso mais avançado do `Hero`. Nos exemplos anteriores, nós apenas definimos o estado final e inicial. Nosso objetivo vai ser implementar uma animação assim:\n\n:::phone-mockup\n![Vídeo mostrando uma tela com detalhes de uma compra de uma almofada do Pokémon Pikachu, com nome do produto, imagem, preço e data de entrega. Abaixo há um botão vermelho para finalizar a compra. Ao tocar nele, o botão fica cinza e o texto vira um indicador de carregamento. Após um tempo, o botão fica verde e um ícone de sucesso aparece nele. Em seguida, o botão começa a crescer até tomar a tela inteira, que fica toda verde. Aparece os textos da tela de sucesso da compra e um botão que, ao ser tocado, fecha e volta para o início do app. #autoplay#loop](/media/hero-5.mp4)\n:::/phone-mockup\n\nComo o código-fonte desse exemplo é um pouco maior, vou explicar alguns dos novos conceitos primeiro e depois colocar o código completo do exemplo.\n\nSeparando em partes, o que acontece no exemplo é:\n\n1. Ao clicar no botão, ele diminui e mostra um indicador de carregamento.\n2. Após um tempo, ele fica verde e mostra um ícone de sucesso.\n3. O botão expande e toma a tela inteira, deixando-a verde.\n4. Uma mensagem de sucesso aparece na tela verde.\n5. Ao tocar no botão que apareceu agora, a tela fecha.\n\nPara simular uma transação, a tela é um `StatefulWidget` que tem um atributo para guardar o seu estado. Ele pode ter o valor `waiting` (inicial), `processing` e `successful`. Não há nenhuma comunicação real acontecendo, e a mudança entre estados acontece usando `await` em timers, quando o botão é clicado.\n\n```dart\nRawMaterialButton(\n  onPressed: () async {\n    if (purchaseState != PurchaseState.waiting) return;\n\n    setState(() {\n      purchaseState = PurchaseState.processing;\n    });\n\n    await Future.delayed(Duration(seconds: 2));\n\n    setState(() {\n      purchaseState = PurchaseState.successful;\n    });\n\n    await Future.delayed(Duration(milliseconds: 500));\n\n    await Navigator.of(context)\n        .pushReplacement(MaterialPageRoute(\n      builder: (_) => SuccessScreen(),\n      fullscreenDialog: true,\n    ));\n  },\n  fillColor: _buttonColor,\n  shape: _buttonShape,\n  child: SizedBox(\n    height: 50,\n    child: Center(child: _buttonChild),\n  ),\n)\n```\n\nAs propriedades `_buttonColor`, `_buttonShape` e `_buttonChild` são _getters_ adicionados no widget que fazem um `switch/case` no estado e retornam a cor de fundo, formato e conteúdo do botão, respectivamente.\n\nOs ítens 1 e 2 da lista são presentes do `RawMaterialButton`, uma classe base para criar botões no Material Design. O botão mudar de um formato de pílula para um círculo acontece pois mudamos o seu atributo `Shape`. O `RawMaterialButton` anima essa mudança de formato automaticamente.\n\nO item 3, a expansão do botão até tomar a tela toda, que é o nosso foco. Ele é uma Hero animation. Pode não parecer óbvio pois, ao clicar, não vemos uma nova tela abrindo e um widget voando da tela antiga para a nova. O segredo é que o widget de destino é **a tela nova inteira**. Na tela de origem, o `Hero` está em volta do botão. Já na tela de destino, o `Hero` está em volta da tela toda. Isso faz com que o botão se transforme na tela seguinte inteira.\n\nSe você olhar no código-fonte do exemplo, que está todo na próxima seção, vai notar que o `Hero` da tela de destino é um pouco diferente dos que fizemos até agora (além do fato de ele englobar uma tela inteira). Ele tem dois atributos que não usamos ainda: `flightShuttleBuilder` e `createRectTween`. Precisamos desses dois atributos para deixar o efeito com a cara que ficou.\n\nComeçando pelo `flightShuttleBuilder`, ele serve para definir **como renderizar o widget durante a transição**. Por padrão, o próprio widget é usado na transição (nos exemplos dos Pokémon, nós vemos a sprite ele se mover de uma tela para a outra). Porém, neste caso, o botão começa bem pequeno e cresce até ocupar a tela toda. Porém, o widget da tela em si possui textos e outros elementos grandes, que dependem do espaço disponível para que seu layout seja calculado. Durante a transição (e expansão), esse espaço vai ser insuficiente e vamos ter problemas de overflow.\n\nHá mais de uma maneira de resolver isso, mas eu parti para uma bem simples: durante a transição, vamos renderizar o widget apenas como um círculo verde expandindo. Ele já vai começar como um círculo verde, no sucesso da compra, e vai expandir com um raio que, garantidamente, vai preencher a tela inteira.\n\n```dart\nHero(\n  // ...\n  flightShuttleBuilder: (flightContext, animation, flightDirection,\n      fromHeroContext, toHeroContext) {\n    return Container(\n      decoration: BoxDecoration(\n        color: Colors.green,\n        shape: BoxShape.circle,\n      ),\n    );\n  },\n)\n```\n\nO `flightShuttleBuilder` recebe cinco parâmetros, que deixei explícitos no exemplo acima para ilustrar suas existências. Não precisamos deles pois vamos renderizar, em todos os quadros da animação, o mesmo círculo verde. Mas temos acesso ao contexto das telas originais e finais, da transição, a direção dessa transição e, talvez mais interessante, a `animation` em si. Ela pode ser usada para modificar o widget durante a transição de acordo com o progresso da animação (que estará em `animation.value`, de zero a um).\n\nEu comentei acima sobre **garantir que o raio do círculo vai cubrir a tela inteira**. O `flightShuttleBuilder` acima não tem nada sobre isso. Para isso vamos usar a outra nova propriedade: `createRectTween`. Ela serve para definir a área e a posição ocupadas pelo widget durante a transição. Quando não definimos essa propriedade, por padrão a Hero animation vai desenhar o widget num retângulo onde o `Hero` estava na primeira tela e interpolar até o retângulo em que o `Hero` está na segunda tela. Ou seja, o widget original aparenta se mover e mudar de tamanho para se transformar nas dimensões da tela de destino.\n\nPara a animação que queria fazer, meu objetivo era que o círculo expandisse **sem sair do lugar**, ou seja, **sem mudar seu centro**. Para isso, precisava que o retângulo de origem e destino tivessem o mesmo centro, e que o retângulo de destino crescesse o suficiente para que o círculo do nosso `flightShuttleBuilder` cobrisse a tela inteira. Flutter já tem maneiras de interpolar dois retângulos (com `Rect.lerp()`), então eu preciso apenas definir quais são os retângulos inicial e final.\n\nO retângulo inicial é o próprio botão. Ele convenientemente já é um quadrado que tem um círculo verde dentro (o botão). Já o retângulo final precisa **conter um círculo que contenha a tela inteira**. Isso é meio confuso, mas a ideia é que o raio do círculo precisa ser a **distância entre o centro do círculo e o canto da tela mais longe dele**. É isso que vamos calcular no construtor da classe `HeroTween`, abaixo. Fazemos isso no construtor pois os retângulos inicial e final não mudam durante a animação.\n\n```dart\nHero(\n  // ...\n  createRectTween: (begin, end) {\n    return HeroTween(begin: begin, end: end);\n  },\n)\n\n// ...\n\nclass HeroTween extends RectTween {\n  HeroTween({Rect begin, Rect end})\n      : radius = sqrt([\n          end.topLeft,\n          end.topRight,\n          end.bottomLeft,\n          end.bottomRight\n        ]\n            .map((p) => begin.center - p)\n            .map((o) => o.distanceSquared)\n            .reduce(max)),\n        super(begin: begin, end: end);\n\n  final double radius;\n\n  @override\n  Rect lerp(double t) {\n    return Rect.lerp(\n        begin, Rect.fromCircle(center: begin.center, radius: radius), t);\n  }\n}\n```\n\nAo criar a classe `HeroTween`, que estende `RectTween`, passamos um `begin` e um `end`. Essas propriedades são os retângulos (`Rect`s) ocupados pelo widget na tela de origem e de destino da animação. Assim, vamos interpolar entre o retângulo original (`begin`) e um retângulo que contenha um círculo cujo centro é o centro do original (`begin.center`) e o raio é a distância que calculamos no construtor.\n\nA inicialização no construtor pode não parecer clara. O que ela está fazendo é calcular, para cada vértice do retângulo final (`end`), a diferênça entre o vértice e o centro do retângulo inicial (`begin`). O resultado dessa diferença é um `Offset`. A classe `Offset` já tem um _getter_ que retorna a distância, `.distance`, porém ela também tem um `.distanceSquared` que é mais eficiente. Como não sabemos qual distância vamos usar, podemos usar a `.distanceSquared` para comparar e encontrar a maior primeiro, e só tirar a raiz quadrada da que realmente vamos usar, a maior.\n\nAo final da transição, a animação vai parar de renderizar nosso `flightShuttleBuilder` e desenhar o `child` do `Hero` de destino, que é a tela de sucesso. Ela já tem o fundo verde, o que ajuda na ilusão e cumpre o item 4 da lista acima. Como a transição entre as telas é feita usando o método `pushReplacement` do `Navigator`, a tela anterior não é mais acessível e, ao fazer um `pop`, não voltamos para a tela com o botão animado, mas sim para onde estávamos antes de tudo isso (cuprindo o item 5). Por essa razão, **não temos que nos preocupar com o funcionamento da animação no sentido contrário** e, por isso, não definimos esses atributos adicionais no `Hero` da tela de origem.\n\n**Ufa!** Se você chegou até aqui, dá uma respirada. Vimos bastante coisa de uma vez! Hero animations podem ser bem simples de usar, mas possuem mecanismos extra para quando queremos ir além do básico e criar animações para interações mais específicas e personalizadas. Dá uma olhada no código abaixo, ele é o código completo das duas telas da animação desse exemplo. Boa parte dele é referente à UI das duas telas, mas deixei uns comentários marcando as partes mais relevantes da nossa animação.\n\n### Código-fonte do exemplo\n\n```dart\nclass PurchaseScreen extends StatefulWidget {\n  @override\n  _PurchaseScreenState createState() => _PurchaseScreenState();\n}\n\nenum PurchaseState { waiting, processing, successful }\n\nclass _PurchaseScreenState extends State<PurchaseScreen>\n    with TickerProviderStateMixin {\n  // Para controlar o estado do botão\n  PurchaseState purchaseState = PurchaseState.waiting;\n\n  @override\n  Widget build(BuildContext context) {\n    final theme = Theme.of(context);\n    final headlineStyle = theme.textTheme.headline4;\n    final labelStyle = theme.textTheme.subtitle1;\n    final valueStyle = labelStyle.copyWith(fontWeight: FontWeight.w500);\n\n    return Scaffold(\n      appBar: AppBar(title: Text('Review your purchase')),\n      body: Padding(\n        padding: const EdgeInsets.all(8),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          crossAxisAlignment: CrossAxisAlignment.center,\n          children: [\n            Text(\n              'Pikachu pillow',\n              style: headlineStyle,\n              textAlign: TextAlign.center,\n            ),\n            Image.network(\n              'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png',\n              width: 250,\n              fit: BoxFit.contain,\n              filterQuality: FilterQuality.none,\n            ),\n            Column(\n              children: [\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                  children: [\n                    Text('Delivery estimate', style: labelStyle),\n                    Text('4 business days', style: valueStyle)\n                  ],\n                ),\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                  children: [\n                    Text('Price', style: labelStyle),\n                    Text('\\$ 30', style: valueStyle)\n                  ],\n                ),\n              ],\n            ),\n            // O Hero da tela inicial, em volta do botão, sem propriedades além da tag e child\n            Hero(\n              tag: 'order-success',\n              child: RawMaterialButton(\n                onPressed: () async {\n                  if (purchaseState != PurchaseState.waiting) return;\n\n                  setState(() {\n                    purchaseState = PurchaseState.processing;\n                  });\n\n                  // Simulando uma transação real com await em Future.delayed\n                  await Future.delayed(Duration(seconds: 2));\n\n                  setState(() {\n                    purchaseState = PurchaseState.successful;\n                  });\n\n                  await Future.delayed(Duration(milliseconds: 500));\n\n                  // pushReplacement para não ser possível voltar para essa tela\n                  Navigator.of(context).pushReplacement(MaterialPageRoute(\n                    builder: (_) => SuccessScreen(),\n                    fullscreenDialog: true,\n                  ));\n                },\n                // Os atributos iniciados em _ são getters definidos logo abaixo do build\n                fillColor: _buttonColor,\n                shape: _buttonShape,\n                child: SizedBox(\n                  height: 50,\n                  child: Center(child: _buttonChild),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget get _buttonChild {\n    final theme = Theme.of(context);\n    final themeContrastColor = theme.primaryTextTheme.headline6.color;\n\n    switch (purchaseState) {\n      case PurchaseState.processing:\n        return CircularProgressIndicator();\n\n      case PurchaseState.successful:\n        return Icon(Icons.check, color: Colors.white);\n\n      case PurchaseState.waiting:\n      default:\n        return Text(\n          'PLACE ORDER',\n          style: TextStyle(\n            color: themeContrastColor,\n            fontWeight: FontWeight.w500,\n            fontSize: 24,\n          ),\n        );\n    }\n  }\n\n  Color get _buttonColor {\n    switch (purchaseState) {\n      case PurchaseState.processing:\n        return Colors.grey[200];\n\n      case PurchaseState.successful:\n        return Colors.green;\n\n      case PurchaseState.waiting:\n      default:\n        return Theme.of(context).primaryColor;\n    }\n  }\n\n  // A mudança do shape é animada pelo RawMaterialButton automaticamente\n  ShapeBorder get _buttonShape {\n    switch (purchaseState) {\n      case PurchaseState.processing:\n      case PurchaseState.successful:\n        return CircleBorder();\n\n      case PurchaseState.waiting:\n      default:\n        return RoundedRectangleBorder(borderRadius: BorderRadius.circular(25));\n    }\n  }\n}\n```\n\n```dart\nclass SuccessScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // O Hero aqui engloba a tela inteira e tem propriedades adicionais\n    return Hero(\n      tag: 'order-success',\n      // Definindo como o widget vai aparecer durante a animação\n      flightShuttleBuilder: (flightContext, animation, flightDirection,\n          fromHeroContext, toHeroContext) {\n        return Container(\n          decoration: BoxDecoration(\n            color: Colors.green,\n            shape: BoxShape.circle,\n          ),\n        );\n      },\n      // Definindo o tamanho do widget durante a animação (a classe é criada abaixo desta)\n      createRectTween: (begin, end) {\n        return HeroTween(begin: begin, end: end);\n      },\n      child: Scaffold(\n        backgroundColor: Colors.green,\n        body: Padding(\n          padding: const EdgeInsets.all(8),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n            crossAxisAlignment: CrossAxisAlignment.center,\n            children: [\n              Icon(\n                Icons.shopping_basket,\n                color: Colors.white,\n                size: 200,\n              ),\n              Text(\n                'Your order is on its way!',\n                textAlign: TextAlign.center,\n                style: TextStyle(\n                  color: Colors.white,\n                  fontSize: 40,\n                ),\n              ),\n              RaisedButton(\n                onPressed: () {\n                  Navigator.of(context).pop();\n                },\n                child: Text('Got it'),\n              )\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// A classe usada pelo createRectTween\nclass HeroTween extends RectTween {\n  // Calculando o raio no construtor\n  HeroTween({Rect begin, Rect end})\n      : radius = sqrt([\n          end.topLeft,\n          end.topRight,\n          end.bottomLeft,\n          end.bottomRight\n        ]\n            .map((p) => begin.center - p)\n            .map((o) => o.distanceSquared)\n            .reduce(max)),\n        super(begin: begin, end: end);\n\n  final double radius;\n\n  @override\n  Rect lerp(double t) {\n    return Rect.lerp(\n        begin, Rect.fromCircle(center: begin.center, radius: radius), t);\n  }\n}\n```\n","readingTime":17,"summary":"Animações são uma excelente maneira de tornar um app mais interativo e engajar os usuários. Flutter tem várias opções para criar animações, com diferentes níveis de complexididade. Uma das (se não a) mais simples são as **Hero animations**, que, com apenas um widget, permitem animar um componente durante a transição entre duas telas. Vamos ver como fazer uma animação super rápida e explorar possibilidades mais avançadas para criar animações mais complexas com essa ferramenta.\n\n"}},"path":"de-zero-a-heroi-hero-animations-em-flutter"}
