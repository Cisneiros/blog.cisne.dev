{"template":"__react_static_root__/src/containers/post","sharedHashesByProp":{},"data":{"postData":{"title":"Recurs√£o de cauda ‚Äî ou como n√£o estourar a pilha","date":"2020-11-13T00:00:00-03:00","slug":"recursao-de-causa-ou-como-nao-estourar-a-pilha","tags":["conceitos"],"filePath":"2020-11-13-recursao-de-causa-ou-como-nao-estourar-a-pilha.md","content":"Quando precisamos realizar uma opera√ß√£o v√°rias vezes, geralmente existem duas maneiras: iterativa e recursiva. Iterativa √© quando utilizamos alguma estrutura de la√ßo, como um `for` ou `while`, com uma vari√°vel de controle para saber quando parar. Recursiva √© quando uma fun√ß√£o decide **executar a si mesma** por entender que ainda precisa continuar processando. Toda itera√ß√£o pode ser escrita como uma recurs√£o e vice-versa. Recurs√µes por√©m tem um risco associado: o **estouro da pilha**. Vamos entender o que isso significa e como escrever c√≥digo recursivo evitando esse problema!\n\n<!-- summary-break -->\n\n## O que √© essa pilha?\n\nAntes de mais nada, o que √© **a pilha**? Neste contexto, n√£o estamos falando de uma bateria üîã, mas de uma estrutura de dados em que podemos **empilhar** informa√ß√£o ü•û. Sempre que executamos uma fun√ß√£o, n√≥s estamos movendo a execu√ß√£o do c√≥digo de um ponto para o outro. Quando a fun√ß√£o que chamamos termina, precisamos voltar para onde est√°vamos com o resultado e continuar a execu√ß√£o. Por isso, quando chamamos uma fun√ß√£o, o ambiente de execu√ß√£o vai guardar **o estado atual de execu√ß√£o** em algum lugar para que possamos retornar para ele depois. Diferentes linguagens de programa√ß√£o v√£o ter diferentes ambientes de execu√ß√£o, mas o conceito √© parecido entre elas.\n\nCada chamada de fun√ß√£o adiciona esse contexto numa pilha (em ingl√™s, _stack_). Usa-se uma pilha pois, se n√≥s executamos a fun√ß√£o A, que chama a fun√ß√£o B, que chama C (nessa ordem), ao final de C n√≥s queremos retornar para B e, ao final de B, n√≥s queremos retornar para A. Assim, vamos empilhando as chamadas aninhadas (chamadas dentro de chamadas) e desempilhando nos retornos. Cada contexto desse adicionado na pilha √© chamado de **quadro** (_stack frame_) e ocupa **espa√ßo em mem√≥ria**.\n\nMem√≥ria n√£o √© infinita, e cada ambiente de execu√ß√£o de c√≥digo vai definir um limite para o qu√£o profunda uma pilha de chamadas de fun√ß√£o pode ser. Se esse tamanho for, por exemplo, 1000, significa que voc√™ pode ter no m√°ximo 1000 n√≠veis de fun√ß√µes chamando umas as outras sem retornar, de acordo com o que a fun√ß√£o precisar guardar na pilha. Se voc√™ tentar chamar mais uma fun√ß√£o aninhada, voc√™ vai ter um **estouro da pilha**, de onde vem o nome do _Stack Overflow_.\n\n## O que isso tem a ver com recurs√£o?\n\n√â dif√≠cil imaginar escrever 1000 fun√ß√µes de maneira que uma chame a outra, consequentemente ultrapassando esse limite. Afinal de contas, voc√™ vai ter o limite da pr√≥pria quantidade de c√≥digo que voc√™ escreve. Por√©m, existe algo bem mais r√°pido e capaz do que n√≥s, humanos: **computadores**. E a√≠ que entra recurs√£o.\n\nImagine o seguinte cen√°rio, em JavaScript. Note que estou colocando um `n` ao final dos n√∫meros. Essa √© a sintaxe para `BigInt` em JS, que s√£o n√∫meros arbitrariamente grandes. O exemplo a seguir faz conta com n√∫mero muito grandes e, se usarmos n√∫meros padr√µes de JavaScript, chegar√≠amos em `Infinity` eventualmente.\n\n```js\nfunction factorial(number) {\n  if (number === 0n) {\n    return 1n\n  } else {\n    return number * factorial(number - 1n)\n  }\n}\n```\n\nTemos uma fun√ß√£o recursiva que calcula o **fatorial de um n√∫mero** (o produto de todos os n√∫meros entre 1 e este n√∫mero). Ela √© recursiva pois tem um **caso base** (se `number` for igual a zero) em que ela apenas retorna algo e um **caso recursivo** (se `number` n√£o for igual a zero), em que ela faz algo e **chama a si mesma com outro argumento**.\n\n```js\nfactorial(10n) // Resultado: 3628800n\n```\n\nEssa fun√ß√£o vai precisar usar a pilha `number` vezes, pois cada execu√ß√£o dela precisa chamar uma fun√ß√£o (ela mesma) **antes de poder retornar**. Ou seja, quando eu chamo `factorial(10)`, essa fun√ß√£o retornar `10 * factorial(9)`. Mas ela n√£o consegue retornar ainda, pois tem uma chamada de fun√ß√£o n√£o resolvida. Ela precisa esperar `factorial(9)` retornar para **depois** poder multiplicar por 10, e assim retornar tamb√©m. Isso acontece sucessivamente at√© chegar em `factorial(0)`, que retorna apenas `1`. A partir da√≠, os contextos de execu√ß√£o das fun√ß√µes v√£o sendo **desempilhados**, passando pelo `factorial(1)` (que aguardava o resultado do `factorial(0)`), depois `factorial(2)`, e assim at√© voltar para o original, `factorial(10)`.\n\nSe a entrada dessa fun√ß√£o se tornar muito grande, vamos precisar fazer um n√∫mero de chamadas de fun√ß√£o, uma dentro da outra, que pode precisar guardar mais informa√ß√£o na pilha do que ela suporta, causando um estouro da pilha. Nos meus testes, rodando em Node.js, `factorial(10948n)` foi o ponto em que a pilha estouraria. Ao tentar executar essa fun√ß√£o, eu recebi a mensagem: **Uncaught RangeError: Maximum call stack size exceeded**.\n\nO motivo de precisarmos guardar informa√ß√£o na pilha de chamadas de fun√ß√£o √© que **essa fun√ß√£o precisa fazer algo com o resultado da chamada recursiva**. Mais especificamente, olhando para essa linha dentro do `else`:\n\n```js\n    return number * factorial(number - 1n)\n```\n\nA fun√ß√£o precisa que a chamada recursiva retorne **para depois** conseguir fazer a multiplica√ß√£o. Para visualizar, vamos diminuir a entrada para `5n`. A execu√ß√£o aconteceria, passo a passo, assim:\n\n```js\nfactorial(5n)\n5n * factorial(4n)\n5n * 4n * factorial(3n)\n5n * 4n * 3n * factorial(2n)\n5n * 4n * 3n * 2n * factorial(1n)\n5n * 4n * 3n * 2n * 1n * factorial(0n)\n5n * 4n * 3n * 2n * 1n * 1n // Chegamos no caso base\n5n * 4n * 3n * 2n * 1n\n5n * 4n * 3n * 2n\n5n * 4n * 6n\n5n * 24n\n120n\n```\n\n√â a√≠ que entra o conceito de **recurs√£o de cauda**, ou **otimiza√ß√£o de chamada de cauda** (_tail call optimization_).\n\n## Como fazer essa recurs√£o n√£o estourar?\n\nAlgumas linguagens de programa√ß√£o conseguem identificar chamadas de fun√ß√µes que **n√£o precisam guardar contexto na pilha**. Quando isso acontece, √© poss√≠vel ter uma recurs√£o que, independentemente da profundidade, n√£o vai causar um estouro da pilha.\n\n**Infelizmente, JavaScript n√£o √© uma delas.** As implementa√ß√µes atuais n√£o suportam esse tipo de otimiza√ß√£o. Para fins ilustrativos, vamos rever como seria o exemplo acima se JavaScript tivesse suporte a recurs√£o de cauda. Depois, vamos ver o mesmo exemplo em **linguagens que de fato suportam**.\n\nVamos re-escrever a fun√ß√£o do fatorial de maneira que **ela n√£o precise esperar pelo retorno da recurs√£o para retornar**. O segredo est√° em fazer com que, em todos os poss√≠veis caminhos para o c√≥digo, n√≥s retornemos apenas **valores** ou **a pr√≥pria chamada recursiva**.\n\n```js\nfunction factorial(number, product) {\n  if (number === 0n) {\n    return product\n  } else {\n    return factorial(number - 1n, product * number)\n  }\n}\n```\n\nA fun√ß√£o acima tem dois caminhos poss√≠veis de execu√ß√£o. O primeiro caminho, se `number` for zero, retorna apenas um valor (a vari√°vel `product`). O segundo, se `number` n√£o for zero, √© o que modificamos. Ao inv√©s de retornar o valor atual multiplicado pelo retorno da recurs√£o, n√≥s **calculamos a multiplica√ß√£o primeiro** e s√≥ depois fazemos a chamada recursiva.\n\nPara isso, introduzimos um segundo argumento a essa fun√ß√£o, o `product`. Ele funciona aqui como um **acumulador**, que guarda o resultado intermedi√°rio. Esse acumulador vai guardando cada multiplica√ß√£o e √© retornado no caso base, quando chegamos no fim da recurs√£o. Como n√≥s passamos esse resultado intermedi√°rio na chamada recursiva, nosso `return` **n√£o faz nada com o resultado da recurs√£o**, apenas retorna-o diretamente. O interpretador do JavaScript poderia perceber isso e **n√£o guardar nada na pilha**. \n\nVamos ver como ficaria a sequ√™ncia de execu√ß√£o dessa nova fun√ß√£o. Note que, como ela tem um acumulador (segundo par√¢metro), precisamos passar algum **valor inicial** para esse par√¢metro. Como √© uma multiplica√ß√£o, podemos passar `1n` (pois 1 n√£o afeta um produto).\n\n```js\nfactorial(5n, 1n)\nfactorial(4n, 5n)\nfactorial(3n, 20n)\nfactorial(2n, 60n)\nfactorial(1n, 120n)\nfactorial(0n, 120n)\n120n\n```\n\nSobre esse segundo argumento, idealmente n√£o gostar√≠amos que fosse necess√°rio pass√°-lo para come√ßar a calcular. Para isso, podemos separar a implementa√ß√£o da fun√ß√£o da API p√∫blica, assim:\n\n```js\nfunction factorialImplementation(number, product) {\n  if (number === 0n) {\n    return product\n  } else {\n    return factorialImplementation(number - 1n, product * number)\n  }\n}\n\n// A fun√ß√£o que exportamos publicamente apenas tem um argumento\nexport function factorial(number) {\n  return factorialImplementation(number, 1n)\n}\n```\n\nAssim, nossa fun√ß√£o `factorial` s√≥ recebe um argumento. Alternativamente, poder√≠amos colocar um valor padr√£o para o segundo argumento (mas isso permitiria chamar a fun√ß√£o passando um segundo argumento errado, ainda assim).\n\n## Exemplos em linguagens que suportam otimiza√ß√£o de chamadas de cauda\n\nComo eu comentei, **infelizmente JavaScript n√£o tem suporte** a n√£o adicionar contexto na pilha caso n√£o seja necess√°rio. Toda chamada de fun√ß√£o vai colocar algo na pilha e, eventualmente, uma recurs√£o causa um estouro.\n\nVamos rever o exemplo do fatorial em algumas linguagens que t√™m suporte a essa otimiza√ß√£o.\n\n### Clojure\n\n```clj\n(defn factorial\n  \"Implementa√ß√£o sem tail call optimization\"\n  [number]\n  (if (zero? number)\n    1\n    (* number (factorial (dec number)))))\n```\n\n```clj\n(defn factorial\n  \"Implementa√ß√£o com tail call optimization\"\n  [number product]\n  (if (zero? number)\n    product\n    (recur (dec number) (* product number))))\n```\n\nNote que, em Clojure, existe uma forma especial para recurs√£o de cauda: `recur`. Usamos `recur` no lugar do nome da fun√ß√£o, para executar uma chamada recursiva. Se voc√™ tentar usar `recur` num contexto que ele n√£o seja a √∫ltima execu√ß√£o de um caminho da execu√ß√£o de c√≥digo, vai receber um erro. Se voc√™ tentar escrever recurs√µes sempre com `recur`, voc√™ tem a garantia de fazer uma recurs√£o de cauda (pois o compilador n√£o vai deixar voc√™ n√£o o fazer).\n\n### Kotlin\n\n```kt\n// Implementa√ß√£o sem tail call optimization\nfun factorial(number: Long) : Long {\n    return if (number === 0) {\n        1\n    } else {\n        number * factorial(number - 1)\n    }\n}\n```\n\n```kt\n// Implementa√ß√£o com tail call optimization\ntailrec fun factorial(number: Long, product: Long) : Long {\n    return if (number === 0) {\n        product\n    } else {\n        factorial(number - 1, product * number)\n    }\n}\n```\n\nKotlin possui a palavra-chave `tailrec`. Se aplicada a uma fun√ß√£o, indica que a recurs√£o dessa fun√ß√£o √© de cauda. Se voc√™ aplicar esse modificador na primeira vers√£o, por exemplo, ter√° um erro, assim como o uso do `recur` em Clojure.\n\n### Haskell\n\n```haskell\n-- Implementa√ß√£o sem tail call optimization\nfactorial :: (Integral a) => a -> a\nfatorial 0 = 1\nfactorial n = n * factorial (n - 1)\n```\n\n```haskell\n-- Implementa√ß√£o com tail call optimization\nfactorial :: (Integral a) => a -> a -> a\nfatorial 0 p = p\nfactorial n p = factorial (n - 1) (p * n)\n```\n\n### Elixir\n\nRecentemente, eu escrevi um post sobre [casamento de padr√µes com Elixir](/casamento-de-padroes-em-elixir/). No final dele tem esse exemplo de fatorial usando casamento de padr√µes e recurs√£o de cauda. Ela tamb√©m deixa p√∫blica apenas a chamada da fun√ß√£o com um argumento, mantendo a vers√£o com o acumulador privada.\n\n```elixir\ndefmodule Math do\n  def factorial(number) do\n    factorial(number, 1)\n  end\n\n  defp factorial(0, current_product) do\n    current_product\n  end\n\n  defp factorial(number, current_product) do\n    factorial(number - 1, number * current_product)\n  end\nend\n```\n\n## Eu posso usar recurs√£o de cauda na minha linguagem favorita?\n\n**Depende de qual √© ela.**\n\nN√£o coincidentemente, os tr√™s exemplos de linguagens que suportam otimiza√ß√£o de chamada de cauda que eu trouxe s√£o **linguagens funcionais**. Normalmente, programa√ß√£o funcional utiliza recurs√£o com uma frequ√™ncia superior a itera√ß√£o, e linguagens funcionais t√™m essa preocupa√ß√£o com performance e limita√ß√µes de mem√≥ria. \n\nA Wikip√©dia tem uma [lista com algumas linguagens que suportam essa otimiza√ß√£o](https://en.wikipedia.org/wiki/Tail_call#By_language). Voc√™ vai ver que, em maioria, s√£o linguagens funcionais. Se essa maneira de pensar te interessou, e voc√™ nunca aprendeu uma linguagem funcional, **que tal experimentar?** Se aceita uma sugest√£o, d√° uma olhada em [Clojure](https://www.braveclojure.com/clojure-for-the-brave-and-true/) ou [Elixir](https://elixir-lang.org/getting-started/introduction.html)!\n","readingTime":10,"summary":"Quando precisamos realizar uma opera√ß√£o v√°rias vezes, geralmente existem duas maneiras: iterativa e recursiva. Iterativa √© quando utilizamos alguma estrutura de la√ßo, como um `for` ou `while`, com uma vari√°vel de controle para saber quando parar. Recursiva √© quando uma fun√ß√£o decide **executar a si mesma** por entender que ainda precisa continuar processando. Toda itera√ß√£o pode ser escrita como uma recurs√£o e vice-versa. Recurs√µes por√©m tem um risco associado: o **estouro da pilha**. Vamos entender o que isso significa e como escrever c√≥digo recursivo evitando esse problema!\n\n"}},"path":"recursao-de-causa-ou-como-nao-estourar-a-pilha"}
