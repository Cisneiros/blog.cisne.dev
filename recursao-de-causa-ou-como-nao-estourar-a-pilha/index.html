<!DOCTYPE html><html lang="pt-BR" class=" "><head><meta name="generator" content="React Static"/><title data-react-helmet="true">Recursão de cauda — ou como não estourar a pilha · Cisne.dev blog</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:creator" content="Cisneiros"/><meta data-react-helmet="true" property="og:title" content="Recursão de cauda — ou como não estourar a pilha · Cisne.dev blog"/><meta data-react-helmet="true" property="og:image" content="https://blog.cisne.dev/recursao-de-causa-ou-como-nao-estourar-a-pilha/social-image.png"/><meta data-react-helmet="true" name="twitter:title" content="Recursão de cauda — ou como não estourar a pilha · Cisne.dev blog"/><meta data-react-helmet="true" name="twitter:image" content="https://blog.cisne.dev/recursao-de-causa-ou-como-nao-estourar-a-pilha/social-image.png"/><link rel="preload" as="script" href="/templates/vendors~__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.207edc50.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.a04ea84b.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/post.d8dd52db.js"/><link rel="preload" as="script" href="/templates/vendors~main.272ae1d1.js"/><link rel="preload" as="script" href="/main.f19d4c14.js"/><link data-react-helmet="true" rel="stylesheet" href="//unpkg.com/dracula-prism/dist/css/dracula-prism.min.css"/><style data-styled="" data-styled-version="5.1.1">.CfxHf{max-width:960px;margin:0 auto;position:relative;}/*!sc*/
data-styled.g1[id="ui__Fit-prwz6b-0"]{content:"CfxHf,"}/*!sc*/
.iuDFSN{padding:1rem;color:var(--color-mid);text-align:center;font-size:1.5rem;}/*!sc*/
.iuDFSN a,.iuDFSN a:hover{-webkit-text-decoration:none;text-decoration:none;color:inherit;}/*!sc*/
data-styled.g2[id="Navigation__Container-sc-1yk0pqp-0"]{content:"iuDFSN,"}/*!sc*/
.izuwCZ{max-width:960px;margin:0 auto;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
data-styled.g3[id="Navigation__NavFit-sc-1yk0pqp-1"]{content:"izuwCZ,"}/*!sc*/
.TctaC{width:2.5rem;height:1.2em;overflow:hidden;--default-rotation:-180deg;}/*!sc*/
@media (prefers-color-scheme:dark){.TctaC{--default-rotation:0;}}/*!sc*/
data-styled.g4[id="Navigation__BrightnessContainer-sc-1yk0pqp-2"]{content:"TctaC,"}/*!sc*/
.sLeDt{-webkit-transform:rotate(var(--default-rotation));-ms-transform:rotate(var(--default-rotation));transform:rotate(var(--default-rotation));-webkit-transition:-webkit-transform 0.3s ease-out;-webkit-transition:transform 0.3s ease-out;transition:transform 0.3s ease-out;}/*!sc*/
html.light .sLeDt{-webkit-transform:rotate(-180deg);-ms-transform:rotate(-180deg);transform:rotate(-180deg);}/*!sc*/
html.dark .sLeDt{-webkit-transform:rotate(0);-ms-transform:rotate(0);transform:rotate(0);}/*!sc*/
data-styled.g5[id="Navigation__BrightnessSpinner-sc-1yk0pqp-3"]{content:"sLeDt,"}/*!sc*/
.frsARl{background:none;border:none;cursor:pointer;}/*!sc*/
.frsARl:last-child{-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg);}/*!sc*/
data-styled.g7[id="Navigation__BrightnessIcon-sc-1yk0pqp-5"]{content:"frsARl,"}/*!sc*/
.gdHjSq{margin-top:3rem;padding:1rem;background:var(--color-foreground);color:var(--color-background);}/*!sc*/
.gdHjSq a{color:var(--text-inverse-color-1);}/*!sc*/
.gdHjSq a:hover{color:var(--text-inverse-color-3);}/*!sc*/
data-styled.g8[id="Footer__Container-b3q04c-0"]{content:"gdHjSq,"}/*!sc*/
.layJcq{max-width:960px;margin:0 auto;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
data-styled.g9[id="Footer__FooterFit-b3q04c-1"]{content:"layJcq,"}/*!sc*/
*{box-sizing:border-box;margin:0;padding:0;border:0;font-size:inherit;font-weight:inherit;font-style:inherit;}/*!sc*/
:root{--color-1:#12c2e9;--color-2:#c471ed;--color-3:#f64f59;--color-1-darker:#0A7B94;--color-2-darker:#AE3CE7;--color-3-darker:#E90C1B;--color-light:#fefefe;--color-dark:#030303;--color-mid-dark:#747481;--color-mid-light:#818181;--font-weight-light:300;--font-weight-regular:400;--font-weight-heavy:500;--font-family-light:"HelveticaNeue-Light","Helvetica Neue Light",'Helvetica Neue',sans-serif;--font-family:'Helvetica Neue',sans-serif;}/*!sc*/
strong,h1,h2,h3,h4,h5,h6{font-family:var(--font-family);}/*!sc*/
html{font-family:var(--font-family-light);font-size:20px;line-height:1;color:var(--color-foreground);background-color:var(--color-background);text-rendering:optimizeLegibility;}/*!sc*/
@media (max-width:600px){html{font-size:16px;}}/*!sc*/
html,html.light{--color-background:var(--color-light);--color-foreground:var(--color-dark);--color-mid:var(--color-mid-dark);--text-color-1:var(--color-1-darker);--text-color-2:var(--color-2-darker);--text-color-3:var(--color-3-darker);--text-inverse-color-1:var(--color-1);--text-inverse-color-2:var(--color-2);--text-inverse-color-3:var(--color-3);}/*!sc*/
html.dark{--color-background:var(--color-dark);--color-foreground:var(--color-light);--color-mid:var(--color-mid-light);--text-color-1:var(--color-1);--text-color-2:var(--color-2);--text-color-3:var(--color-3);--text-inverse-color-1:var(--color-1-darker);--text-inverse-color-2:var(--color-2-darker);--text-inverse-color-3:var(--color-3-darker);}/*!sc*/
@media (prefers-color-scheme:dark){html{--color-background:var(--color-dark);--color-foreground:var(--color-light);--color-mid:var(--color-mid-light);}}/*!sc*/
body{font-size:1em;font-weight:var(--font-weight-light);}/*!sc*/
strong{font-weight:var(--font-weight-heavy);}/*!sc*/
em{font-style:italic;}/*!sc*/
main{padding:1rem;}/*!sc*/
hr{width:30%;margin:4rem auto;border:none;border-bottom:dotted 1px var(--color-1);}/*!sc*/
.pagination{text-align:center;}/*!sc*/
.pagination a{color:var(--text-color-1);}/*!sc*/
.pagination a:hover{color:var(--text-color-3);}/*!sc*/
a{color:var(--text-color-1);-webkit-text-decoration-color:#c471ed80;text-decoration-color:#c471ed80;-webkit-text-decoration-style:wavy;text-decoration-style:wavy;}/*!sc*/
a:hover{color:var(--text-color-3);-webkit-text-decoration-color:#12c2e980;text-decoration-color:#12c2e980;}/*!sc*/
.phone-mockup{max-width:15rem;margin:0 auto 1rem;position:relative;}/*!sc*/
.phone-mockup::before{content:'';width:100%;height:100%;position:absolute;pointer-events:none;background:url(/iphone-11-pro.png) no-repeat;background-size:contain;}/*!sc*/
.phone-mockup video,.phone-mockup img{width:100%;padding:9.3%;}/*!sc*/
data-styled.g14[id="sc-global-hFBrmQ1"]{content:"sc-global-hFBrmQ1,"}/*!sc*/
.tuaWG{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
@media (max-width:600px){.tuaWG{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}/*!sc*/
data-styled.g23[id="Poststyles__AfterPost-sc-12qb97v-0"]{content:"tuaWG,"}/*!sc*/
.gkeqUt{-webkit-flex:1;-ms-flex:1;flex:1;}/*!sc*/
@media (max-width:600px){.gkeqUt{text-align:center;margin-bottom:1rem;}}/*!sc*/
data-styled.g24[id="Poststyles__AfterPostChild-sc-12qb97v-1"]{content:"gkeqUt,"}/*!sc*/
.fAvgXR{-webkit-flex:1;-ms-flex:1;flex:1;text-align:right;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
@media (max-width:600px){.fAvgXR{text-align:center;margin-bottom:1rem;}}/*!sc*/
data-styled.g25[id="Poststyles__Tags-sc-12qb97v-2"]{content:"fAvgXR,"}/*!sc*/
.kSZCZX::before{content:' #';color:var(--color-mid);}/*!sc*/
data-styled.g26[id="Poststyles__Tag-sc-12qb97v-3"]{content:"kSZCZX,"}/*!sc*/
.kyWzPB{-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;hyphens:auto;}/*!sc*/
data-styled.g27[id="Poststyles__Container-sc-12qb97v-4"]{content:"kyWzPB,"}/*!sc*/
.hhBwVH{font-size:5rem;font-weight:var(--font-weight-regular);line-height:0.8;background:linear-gradient(var(--color-1),var(--color-2),var(--color-3));-webkit-text-fill-color:transparent;background-clip:text;-webkit-background-clip:text;padding-bottom:1rem;margin:1rem 0;}/*!sc*/
html.rainbow .hhBwVH{background-image:linear-gradient(124deg,#ff2400,#e81d1d,#e8b71d,#e3e81d,#1de840,#1ddde8,#2b1de8,#dd00f3,#dd00f3);-webkit-animation:hTUzwZ 9s ease infinite;animation:hTUzwZ 9s ease infinite;background-size:450% 450%;}/*!sc*/
@media (max-width:600px){.hhBwVH{font-size:3.5rem;}}/*!sc*/
.hhBwVH a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g28[id="Poststyles__Title-sc-12qb97v-5"]{content:"hhBwVH,"}/*!sc*/
.fonWHZ{color:var(--color-mid);text-align:center;margin-bottom:2rem;}/*!sc*/
data-styled.g29[id="Poststyles__Meta-sc-12qb97v-6"]{content:"fonWHZ,"}/*!sc*/
.jhgzPU{line-height:1.6;}/*!sc*/
.jhgzPU h2{font-size:2.5rem;}/*!sc*/
.jhgzPU h3{font-size:2rem;}/*!sc*/
.jhgzPU h4{font-size:1.5rem;}/*!sc*/
.jhgzPU h2,.jhgzPU h3,.jhgzPU h4,.jhgzPU h5,.jhgzPU h6{-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;hyphens:auto;font-weight:var(--font-weight-regular);line-height:0.8;padding-bottom:1rem;margin-top:2rem;}/*!sc*/
.jhgzPU img{max-width:100%;}/*!sc*/
.jhgzPU pre.refractor{margin-top:0;margin-left:0;padding-left:1rem;border-left:solid 0.25rem var(--color-1);border-radius:0;font-size:0.8rem;overflow-wrap:normal;overflow-x:auto;background-color:var(--color-dark);color:var(--color-light);padding-top:0.5rem;padding-bottom:0.5rem;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
.jhgzPU pre.refractor::-webkit-scrollbar{width:0.25rem;height:0.25rem;}/*!sc*/
.jhgzPU pre.refractor code,.jhgzPU code{font-family:'Fira Code','Menlo',monospace;}/*!sc*/
.jhgzPU p code{color:var(--text-color-3);}/*!sc*/
.jhgzPU p code,.jhgzPU h1 code,.jhgzPU h2 code,.jhgzPU h3 code,.jhgzPU h4 code,.jhgzPU h5 code,.jhgzPU h6 code{font-size:0.9em;}/*!sc*/
.jhgzPU p,.jhgzPU pre,.jhgzPU ul,.jhgzPU ol,.jhgzPU table,.jhgzPU blockquote,.jhgzPU .live-code-container{margin-bottom:1rem;}/*!sc*/
.jhgzPU twitter-widget{margin-bottom:1rem !important;}/*!sc*/
.jhgzPU p:last-child,.jhgzPU pre:last-child,.jhgzPU ul:last-child,.jhgzPU ol:last-child,.jhgzPU table:last-child,.jhgzPU blockquote:last-child,.jhgzPU .live-code-container:last-child{margin-bottom:0;}/*!sc*/
.jhgzPU ul,.jhgzPU ol{list-style:none;margin-left:1rem;counter-reset:li;}/*!sc*/
.jhgzPU li{counter-increment:li;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}/*!sc*/
.jhgzPU ul li::before{content:'•';margin-right:0.5rem;color:var(--color-2);}/*!sc*/
.jhgzPU ol li::before{content:"."counter(li);margin-right:0.5rem;color:var(--color-2);font-weight:var(--font-weight-regular);width:1em;display:inline-block;margin-left:-0.5em;margin-right:0.5em;text-align:right;direction:rtl;}/*!sc*/
.jhgzPU table{margin-left:auto;margin-right:auto;border-spacing:0;font-size:0.9em;}/*!sc*/
.jhgzPU td,.jhgzPU th{border-bottom:solid 1px var(--color-2);padding:0.5rem;}/*!sc*/
.jhgzPU th{font-weight:var(--font-weight-heavy);}/*!sc*/
.jhgzPU tr:hover{background:var(--color-2);}/*!sc*/
.jhgzPU tr:last-of-type td{border-bottom:0;}/*!sc*/
.jhgzPU blockquote{padding-left:1rem;border-left:solid 0.25rem var(--color-3);color:var(--color-mid);}/*!sc*/
data-styled.g30[id="Poststyles__Content-sc-12qb97v-7"]{content:"jhgzPU,"}/*!sc*/
.jjKdZc{position:fixed;top:0;left:0;right:0;height:0.25rem;background-color:var(--color-1);-webkit-transition:opacity 0.25s ease-out;transition:opacity 0.25s ease-out;z-index:2;}/*!sc*/
data-styled.g31[id="post__ScrollTrackerContainer-gh0jqu-0"]{content:"jjKdZc,"}/*!sc*/
@-webkit-keyframes hTUzwZ{0%{background-position:0% 82%;}50%{background-position:100% 19%;}100%{background-position:0% 82%;}}/*!sc*/
@keyframes hTUzwZ{0%{background-position:0% 82%;}50%{background-position:100% 19%;}100%{background-position:0% 82%;}}/*!sc*/
data-styled.g32[id="sc-keyframes-hTUzwZ"]{content:"hTUzwZ,"}/*!sc*/
</style><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml"/></head><body><div id="root"><nav class="Navigation__Container-sc-1yk0pqp-0 iuDFSN"><div class="ui__Fit-prwz6b-0 Navigation__NavFit-sc-1yk0pqp-1 izuwCZ"><p class="logo"><a href="/">Cisne.dev blog</a></p><div class="Navigation__BrightnessContainer-sc-1yk0pqp-2 TctaC"><div class="Navigation__BrightnessSpinner-sc-1yk0pqp-3 sLeDt"><button title="Mudar para modo diurno" aria-label="Mudar para modo diurno" class="Navigation__ClearButton-sc-1yk0pqp-4 Navigation__BrightnessIcon-sc-1yk0pqp-5 frsARl">🌙</button><button title="Mudar para modo noturno" aria-label="Mudar para modo noturno" class="Navigation__ClearButton-sc-1yk0pqp-4 Navigation__BrightnessIcon-sc-1yk0pqp-5 frsARl">☀️</button></div></div></div></nav><main><div class="ui__Fit-prwz6b-0 CfxHf"><div><div style="width:0%;opacity:0" class="post__ScrollTrackerContainer-gh0jqu-0 jjKdZc"></div><article class="Poststyles__Container-sc-12qb97v-4 kyWzPB"><h1 class="Poststyles__Title-sc-12qb97v-5 hhBwVH"><a href="/recursao-de-causa-ou-como-nao-estourar-a-pilha/">Recursão de cauda — ou como não estourar a pilha</a></h1><p class="Poststyles__Meta-sc-12qb97v-6 fonWHZ">Publicado em <!-- -->13 nov 2020<!-- -->. Uns <!-- -->10<!-- --> minutos de leitura.</p><div class="Poststyles__Content-sc-12qb97v-7 jhgzPU content"><p>Quando precisamos realizar uma operação várias vezes, geralmente existem duas maneiras: iterativa e recursiva. Iterativa é quando utilizamos alguma estrutura de laço, como um <code>for</code> ou <code>while</code>, com uma variável de controle para saber quando parar. Recursiva é quando uma função decide <strong>executar a si mesma</strong> por entender que ainda precisa continuar processando. Toda iteração pode ser escrita como uma recursão e vice-versa. Recursões porém tem um risco associado: o <strong>estouro da pilha</strong>. Vamos entender o que isso significa e como escrever código recursivo evitando esse problema!</p><span><!-- summary-break --></span><h2>O que é essa pilha?</h2><p>Antes de mais nada, o que é <strong>a pilha</strong>? Neste contexto, não estamos falando de uma bateria 🔋, mas de uma estrutura de dados em que podemos <strong>empilhar</strong> informação 🥞. Sempre que executamos uma função, nós estamos movendo a execução do código de um ponto para o outro. Quando a função que chamamos termina, precisamos voltar para onde estávamos com o resultado e continuar a execução. Por isso, quando chamamos uma função, o ambiente de execução vai guardar <strong>o estado atual de execução</strong> em algum lugar para que possamos retornar para ele depois. Diferentes linguagens de programação vão ter diferentes ambientes de execução, mas o conceito é parecido entre elas.</p><p>Cada chamada de função adiciona esse contexto numa pilha (em inglês, <em>stack</em>). Usa-se uma pilha pois, se nós executamos a função A, que chama a função B, que chama C (nessa ordem), ao final de C nós queremos retornar para B e, ao final de B, nós queremos retornar para A. Assim, vamos empilhando as chamadas aninhadas (chamadas dentro de chamadas) e desempilhando nos retornos. Cada contexto desse adicionado na pilha é chamado de <strong>quadro</strong> (<em>stack frame</em>) e ocupa <strong>espaço em memória</strong>.</p><p>Memória não é infinita, e cada ambiente de execução de código vai definir um limite para o quão profunda uma pilha de chamadas de função pode ser. Se esse tamanho for, por exemplo, 1000, significa que você pode ter no máximo 1000 níveis de funções chamando umas as outras sem retornar, de acordo com o que a função precisar guardar na pilha. Se você tentar chamar mais uma função aninhada, você vai ter um <strong>estouro da pilha</strong>, de onde vem o nome do <em>Stack Overflow</em>.</p><h2>O que isso tem a ver com recursão?</h2><p>É difícil imaginar escrever 1000 funções de maneira que uma chame a outra, consequentemente ultrapassando esse limite. Afinal de contas, você vai ter o limite da própria quantidade de código que você escreve. Porém, existe algo bem mais rápido e capaz do que nós, humanos: <strong>computadores</strong>. E aí que entra recursão.</p><p>Imagine o seguinte cenário, em JavaScript. Note que estou colocando um <code>n</code> ao final dos números. Essa é a sintaxe para <code>BigInt</code> em JS, que são números arbitrariamente grandes. O exemplo a seguir faz conta com número muito grandes e, se usarmos números padrões de JavaScript, chegaríamos em <code>Infinity</code> eventualmente.</p><pre class="refractor language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1n</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> number <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Temos uma função recursiva que calcula o <strong>fatorial de um número</strong> (o produto de todos os números entre 1 e este número). Ela é recursiva pois tem um <strong>caso base</strong> (se <code>number</code> for igual a zero) em que ela apenas retorna algo e um <strong>caso recursivo</strong> (se <code>number</code> não for igual a zero), em que ela faz algo e <strong>chama a si mesma com outro argumento</strong>.</p><pre class="refractor language-js"><code class="language-js"><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">10n</span><span class="token punctuation">)</span> <span class="token comment">// Resultado: 3628800n</span></code></pre><p>Essa função vai precisar usar a pilha <code>number</code> vezes, pois cada execução dela precisa chamar uma função (ela mesma) <strong>antes de poder retornar</strong>. Ou seja, quando eu chamo <code>factorial(10)</code>, essa função retornar <code>10 * factorial(9)</code>. Mas ela não consegue retornar ainda, pois tem uma chamada de função não resolvida. Ela precisa esperar <code>factorial(9)</code> retornar para <strong>depois</strong> poder multiplicar por 10, e assim retornar também. Isso acontece sucessivamente até chegar em <code>factorial(0)</code>, que retorna apenas <code>1</code>. A partir daí, os contextos de execução das funções vão sendo <strong>desempilhados</strong>, passando pelo <code>factorial(1)</code> (que aguardava o resultado do <code>factorial(0)</code>), depois <code>factorial(2)</code>, e assim até voltar para o original, <code>factorial(10)</code>.</p><p>Se a entrada dessa função se tornar muito grande, vamos precisar fazer um número de chamadas de função, uma dentro da outra, que pode precisar guardar mais informação na pilha do que ela suporta, causando um estouro da pilha. Nos meus testes, rodando em Node.js, <code>factorial(10948n)</code> foi o ponto em que a pilha estouraria. Ao tentar executar essa função, eu recebi a mensagem: <strong>Uncaught RangeError: Maximum call stack size exceeded</strong>.</p><p>O motivo de precisarmos guardar informação na pilha de chamadas de função é que <strong>essa função precisa fazer algo com o resultado da chamada recursiva</strong>. Mais especificamente, olhando para essa linha dentro do <code>else</code>:</p><pre class="refractor language-js"><code class="language-js">    <span class="token keyword">return</span> number <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">)</span></code></pre><p>A função precisa que a chamada recursiva retorne <strong>para depois</strong> conseguir fazer a multiplicação. Para visualizar, vamos diminuir a entrada para <code>5n</code>. A execução aconteceria, passo a passo, assim:</p><pre class="refractor language-js"><code class="language-js"><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">3n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">2n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">1n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span> <span class="token operator">*</span> <span class="token number">1n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">0n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span> <span class="token operator">*</span> <span class="token number">1n</span> <span class="token operator">*</span> <span class="token number">1n</span> <span class="token comment">// Chegamos no caso base</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span> <span class="token operator">*</span> <span class="token number">1n</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">6n</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">24n</span>
<span class="token number">120n</span></code></pre><p>É aí que entra o conceito de <strong>recursão de cauda</strong>, ou <strong>otimização de chamada de cauda</strong> (<em>tail call optimization</em>).</p><h2>Como fazer essa recursão não estourar?</h2><p>Algumas linguagens de programação conseguem identificar chamadas de funções que <strong>não precisam guardar contexto na pilha</strong>. Quando isso acontece, é possível ter uma recursão que, independentemente da profundidade, não vai causar um estouro da pilha.</p><p><strong>Infelizmente, JavaScript não é uma delas.</strong> As implementações atuais não suportam esse tipo de otimização. Para fins ilustrativos, vamos rever como seria o exemplo acima se JavaScript tivesse suporte a recursão de cauda. Depois, vamos ver o mesmo exemplo em <strong>linguagens que de fato suportam</strong>.</p><p>Vamos re-escrever a função do fatorial de maneira que <strong>ela não precise esperar pelo retorno da recursão para retornar</strong>. O segredo está em fazer com que, em todos os possíveis caminhos para o código, nós retornemos apenas <strong>valores</strong> ou <strong>a própria chamada recursiva</strong>.</p><pre class="refractor language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">number<span class="token punctuation">,</span> product</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> product
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">,</span> product <span class="token operator">*</span> number<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>A função acima tem dois caminhos possíveis de execução. O primeiro caminho, se <code>number</code> for zero, retorna apenas um valor (a variável <code>product</code>). O segundo, se <code>number</code> não for zero, é o que modificamos. Ao invés de retornar o valor atual multiplicado pelo retorno da recursão, nós <strong>calculamos a multiplicação primeiro</strong> e só depois fazemos a chamada recursiva.</p><p>Para isso, introduzimos um segundo argumento a essa função, o <code>product</code>. Ele funciona aqui como um <strong>acumulador</strong>, que guarda o resultado intermediário. Esse acumulador vai guardando cada multiplicação e é retornado no caso base, quando chegamos no fim da recursão. Como nós passamos esse resultado intermediário na chamada recursiva, nosso <code>return</code> <strong>não faz nada com o resultado da recursão</strong>, apenas retorna-o diretamente. O interpretador do JavaScript poderia perceber isso e <strong>não guardar nada na pilha</strong>. </p><p>Vamos ver como ficaria a sequência de execução dessa nova função. Note que, como ela tem um acumulador (segundo parâmetro), precisamos passar algum <strong>valor inicial</strong> para esse parâmetro. Como é uma multiplicação, podemos passar <code>1n</code> (pois 1 não afeta um produto).</p><pre class="refractor language-js"><code class="language-js"><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5n</span><span class="token punctuation">,</span> <span class="token number">1n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4n</span><span class="token punctuation">,</span> <span class="token number">5n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">3n</span><span class="token punctuation">,</span> <span class="token number">20n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">2n</span><span class="token punctuation">,</span> <span class="token number">60n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">1n</span><span class="token punctuation">,</span> <span class="token number">120n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">0n</span><span class="token punctuation">,</span> <span class="token number">120n</span><span class="token punctuation">)</span>
<span class="token number">120n</span></code></pre><p>Sobre esse segundo argumento, idealmente não gostaríamos que fosse necessário passá-lo para começar a calcular. Para isso, podemos separar a implementação da função da API pública, assim:</p><pre class="refractor language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">factorialImplementation</span><span class="token punctuation">(</span><span class="token parameter">number<span class="token punctuation">,</span> product</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> product
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">factorialImplementation</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">,</span> product <span class="token operator">*</span> number<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// A função que exportamos publicamente apenas tem um argumento</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">factorialImplementation</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> <span class="token number">1n</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>Assim, nossa função <code>factorial</code> só recebe um argumento. Alternativamente, poderíamos colocar um valor padrão para o segundo argumento (mas isso permitiria chamar a função passando um segundo argumento errado, ainda assim).</p><h2>Exemplos em linguagens que suportam otimização de chamadas de cauda</h2><p>Como eu comentei, <strong>infelizmente JavaScript não tem suporte</strong> a não adicionar contexto na pilha caso não seja necessário. Toda chamada de função vai colocar algo na pilha e, eventualmente, uma recursão causa um estouro.</p><p>Vamos rever o exemplo do fatorial em algumas linguagens que têm suporte a essa otimização.</p><h3>Clojure</h3><pre class="refractor language-js"><code class="language-js"><span class="token punctuation">(</span>defn factorial
  <span class="token string">&quot;Implementação sem tail call optimization&quot;</span>
  <span class="token punctuation">[</span>number<span class="token punctuation">]</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>zero<span class="token operator">?</span> number<span class="token punctuation">)</span>
    <span class="token number">1</span>
    <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token function">number</span> <span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token punctuation">(</span>dec number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class="refractor language-js"><code class="language-js"><span class="token punctuation">(</span>defn factorial
  <span class="token string">&quot;Implementação com tail call optimization&quot;</span>
  <span class="token punctuation">[</span>number product<span class="token punctuation">]</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>zero<span class="token operator">?</span> number<span class="token punctuation">)</span>
    <span class="token function">product</span>
    <span class="token punctuation">(</span><span class="token function">recur</span> <span class="token punctuation">(</span>dec number<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> product number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Note que, em Clojure, existe uma forma especial para recursão de cauda: <code>recur</code>. Usamos <code>recur</code> no lugar do nome da função, para executar uma chamada recursiva. Se você tentar usar <code>recur</code> num contexto que ele não seja a última execução de um caminho da execução de código, vai receber um erro. Se você tentar escrever recursões sempre com <code>recur</code>, você tem a garantia de fazer uma recursão de cauda (pois o compilador não vai deixar você não o fazer).</p><h3>Kotlin</h3><pre class="refractor language-js"><code class="language-js"><span class="token comment">// Implementação sem tail call optimization</span>
fun <span class="token function">factorial</span><span class="token punctuation">(</span>number<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token operator">:</span> Long <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token number">1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        number <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><pre class="refractor language-js"><code class="language-js"><span class="token comment">// Implementação com tail call optimization</span>
tailrec fun <span class="token function">factorial</span><span class="token punctuation">(</span>number<span class="token operator">:</span> Long<span class="token punctuation">,</span> product<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token operator">:</span> Long <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        product
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> product <span class="token operator">*</span> number<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Kotlin possui a palavra-chave <code>tailrec</code>. Se aplicada a uma função, indica que a recursão dessa função é de cauda. Se você aplicar esse modificador na primeira versão, por exemplo, terá um erro, assim como o uso do <code>recur</code> em Clojure.</p><h3>Haskell</h3><pre class="refractor language-js"><code class="language-js"><span class="token operator">--</span> Implementação sem tail call optimization
factorial <span class="token operator">:</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">Integral a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span><span class="token operator">&gt;</span> a
fatorial <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1</span>
factorial n <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token function">factorial</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><pre class="refractor language-js"><code class="language-js"><span class="token operator">--</span> Implementação com tail call optimization
factorial <span class="token operator">:</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">Integral a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span><span class="token operator">&gt;</span> a <span class="token operator">-</span><span class="token operator">&gt;</span> a
fatorial <span class="token number">0</span> p <span class="token operator">=</span> p
factorial n p <span class="token operator">=</span> <span class="token function">factorial</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>p <span class="token operator">*</span> n<span class="token punctuation">)</span></code></pre><h3>Elixir</h3><p>Recentemente, eu escrevi um post sobre <a href="/casamento-de-padroes-em-elixir/">casamento de padrões com Elixir</a>. No final dele tem esse exemplo de fatorial usando casamento de padrões e recursão de cauda. Ela também deixa pública apenas a chamada da função com um argumento, mantendo a versão com o acumulador privada.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> Math <span class="token keyword">do</span>
  <span class="token keyword">def</span> factorial<span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token keyword">do</span>
    factorial<span class="token punctuation">(</span>number<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> factorial<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> current_product<span class="token punctuation">)</span> <span class="token keyword">do</span>
    current_product
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> factorial<span class="token punctuation">(</span>number<span class="token punctuation">,</span> current_product<span class="token punctuation">)</span> <span class="token keyword">do</span>
    factorial<span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> number <span class="token operator">*</span> current_product<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span></code></pre><h2>Eu posso usar recursão de cauda na minha linguagem favorita?</h2><p><strong>Depende de qual é ela.</strong></p><p>Não coincidentemente, os três exemplos de linguagens que suportam otimização de chamada de cauda que eu trouxe são <strong>linguagens funcionais</strong>. Normalmente, programação funcional utiliza recursão com uma frequência superior a iteração, e linguagens funcionais têm essa preocupação com performance e limitações de memória. </p><p>A Wikipédia tem uma <a href="https://en.wikipedia.org/wiki/Tail_call#By_language">lista com algumas linguagens que suportam essa otimização</a>. Você vai ver que, em maioria, são linguagens funcionais. Se essa maneira de pensar te interessou, e você nunca aprendeu uma linguagem funcional, <strong>que tal experimentar?</strong> Se aceita uma sugestão, dá uma olhada em <a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/">Clojure</a> ou <a href="https://elixir-lang.org/getting-started/introduction.html">Elixir</a>!</p></div><hr/><div class="Poststyles__AfterPost-sc-12qb97v-0 tuaWG"><p class="Poststyles__AfterPostChild-sc-12qb97v-1 gkeqUt">Gostou? <a href="https://twitter.com/intent/tweet?text=%22Recurs%C3%A3o%20de%20cauda%20%E2%80%94%20ou%20como%20n%C3%A3o%20estourar%20a%20pilha%22%20por%20%40Cisneiros%0A%0Ahttps%3A%2F%2Fblog.cisne.dev%2Frecursao-de-causa-ou-como-nao-estourar-a-pilha" target="_blank" rel="noopener noreferrer">Que tal compartilhar?</a></p><p class="Poststyles__AfterPostChild-sc-12qb97v-1 Poststyles__Tags-sc-12qb97v-2 fAvgXR">Tags: <span class="Poststyles__Tag-sc-12qb97v-3 kSZCZX"><a href="/tag/conceitos">conceitos</a></span></p></div></article></div></div></main><footer class="Footer__Container-b3q04c-0 gdHjSq"><div class="ui__Fit-prwz6b-0 Footer__FooterFit-b3q04c-1 layJcq"><p>© <a href="https://cisne.dev">Alexandre Cisneiros</a></p><p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a></p></div></footer></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/src/containers/post\",\"sharedHashesByProp\":{},\"data\":{\"postData\":{\"title\":\"Recurs\u00E3o de cauda \u2014 ou como n\u00E3o estourar a pilha\",\"date\":\"2020-11-13T00:00:00-03:00\",\"slug\":\"recursao-de-causa-ou-como-nao-estourar-a-pilha\",\"tags\":[\"conceitos\"],\"filePath\":\"2020-11-13-recursao-de-causa-ou-como-nao-estourar-a-pilha.md\",\"content\":\"Quando precisamos realizar uma opera\u00E7\u00E3o v\u00E1rias vezes, geralmente existem duas maneiras: iterativa e recursiva. Iterativa \u00E9 quando utilizamos alguma estrutura de la\u00E7o, como um `for` ou `while`, com uma vari\u00E1vel de controle para saber quando parar. Recursiva \u00E9 quando uma fun\u00E7\u00E3o decide **executar a si mesma** por entender que ainda precisa continuar processando. Toda itera\u00E7\u00E3o pode ser escrita como uma recurs\u00E3o e vice-versa. Recurs\u00F5es por\u00E9m tem um risco associado: o **estouro da pilha**. Vamos entender o que isso significa e como escrever c\u00F3digo recursivo evitando esse problema!\\n\\n\u003C!-- summary-break -->\\n\\n## O que \u00E9 essa pilha?\\n\\nAntes de mais nada, o que \u00E9 **a pilha**? Neste contexto, n\u00E3o estamos falando de uma bateria \uD83D\uDD0B, mas de uma estrutura de dados em que podemos **empilhar** informa\u00E7\u00E3o \uD83E\uDD5E. Sempre que executamos uma fun\u00E7\u00E3o, n\u00F3s estamos movendo a execu\u00E7\u00E3o do c\u00F3digo de um ponto para o outro. Quando a fun\u00E7\u00E3o que chamamos termina, precisamos voltar para onde est\u00E1vamos com o resultado e continuar a execu\u00E7\u00E3o. Por isso, quando chamamos uma fun\u00E7\u00E3o, o ambiente de execu\u00E7\u00E3o vai guardar **o estado atual de execu\u00E7\u00E3o** em algum lugar para que possamos retornar para ele depois. Diferentes linguagens de programa\u00E7\u00E3o v\u00E3o ter diferentes ambientes de execu\u00E7\u00E3o, mas o conceito \u00E9 parecido entre elas.\\n\\nCada chamada de fun\u00E7\u00E3o adiciona esse contexto numa pilha (em ingl\u00EAs, _stack_). Usa-se uma pilha pois, se n\u00F3s executamos a fun\u00E7\u00E3o A, que chama a fun\u00E7\u00E3o B, que chama C (nessa ordem), ao final de C n\u00F3s queremos retornar para B e, ao final de B, n\u00F3s queremos retornar para A. Assim, vamos empilhando as chamadas aninhadas (chamadas dentro de chamadas) e desempilhando nos retornos. Cada contexto desse adicionado na pilha \u00E9 chamado de **quadro** (_stack frame_) e ocupa **espa\u00E7o em mem\u00F3ria**.\\n\\nMem\u00F3ria n\u00E3o \u00E9 infinita, e cada ambiente de execu\u00E7\u00E3o de c\u00F3digo vai definir um limite para o qu\u00E3o profunda uma pilha de chamadas de fun\u00E7\u00E3o pode ser. Se esse tamanho for, por exemplo, 1000, significa que voc\u00EA pode ter no m\u00E1ximo 1000 n\u00EDveis de fun\u00E7\u00F5es chamando umas as outras sem retornar, de acordo com o que a fun\u00E7\u00E3o precisar guardar na pilha. Se voc\u00EA tentar chamar mais uma fun\u00E7\u00E3o aninhada, voc\u00EA vai ter um **estouro da pilha**, de onde vem o nome do _Stack Overflow_.\\n\\n## O que isso tem a ver com recurs\u00E3o?\\n\\n\u00C9 dif\u00EDcil imaginar escrever 1000 fun\u00E7\u00F5es de maneira que uma chame a outra, consequentemente ultrapassando esse limite. Afinal de contas, voc\u00EA vai ter o limite da pr\u00F3pria quantidade de c\u00F3digo que voc\u00EA escreve. Por\u00E9m, existe algo bem mais r\u00E1pido e capaz do que n\u00F3s, humanos: **computadores**. E a\u00ED que entra recurs\u00E3o.\\n\\nImagine o seguinte cen\u00E1rio, em JavaScript. Note que estou colocando um `n` ao final dos n\u00FAmeros. Essa \u00E9 a sintaxe para `BigInt` em JS, que s\u00E3o n\u00FAmeros arbitrariamente grandes. O exemplo a seguir faz conta com n\u00FAmero muito grandes e, se usarmos n\u00FAmeros padr\u00F5es de JavaScript, chegar\u00EDamos em `Infinity` eventualmente.\\n\\n```js\\nfunction factorial(number) {\\n  if (number === 0n) {\\n    return 1n\\n  } else {\\n    return number * factorial(number - 1n)\\n  }\\n}\\n```\\n\\nTemos uma fun\u00E7\u00E3o recursiva que calcula o **fatorial de um n\u00FAmero** (o produto de todos os n\u00FAmeros entre 1 e este n\u00FAmero). Ela \u00E9 recursiva pois tem um **caso base** (se `number` for igual a zero) em que ela apenas retorna algo e um **caso recursivo** (se `number` n\u00E3o for igual a zero), em que ela faz algo e **chama a si mesma com outro argumento**.\\n\\n```js\\nfactorial(10n) // Resultado: 3628800n\\n```\\n\\nEssa fun\u00E7\u00E3o vai precisar usar a pilha `number` vezes, pois cada execu\u00E7\u00E3o dela precisa chamar uma fun\u00E7\u00E3o (ela mesma) **antes de poder retornar**. Ou seja, quando eu chamo `factorial(10)`, essa fun\u00E7\u00E3o retornar `10 * factorial(9)`. Mas ela n\u00E3o consegue retornar ainda, pois tem uma chamada de fun\u00E7\u00E3o n\u00E3o resolvida. Ela precisa esperar `factorial(9)` retornar para **depois** poder multiplicar por 10, e assim retornar tamb\u00E9m. Isso acontece sucessivamente at\u00E9 chegar em `factorial(0)`, que retorna apenas `1`. A partir da\u00ED, os contextos de execu\u00E7\u00E3o das fun\u00E7\u00F5es v\u00E3o sendo **desempilhados**, passando pelo `factorial(1)` (que aguardava o resultado do `factorial(0)`), depois `factorial(2)`, e assim at\u00E9 voltar para o original, `factorial(10)`.\\n\\nSe a entrada dessa fun\u00E7\u00E3o se tornar muito grande, vamos precisar fazer um n\u00FAmero de chamadas de fun\u00E7\u00E3o, uma dentro da outra, que pode precisar guardar mais informa\u00E7\u00E3o na pilha do que ela suporta, causando um estouro da pilha. Nos meus testes, rodando em Node.js, `factorial(10948n)` foi o ponto em que a pilha estouraria. Ao tentar executar essa fun\u00E7\u00E3o, eu recebi a mensagem: **Uncaught RangeError: Maximum call stack size exceeded**.\\n\\nO motivo de precisarmos guardar informa\u00E7\u00E3o na pilha de chamadas de fun\u00E7\u00E3o \u00E9 que **essa fun\u00E7\u00E3o precisa fazer algo com o resultado da chamada recursiva**. Mais especificamente, olhando para essa linha dentro do `else`:\\n\\n```js\\n    return number * factorial(number - 1n)\\n```\\n\\nA fun\u00E7\u00E3o precisa que a chamada recursiva retorne **para depois** conseguir fazer a multiplica\u00E7\u00E3o. Para visualizar, vamos diminuir a entrada para `5n`. A execu\u00E7\u00E3o aconteceria, passo a passo, assim:\\n\\n```js\\nfactorial(5n)\\n5n * factorial(4n)\\n5n * 4n * factorial(3n)\\n5n * 4n * 3n * factorial(2n)\\n5n * 4n * 3n * 2n * factorial(1n)\\n5n * 4n * 3n * 2n * 1n * factorial(0n)\\n5n * 4n * 3n * 2n * 1n * 1n // Chegamos no caso base\\n5n * 4n * 3n * 2n * 1n\\n5n * 4n * 3n * 2n\\n5n * 4n * 6n\\n5n * 24n\\n120n\\n```\\n\\n\u00C9 a\u00ED que entra o conceito de **recurs\u00E3o de cauda**, ou **otimiza\u00E7\u00E3o de chamada de cauda** (_tail call optimization_).\\n\\n## Como fazer essa recurs\u00E3o n\u00E3o estourar?\\n\\nAlgumas linguagens de programa\u00E7\u00E3o conseguem identificar chamadas de fun\u00E7\u00F5es que **n\u00E3o precisam guardar contexto na pilha**. Quando isso acontece, \u00E9 poss\u00EDvel ter uma recurs\u00E3o que, independentemente da profundidade, n\u00E3o vai causar um estouro da pilha.\\n\\n**Infelizmente, JavaScript n\u00E3o \u00E9 uma delas.** As implementa\u00E7\u00F5es atuais n\u00E3o suportam esse tipo de otimiza\u00E7\u00E3o. Para fins ilustrativos, vamos rever como seria o exemplo acima se JavaScript tivesse suporte a recurs\u00E3o de cauda. Depois, vamos ver o mesmo exemplo em **linguagens que de fato suportam**.\\n\\nVamos re-escrever a fun\u00E7\u00E3o do fatorial de maneira que **ela n\u00E3o precise esperar pelo retorno da recurs\u00E3o para retornar**. O segredo est\u00E1 em fazer com que, em todos os poss\u00EDveis caminhos para o c\u00F3digo, n\u00F3s retornemos apenas **valores** ou **a pr\u00F3pria chamada recursiva**.\\n\\n```js\\nfunction factorial(number, product) {\\n  if (number === 0n) {\\n    return product\\n  } else {\\n    return factorial(number - 1n, product * number)\\n  }\\n}\\n```\\n\\nA fun\u00E7\u00E3o acima tem dois caminhos poss\u00EDveis de execu\u00E7\u00E3o. O primeiro caminho, se `number` for zero, retorna apenas um valor (a vari\u00E1vel `product`). O segundo, se `number` n\u00E3o for zero, \u00E9 o que modificamos. Ao inv\u00E9s de retornar o valor atual multiplicado pelo retorno da recurs\u00E3o, n\u00F3s **calculamos a multiplica\u00E7\u00E3o primeiro** e s\u00F3 depois fazemos a chamada recursiva.\\n\\nPara isso, introduzimos um segundo argumento a essa fun\u00E7\u00E3o, o `product`. Ele funciona aqui como um **acumulador**, que guarda o resultado intermedi\u00E1rio. Esse acumulador vai guardando cada multiplica\u00E7\u00E3o e \u00E9 retornado no caso base, quando chegamos no fim da recurs\u00E3o. Como n\u00F3s passamos esse resultado intermedi\u00E1rio na chamada recursiva, nosso `return` **n\u00E3o faz nada com o resultado da recurs\u00E3o**, apenas retorna-o diretamente. O interpretador do JavaScript poderia perceber isso e **n\u00E3o guardar nada na pilha**. \\n\\nVamos ver como ficaria a sequ\u00EAncia de execu\u00E7\u00E3o dessa nova fun\u00E7\u00E3o. Note que, como ela tem um acumulador (segundo par\u00E2metro), precisamos passar algum **valor inicial** para esse par\u00E2metro. Como \u00E9 uma multiplica\u00E7\u00E3o, podemos passar `1n` (pois 1 n\u00E3o afeta um produto).\\n\\n```js\\nfactorial(5n, 1n)\\nfactorial(4n, 5n)\\nfactorial(3n, 20n)\\nfactorial(2n, 60n)\\nfactorial(1n, 120n)\\nfactorial(0n, 120n)\\n120n\\n```\\n\\nSobre esse segundo argumento, idealmente n\u00E3o gostar\u00EDamos que fosse necess\u00E1rio pass\u00E1-lo para come\u00E7ar a calcular. Para isso, podemos separar a implementa\u00E7\u00E3o da fun\u00E7\u00E3o da API p\u00FAblica, assim:\\n\\n```js\\nfunction factorialImplementation(number, product) {\\n  if (number === 0n) {\\n    return product\\n  } else {\\n    return factorialImplementation(number - 1n, product * number)\\n  }\\n}\\n\\n// A fun\u00E7\u00E3o que exportamos publicamente apenas tem um argumento\\nexport function factorial(number) {\\n  return factorialImplementation(number, 1n)\\n}\\n```\\n\\nAssim, nossa fun\u00E7\u00E3o `factorial` s\u00F3 recebe um argumento. Alternativamente, poder\u00EDamos colocar um valor padr\u00E3o para o segundo argumento (mas isso permitiria chamar a fun\u00E7\u00E3o passando um segundo argumento errado, ainda assim).\\n\\n## Exemplos em linguagens que suportam otimiza\u00E7\u00E3o de chamadas de cauda\\n\\nComo eu comentei, **infelizmente JavaScript n\u00E3o tem suporte** a n\u00E3o adicionar contexto na pilha caso n\u00E3o seja necess\u00E1rio. Toda chamada de fun\u00E7\u00E3o vai colocar algo na pilha e, eventualmente, uma recurs\u00E3o causa um estouro.\\n\\nVamos rever o exemplo do fatorial em algumas linguagens que t\u00EAm suporte a essa otimiza\u00E7\u00E3o.\\n\\n### Clojure\\n\\n```clj\\n(defn factorial\\n  \\\"Implementa\u00E7\u00E3o sem tail call optimization\\\"\\n  [number]\\n  (if (zero? number)\\n    1\\n    (* number (factorial (dec number)))))\\n```\\n\\n```clj\\n(defn factorial\\n  \\\"Implementa\u00E7\u00E3o com tail call optimization\\\"\\n  [number product]\\n  (if (zero? number)\\n    product\\n    (recur (dec number) (* product number))))\\n```\\n\\nNote que, em Clojure, existe uma forma especial para recurs\u00E3o de cauda: `recur`. Usamos `recur` no lugar do nome da fun\u00E7\u00E3o, para executar uma chamada recursiva. Se voc\u00EA tentar usar `recur` num contexto que ele n\u00E3o seja a \u00FAltima execu\u00E7\u00E3o de um caminho da execu\u00E7\u00E3o de c\u00F3digo, vai receber um erro. Se voc\u00EA tentar escrever recurs\u00F5es sempre com `recur`, voc\u00EA tem a garantia de fazer uma recurs\u00E3o de cauda (pois o compilador n\u00E3o vai deixar voc\u00EA n\u00E3o o fazer).\\n\\n### Kotlin\\n\\n```kt\\n// Implementa\u00E7\u00E3o sem tail call optimization\\nfun factorial(number: Long) : Long {\\n    return if (number === 0) {\\n        1\\n    } else {\\n        number * factorial(number - 1)\\n    }\\n}\\n```\\n\\n```kt\\n// Implementa\u00E7\u00E3o com tail call optimization\\ntailrec fun factorial(number: Long, product: Long) : Long {\\n    return if (number === 0) {\\n        product\\n    } else {\\n        factorial(number - 1, product * number)\\n    }\\n}\\n```\\n\\nKotlin possui a palavra-chave `tailrec`. Se aplicada a uma fun\u00E7\u00E3o, indica que a recurs\u00E3o dessa fun\u00E7\u00E3o \u00E9 de cauda. Se voc\u00EA aplicar esse modificador na primeira vers\u00E3o, por exemplo, ter\u00E1 um erro, assim como o uso do `recur` em Clojure.\\n\\n### Haskell\\n\\n```haskell\\n-- Implementa\u00E7\u00E3o sem tail call optimization\\nfactorial :: (Integral a) => a -> a\\nfatorial 0 = 1\\nfactorial n = n * factorial (n - 1)\\n```\\n\\n```haskell\\n-- Implementa\u00E7\u00E3o com tail call optimization\\nfactorial :: (Integral a) => a -> a -> a\\nfatorial 0 p = p\\nfactorial n p = factorial (n - 1) (p * n)\\n```\\n\\n### Elixir\\n\\nRecentemente, eu escrevi um post sobre [casamento de padr\u00F5es com Elixir](/casamento-de-padroes-em-elixir/). No final dele tem esse exemplo de fatorial usando casamento de padr\u00F5es e recurs\u00E3o de cauda. Ela tamb\u00E9m deixa p\u00FAblica apenas a chamada da fun\u00E7\u00E3o com um argumento, mantendo a vers\u00E3o com o acumulador privada.\\n\\n```elixir\\ndefmodule Math do\\n  def factorial(number) do\\n    factorial(number, 1)\\n  end\\n\\n  defp factorial(0, current_product) do\\n    current_product\\n  end\\n\\n  defp factorial(number, current_product) do\\n    factorial(number - 1, number * current_product)\\n  end\\nend\\n```\\n\\n## Eu posso usar recurs\u00E3o de cauda na minha linguagem favorita?\\n\\n**Depende de qual \u00E9 ela.**\\n\\nN\u00E3o coincidentemente, os tr\u00EAs exemplos de linguagens que suportam otimiza\u00E7\u00E3o de chamada de cauda que eu trouxe s\u00E3o **linguagens funcionais**. Normalmente, programa\u00E7\u00E3o funcional utiliza recurs\u00E3o com uma frequ\u00EAncia superior a itera\u00E7\u00E3o, e linguagens funcionais t\u00EAm essa preocupa\u00E7\u00E3o com performance e limita\u00E7\u00F5es de mem\u00F3ria. \\n\\nA Wikip\u00E9dia tem uma [lista com algumas linguagens que suportam essa otimiza\u00E7\u00E3o](https://en.wikipedia.org/wiki/Tail_call#By_language). Voc\u00EA vai ver que, em maioria, s\u00E3o linguagens funcionais. Se essa maneira de pensar te interessou, e voc\u00EA nunca aprendeu uma linguagem funcional, **que tal experimentar?** Se aceita uma sugest\u00E3o, d\u00E1 uma olhada em [Clojure](https://www.braveclojure.com/clojure-for-the-brave-and-true/) ou [Elixir](https://elixir-lang.org/getting-started/introduction.html)!\\n\",\"readingTime\":10,\"summary\":\"Quando precisamos realizar uma opera\u00E7\u00E3o v\u00E1rias vezes, geralmente existem duas maneiras: iterativa e recursiva. Iterativa \u00E9 quando utilizamos alguma estrutura de la\u00E7o, como um `for` ou `while`, com uma vari\u00E1vel de controle para saber quando parar. Recursiva \u00E9 quando uma fun\u00E7\u00E3o decide **executar a si mesma** por entender que ainda precisa continuar processando. Toda itera\u00E7\u00E3o pode ser escrita como uma recurs\u00E3o e vice-versa. Recurs\u00F5es por\u00E9m tem um risco associado: o **estouro da pilha**. Vamos entender o que isso significa e como escrever c\u00F3digo recursivo evitando esse problema!\\n\\n\"}},\"path\":\"recursao-de-causa-ou-como-nao-estourar-a-pilha\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/vendors~__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.207edc50.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.a04ea84b.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/post.d8dd52db.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.272ae1d1.js"></script><script defer="" type="text/javascript" src="/main.f19d4c14.js"></script></body></html>