<!DOCTYPE html><html lang="pt-BR" class=" "><head><meta name="generator" content="React Static"/><title data-react-helmet="true">Recurs√£o de cauda ‚Äî ou como n√£o estourar a pilha ¬∑ Cisne.dev blog</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:creator" content="Cisneiros"/><meta data-react-helmet="true" property="og:title" content="Recurs√£o de cauda ‚Äî ou como n√£o estourar a pilha ¬∑ Cisne.dev blog"/><meta data-react-helmet="true" property="og:image" content="https://blog.cisne.dev/recursao-de-causa-ou-como-nao-estourar-a-pilha/social-image.png"/><meta data-react-helmet="true" name="twitter:title" content="Recurs√£o de cauda ‚Äî ou como n√£o estourar a pilha ¬∑ Cisne.dev blog"/><meta data-react-helmet="true" name="twitter:image" content="https://blog.cisne.dev/recursao-de-causa-ou-como-nao-estourar-a-pilha/social-image.png"/><link rel="preload" as="script" href="/templates/vendors~__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.207edc50.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.a04ea84b.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/post.d8dd52db.js"/><link rel="preload" as="script" href="/templates/vendors~main.272ae1d1.js"/><link rel="preload" as="script" href="/main.f19d4c14.js"/><link data-react-helmet="true" rel="stylesheet" href="//unpkg.com/dracula-prism/dist/css/dracula-prism.min.css"/><style data-styled="" data-styled-version="5.1.1">.CfxHf{max-width:960px;margin:0 auto;position:relative;}/*!sc*/
data-styled.g1[id="ui__Fit-prwz6b-0"]{content:"CfxHf,"}/*!sc*/
.iuDFSN{padding:1rem;color:var(--color-mid);text-align:center;font-size:1.5rem;}/*!sc*/
.iuDFSN a,.iuDFSN a:hover{-webkit-text-decoration:none;text-decoration:none;color:inherit;}/*!sc*/
data-styled.g2[id="Navigation__Container-sc-1yk0pqp-0"]{content:"iuDFSN,"}/*!sc*/
.izuwCZ{max-width:960px;margin:0 auto;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
data-styled.g3[id="Navigation__NavFit-sc-1yk0pqp-1"]{content:"izuwCZ,"}/*!sc*/
.TctaC{width:2.5rem;height:1.2em;overflow:hidden;--default-rotation:-180deg;}/*!sc*/
@media (prefers-color-scheme:dark){.TctaC{--default-rotation:0;}}/*!sc*/
data-styled.g4[id="Navigation__BrightnessContainer-sc-1yk0pqp-2"]{content:"TctaC,"}/*!sc*/
.sLeDt{-webkit-transform:rotate(var(--default-rotation));-ms-transform:rotate(var(--default-rotation));transform:rotate(var(--default-rotation));-webkit-transition:-webkit-transform 0.3s ease-out;-webkit-transition:transform 0.3s ease-out;transition:transform 0.3s ease-out;}/*!sc*/
html.light .sLeDt{-webkit-transform:rotate(-180deg);-ms-transform:rotate(-180deg);transform:rotate(-180deg);}/*!sc*/
html.dark .sLeDt{-webkit-transform:rotate(0);-ms-transform:rotate(0);transform:rotate(0);}/*!sc*/
data-styled.g5[id="Navigation__BrightnessSpinner-sc-1yk0pqp-3"]{content:"sLeDt,"}/*!sc*/
.frsARl{background:none;border:none;cursor:pointer;}/*!sc*/
.frsARl:last-child{-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg);}/*!sc*/
data-styled.g7[id="Navigation__BrightnessIcon-sc-1yk0pqp-5"]{content:"frsARl,"}/*!sc*/
.gdHjSq{margin-top:3rem;padding:1rem;background:var(--color-foreground);color:var(--color-background);}/*!sc*/
.gdHjSq a{color:var(--text-inverse-color-1);}/*!sc*/
.gdHjSq a:hover{color:var(--text-inverse-color-3);}/*!sc*/
data-styled.g8[id="Footer__Container-b3q04c-0"]{content:"gdHjSq,"}/*!sc*/
.layJcq{max-width:960px;margin:0 auto;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
data-styled.g9[id="Footer__FooterFit-b3q04c-1"]{content:"layJcq,"}/*!sc*/
*{box-sizing:border-box;margin:0;padding:0;border:0;font-size:inherit;font-weight:inherit;font-style:inherit;}/*!sc*/
:root{--color-1:#12c2e9;--color-2:#c471ed;--color-3:#f64f59;--color-1-darker:#0A7B94;--color-2-darker:#AE3CE7;--color-3-darker:#E90C1B;--color-light:#fefefe;--color-dark:#030303;--color-mid-dark:#747481;--color-mid-light:#818181;--font-weight-light:300;--font-weight-regular:400;--font-weight-heavy:500;--font-family-light:"HelveticaNeue-Light","Helvetica Neue Light",'Helvetica Neue',sans-serif;--font-family:'Helvetica Neue',sans-serif;}/*!sc*/
strong,h1,h2,h3,h4,h5,h6{font-family:var(--font-family);}/*!sc*/
html{font-family:var(--font-family-light);font-size:20px;line-height:1;color:var(--color-foreground);background-color:var(--color-background);text-rendering:optimizeLegibility;}/*!sc*/
@media (max-width:600px){html{font-size:16px;}}/*!sc*/
html,html.light{--color-background:var(--color-light);--color-foreground:var(--color-dark);--color-mid:var(--color-mid-dark);--text-color-1:var(--color-1-darker);--text-color-2:var(--color-2-darker);--text-color-3:var(--color-3-darker);--text-inverse-color-1:var(--color-1);--text-inverse-color-2:var(--color-2);--text-inverse-color-3:var(--color-3);}/*!sc*/
html.dark{--color-background:var(--color-dark);--color-foreground:var(--color-light);--color-mid:var(--color-mid-light);--text-color-1:var(--color-1);--text-color-2:var(--color-2);--text-color-3:var(--color-3);--text-inverse-color-1:var(--color-1-darker);--text-inverse-color-2:var(--color-2-darker);--text-inverse-color-3:var(--color-3-darker);}/*!sc*/
@media (prefers-color-scheme:dark){html{--color-background:var(--color-dark);--color-foreground:var(--color-light);--color-mid:var(--color-mid-light);}}/*!sc*/
body{font-size:1em;font-weight:var(--font-weight-light);}/*!sc*/
strong{font-weight:var(--font-weight-heavy);}/*!sc*/
em{font-style:italic;}/*!sc*/
main{padding:1rem;}/*!sc*/
hr{width:30%;margin:4rem auto;border:none;border-bottom:dotted 1px var(--color-1);}/*!sc*/
.pagination{text-align:center;}/*!sc*/
.pagination a{color:var(--text-color-1);}/*!sc*/
.pagination a:hover{color:var(--text-color-3);}/*!sc*/
a{color:var(--text-color-1);-webkit-text-decoration-color:#c471ed80;text-decoration-color:#c471ed80;-webkit-text-decoration-style:wavy;text-decoration-style:wavy;}/*!sc*/
a:hover{color:var(--text-color-3);-webkit-text-decoration-color:#12c2e980;text-decoration-color:#12c2e980;}/*!sc*/
.phone-mockup{max-width:15rem;margin:0 auto 1rem;position:relative;}/*!sc*/
.phone-mockup::before{content:'';width:100%;height:100%;position:absolute;pointer-events:none;background:url(/iphone-11-pro.png) no-repeat;background-size:contain;}/*!sc*/
.phone-mockup video,.phone-mockup img{width:100%;padding:9.3%;}/*!sc*/
data-styled.g14[id="sc-global-hFBrmQ1"]{content:"sc-global-hFBrmQ1,"}/*!sc*/
.tuaWG{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}/*!sc*/
@media (max-width:600px){.tuaWG{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}/*!sc*/
data-styled.g23[id="Poststyles__AfterPost-sc-12qb97v-0"]{content:"tuaWG,"}/*!sc*/
.gkeqUt{-webkit-flex:1;-ms-flex:1;flex:1;}/*!sc*/
@media (max-width:600px){.gkeqUt{text-align:center;margin-bottom:1rem;}}/*!sc*/
data-styled.g24[id="Poststyles__AfterPostChild-sc-12qb97v-1"]{content:"gkeqUt,"}/*!sc*/
.fAvgXR{-webkit-flex:1;-ms-flex:1;flex:1;text-align:right;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
@media (max-width:600px){.fAvgXR{text-align:center;margin-bottom:1rem;}}/*!sc*/
data-styled.g25[id="Poststyles__Tags-sc-12qb97v-2"]{content:"fAvgXR,"}/*!sc*/
.kSZCZX::before{content:' #';color:var(--color-mid);}/*!sc*/
data-styled.g26[id="Poststyles__Tag-sc-12qb97v-3"]{content:"kSZCZX,"}/*!sc*/
.kyWzPB{-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;hyphens:auto;}/*!sc*/
data-styled.g27[id="Poststyles__Container-sc-12qb97v-4"]{content:"kyWzPB,"}/*!sc*/
.hhBwVH{font-size:5rem;font-weight:var(--font-weight-regular);line-height:0.8;background:linear-gradient(var(--color-1),var(--color-2),var(--color-3));-webkit-text-fill-color:transparent;background-clip:text;-webkit-background-clip:text;padding-bottom:1rem;margin:1rem 0;}/*!sc*/
html.rainbow .hhBwVH{background-image:linear-gradient(124deg,#ff2400,#e81d1d,#e8b71d,#e3e81d,#1de840,#1ddde8,#2b1de8,#dd00f3,#dd00f3);-webkit-animation:hTUzwZ 9s ease infinite;animation:hTUzwZ 9s ease infinite;background-size:450% 450%;}/*!sc*/
@media (max-width:600px){.hhBwVH{font-size:3.5rem;}}/*!sc*/
.hhBwVH a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g28[id="Poststyles__Title-sc-12qb97v-5"]{content:"hhBwVH,"}/*!sc*/
.fonWHZ{color:var(--color-mid);text-align:center;margin-bottom:2rem;}/*!sc*/
data-styled.g29[id="Poststyles__Meta-sc-12qb97v-6"]{content:"fonWHZ,"}/*!sc*/
.jhgzPU{line-height:1.6;}/*!sc*/
.jhgzPU h2{font-size:2.5rem;}/*!sc*/
.jhgzPU h3{font-size:2rem;}/*!sc*/
.jhgzPU h4{font-size:1.5rem;}/*!sc*/
.jhgzPU h2,.jhgzPU h3,.jhgzPU h4,.jhgzPU h5,.jhgzPU h6{-webkit-hyphens:auto;-moz-hyphens:auto;-ms-hyphens:auto;hyphens:auto;font-weight:var(--font-weight-regular);line-height:0.8;padding-bottom:1rem;margin-top:2rem;}/*!sc*/
.jhgzPU img{max-width:100%;}/*!sc*/
.jhgzPU pre.refractor{margin-top:0;margin-left:0;padding-left:1rem;border-left:solid 0.25rem var(--color-1);border-radius:0;font-size:0.8rem;overflow-wrap:normal;overflow-x:auto;background-color:var(--color-dark);color:var(--color-light);padding-top:0.5rem;padding-bottom:0.5rem;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
.jhgzPU pre.refractor::-webkit-scrollbar{width:0.25rem;height:0.25rem;}/*!sc*/
.jhgzPU pre.refractor code,.jhgzPU code{font-family:'Fira Code','Menlo',monospace;}/*!sc*/
.jhgzPU p code{color:var(--text-color-3);}/*!sc*/
.jhgzPU p code,.jhgzPU h1 code,.jhgzPU h2 code,.jhgzPU h3 code,.jhgzPU h4 code,.jhgzPU h5 code,.jhgzPU h6 code{font-size:0.9em;}/*!sc*/
.jhgzPU p,.jhgzPU pre,.jhgzPU ul,.jhgzPU ol,.jhgzPU table,.jhgzPU blockquote,.jhgzPU .live-code-container{margin-bottom:1rem;}/*!sc*/
.jhgzPU twitter-widget{margin-bottom:1rem !important;}/*!sc*/
.jhgzPU p:last-child,.jhgzPU pre:last-child,.jhgzPU ul:last-child,.jhgzPU ol:last-child,.jhgzPU table:last-child,.jhgzPU blockquote:last-child,.jhgzPU .live-code-container:last-child{margin-bottom:0;}/*!sc*/
.jhgzPU ul,.jhgzPU ol{list-style:none;margin-left:1rem;counter-reset:li;}/*!sc*/
.jhgzPU li{counter-increment:li;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}/*!sc*/
.jhgzPU ul li::before{content:'‚Ä¢';margin-right:0.5rem;color:var(--color-2);}/*!sc*/
.jhgzPU ol li::before{content:"."counter(li);margin-right:0.5rem;color:var(--color-2);font-weight:var(--font-weight-regular);width:1em;display:inline-block;margin-left:-0.5em;margin-right:0.5em;text-align:right;direction:rtl;}/*!sc*/
.jhgzPU table{margin-left:auto;margin-right:auto;border-spacing:0;font-size:0.9em;}/*!sc*/
.jhgzPU td,.jhgzPU th{border-bottom:solid 1px var(--color-2);padding:0.5rem;}/*!sc*/
.jhgzPU th{font-weight:var(--font-weight-heavy);}/*!sc*/
.jhgzPU tr:hover{background:var(--color-2);}/*!sc*/
.jhgzPU tr:last-of-type td{border-bottom:0;}/*!sc*/
.jhgzPU blockquote{padding-left:1rem;border-left:solid 0.25rem var(--color-3);color:var(--color-mid);}/*!sc*/
data-styled.g30[id="Poststyles__Content-sc-12qb97v-7"]{content:"jhgzPU,"}/*!sc*/
.jjKdZc{position:fixed;top:0;left:0;right:0;height:0.25rem;background-color:var(--color-1);-webkit-transition:opacity 0.25s ease-out;transition:opacity 0.25s ease-out;z-index:2;}/*!sc*/
data-styled.g31[id="post__ScrollTrackerContainer-gh0jqu-0"]{content:"jjKdZc,"}/*!sc*/
@-webkit-keyframes hTUzwZ{0%{background-position:0% 82%;}50%{background-position:100% 19%;}100%{background-position:0% 82%;}}/*!sc*/
@keyframes hTUzwZ{0%{background-position:0% 82%;}50%{background-position:100% 19%;}100%{background-position:0% 82%;}}/*!sc*/
data-styled.g32[id="sc-keyframes-hTUzwZ"]{content:"hTUzwZ,"}/*!sc*/
</style><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feed.xml"/></head><body><div id="root"><nav class="Navigation__Container-sc-1yk0pqp-0 iuDFSN"><div class="ui__Fit-prwz6b-0 Navigation__NavFit-sc-1yk0pqp-1 izuwCZ"><p class="logo"><a href="/">Cisne.dev blog</a></p><div class="Navigation__BrightnessContainer-sc-1yk0pqp-2 TctaC"><div class="Navigation__BrightnessSpinner-sc-1yk0pqp-3 sLeDt"><button title="Mudar para modo diurno" aria-label="Mudar para modo diurno" class="Navigation__ClearButton-sc-1yk0pqp-4 Navigation__BrightnessIcon-sc-1yk0pqp-5 frsARl">üåô</button><button title="Mudar para modo noturno" aria-label="Mudar para modo noturno" class="Navigation__ClearButton-sc-1yk0pqp-4 Navigation__BrightnessIcon-sc-1yk0pqp-5 frsARl">‚òÄÔ∏è</button></div></div></div></nav><main><div class="ui__Fit-prwz6b-0 CfxHf"><div><div style="width:0%;opacity:0" class="post__ScrollTrackerContainer-gh0jqu-0 jjKdZc"></div><article class="Poststyles__Container-sc-12qb97v-4 kyWzPB"><h1 class="Poststyles__Title-sc-12qb97v-5 hhBwVH"><a href="/recursao-de-causa-ou-como-nao-estourar-a-pilha/">Recurs√£o de cauda ‚Äî ou como n√£o estourar a pilha</a></h1><p class="Poststyles__Meta-sc-12qb97v-6 fonWHZ">Publicado em <!-- -->13 nov 2020<!-- -->. Uns <!-- -->10<!-- --> minutos de leitura.</p><div class="Poststyles__Content-sc-12qb97v-7 jhgzPU content"><p>Quando precisamos realizar uma opera√ß√£o v√°rias vezes, geralmente existem duas maneiras: iterativa e recursiva. Iterativa √© quando utilizamos alguma estrutura de la√ßo, como um <code>for</code> ou <code>while</code>, com uma vari√°vel de controle para saber quando parar. Recursiva √© quando uma fun√ß√£o decide <strong>executar a si mesma</strong> por entender que ainda precisa continuar processando. Toda itera√ß√£o pode ser escrita como uma recurs√£o e vice-versa. Recurs√µes por√©m tem um risco associado: o <strong>estouro da pilha</strong>. Vamos entender o que isso significa e como escrever c√≥digo recursivo evitando esse problema!</p><span><!-- summary-break --></span><h2>O que √© essa pilha?</h2><p>Antes de mais nada, o que √© <strong>a pilha</strong>? Neste contexto, n√£o estamos falando de uma bateria üîã, mas de uma estrutura de dados em que podemos <strong>empilhar</strong> informa√ß√£o ü•û. Sempre que executamos uma fun√ß√£o, n√≥s estamos movendo a execu√ß√£o do c√≥digo de um ponto para o outro. Quando a fun√ß√£o que chamamos termina, precisamos voltar para onde est√°vamos com o resultado e continuar a execu√ß√£o. Por isso, quando chamamos uma fun√ß√£o, o ambiente de execu√ß√£o vai guardar <strong>o estado atual de execu√ß√£o</strong> em algum lugar para que possamos retornar para ele depois. Diferentes linguagens de programa√ß√£o v√£o ter diferentes ambientes de execu√ß√£o, mas o conceito √© parecido entre elas.</p><p>Cada chamada de fun√ß√£o adiciona esse contexto numa pilha (em ingl√™s, <em>stack</em>). Usa-se uma pilha pois, se n√≥s executamos a fun√ß√£o A, que chama a fun√ß√£o B, que chama C (nessa ordem), ao final de C n√≥s queremos retornar para B e, ao final de B, n√≥s queremos retornar para A. Assim, vamos empilhando as chamadas aninhadas (chamadas dentro de chamadas) e desempilhando nos retornos. Cada contexto desse adicionado na pilha √© chamado de <strong>quadro</strong> (<em>stack frame</em>) e ocupa <strong>espa√ßo em mem√≥ria</strong>.</p><p>Mem√≥ria n√£o √© infinita, e cada ambiente de execu√ß√£o de c√≥digo vai definir um limite para o qu√£o profunda uma pilha de chamadas de fun√ß√£o pode ser. Se esse tamanho for, por exemplo, 1000, significa que voc√™ pode ter no m√°ximo 1000 n√≠veis de fun√ß√µes chamando umas as outras sem retornar, de acordo com o que a fun√ß√£o precisar guardar na pilha. Se voc√™ tentar chamar mais uma fun√ß√£o aninhada, voc√™ vai ter um <strong>estouro da pilha</strong>, de onde vem o nome do <em>Stack Overflow</em>.</p><h2>O que isso tem a ver com recurs√£o?</h2><p>√â dif√≠cil imaginar escrever 1000 fun√ß√µes de maneira que uma chame a outra, consequentemente ultrapassando esse limite. Afinal de contas, voc√™ vai ter o limite da pr√≥pria quantidade de c√≥digo que voc√™ escreve. Por√©m, existe algo bem mais r√°pido e capaz do que n√≥s, humanos: <strong>computadores</strong>. E a√≠ que entra recurs√£o.</p><p>Imagine o seguinte cen√°rio, em JavaScript. Note que estou colocando um <code>n</code> ao final dos n√∫meros. Essa √© a sintaxe para <code>BigInt</code> em JS, que s√£o n√∫meros arbitrariamente grandes. O exemplo a seguir faz conta com n√∫mero muito grandes e, se usarmos n√∫meros padr√µes de JavaScript, chegar√≠amos em <code>Infinity</code> eventualmente.</p><pre class="refractor language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1n</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> number <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Temos uma fun√ß√£o recursiva que calcula o <strong>fatorial de um n√∫mero</strong> (o produto de todos os n√∫meros entre 1 e este n√∫mero). Ela √© recursiva pois tem um <strong>caso base</strong> (se <code>number</code> for igual a zero) em que ela apenas retorna algo e um <strong>caso recursivo</strong> (se <code>number</code> n√£o for igual a zero), em que ela faz algo e <strong>chama a si mesma com outro argumento</strong>.</p><pre class="refractor language-js"><code class="language-js"><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">10n</span><span class="token punctuation">)</span> <span class="token comment">// Resultado: 3628800n</span></code></pre><p>Essa fun√ß√£o vai precisar usar a pilha <code>number</code> vezes, pois cada execu√ß√£o dela precisa chamar uma fun√ß√£o (ela mesma) <strong>antes de poder retornar</strong>. Ou seja, quando eu chamo <code>factorial(10)</code>, essa fun√ß√£o retornar <code>10 * factorial(9)</code>. Mas ela n√£o consegue retornar ainda, pois tem uma chamada de fun√ß√£o n√£o resolvida. Ela precisa esperar <code>factorial(9)</code> retornar para <strong>depois</strong> poder multiplicar por 10, e assim retornar tamb√©m. Isso acontece sucessivamente at√© chegar em <code>factorial(0)</code>, que retorna apenas <code>1</code>. A partir da√≠, os contextos de execu√ß√£o das fun√ß√µes v√£o sendo <strong>desempilhados</strong>, passando pelo <code>factorial(1)</code> (que aguardava o resultado do <code>factorial(0)</code>), depois <code>factorial(2)</code>, e assim at√© voltar para o original, <code>factorial(10)</code>.</p><p>Se a entrada dessa fun√ß√£o se tornar muito grande, vamos precisar fazer um n√∫mero de chamadas de fun√ß√£o, uma dentro da outra, que pode precisar guardar mais informa√ß√£o na pilha do que ela suporta, causando um estouro da pilha. Nos meus testes, rodando em Node.js, <code>factorial(10948n)</code> foi o ponto em que a pilha estouraria. Ao tentar executar essa fun√ß√£o, eu recebi a mensagem: <strong>Uncaught RangeError: Maximum call stack size exceeded</strong>.</p><p>O motivo de precisarmos guardar informa√ß√£o na pilha de chamadas de fun√ß√£o √© que <strong>essa fun√ß√£o precisa fazer algo com o resultado da chamada recursiva</strong>. Mais especificamente, olhando para essa linha dentro do <code>else</code>:</p><pre class="refractor language-js"><code class="language-js">    <span class="token keyword">return</span> number <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">)</span></code></pre><p>A fun√ß√£o precisa que a chamada recursiva retorne <strong>para depois</strong> conseguir fazer a multiplica√ß√£o. Para visualizar, vamos diminuir a entrada para <code>5n</code>. A execu√ß√£o aconteceria, passo a passo, assim:</p><pre class="refractor language-js"><code class="language-js"><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">3n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">2n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">1n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span> <span class="token operator">*</span> <span class="token number">1n</span> <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">0n</span><span class="token punctuation">)</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span> <span class="token operator">*</span> <span class="token number">1n</span> <span class="token operator">*</span> <span class="token number">1n</span> <span class="token comment">// Chegamos no caso base</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span> <span class="token operator">*</span> <span class="token number">1n</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">3n</span> <span class="token operator">*</span> <span class="token number">2n</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">4n</span> <span class="token operator">*</span> <span class="token number">6n</span>
<span class="token number">5n</span> <span class="token operator">*</span> <span class="token number">24n</span>
<span class="token number">120n</span></code></pre><p>√â a√≠ que entra o conceito de <strong>recurs√£o de cauda</strong>, ou <strong>otimiza√ß√£o de chamada de cauda</strong> (<em>tail call optimization</em>).</p><h2>Como fazer essa recurs√£o n√£o estourar?</h2><p>Algumas linguagens de programa√ß√£o conseguem identificar chamadas de fun√ß√µes que <strong>n√£o precisam guardar contexto na pilha</strong>. Quando isso acontece, √© poss√≠vel ter uma recurs√£o que, independentemente da profundidade, n√£o vai causar um estouro da pilha.</p><p><strong>Infelizmente, JavaScript n√£o √© uma delas.</strong> As implementa√ß√µes atuais n√£o suportam esse tipo de otimiza√ß√£o. Para fins ilustrativos, vamos rever como seria o exemplo acima se JavaScript tivesse suporte a recurs√£o de cauda. Depois, vamos ver o mesmo exemplo em <strong>linguagens que de fato suportam</strong>.</p><p>Vamos re-escrever a fun√ß√£o do fatorial de maneira que <strong>ela n√£o precise esperar pelo retorno da recurs√£o para retornar</strong>. O segredo est√° em fazer com que, em todos os poss√≠veis caminhos para o c√≥digo, n√≥s retornemos apenas <strong>valores</strong> ou <strong>a pr√≥pria chamada recursiva</strong>.</p><pre class="refractor language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">number<span class="token punctuation">,</span> product</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> product
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">,</span> product <span class="token operator">*</span> number<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>A fun√ß√£o acima tem dois caminhos poss√≠veis de execu√ß√£o. O primeiro caminho, se <code>number</code> for zero, retorna apenas um valor (a vari√°vel <code>product</code>). O segundo, se <code>number</code> n√£o for zero, √© o que modificamos. Ao inv√©s de retornar o valor atual multiplicado pelo retorno da recurs√£o, n√≥s <strong>calculamos a multiplica√ß√£o primeiro</strong> e s√≥ depois fazemos a chamada recursiva.</p><p>Para isso, introduzimos um segundo argumento a essa fun√ß√£o, o <code>product</code>. Ele funciona aqui como um <strong>acumulador</strong>, que guarda o resultado intermedi√°rio. Esse acumulador vai guardando cada multiplica√ß√£o e √© retornado no caso base, quando chegamos no fim da recurs√£o. Como n√≥s passamos esse resultado intermedi√°rio na chamada recursiva, nosso <code>return</code> <strong>n√£o faz nada com o resultado da recurs√£o</strong>, apenas retorna-o diretamente. O interpretador do JavaScript poderia perceber isso e <strong>n√£o guardar nada na pilha</strong>. </p><p>Vamos ver como ficaria a sequ√™ncia de execu√ß√£o dessa nova fun√ß√£o. Note que, como ela tem um acumulador (segundo par√¢metro), precisamos passar algum <strong>valor inicial</strong> para esse par√¢metro. Como √© uma multiplica√ß√£o, podemos passar <code>1n</code> (pois 1 n√£o afeta um produto).</p><pre class="refractor language-js"><code class="language-js"><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5n</span><span class="token punctuation">,</span> <span class="token number">1n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4n</span><span class="token punctuation">,</span> <span class="token number">5n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">3n</span><span class="token punctuation">,</span> <span class="token number">20n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">2n</span><span class="token punctuation">,</span> <span class="token number">60n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">1n</span><span class="token punctuation">,</span> <span class="token number">120n</span><span class="token punctuation">)</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">0n</span><span class="token punctuation">,</span> <span class="token number">120n</span><span class="token punctuation">)</span>
<span class="token number">120n</span></code></pre><p>Sobre esse segundo argumento, idealmente n√£o gostar√≠amos que fosse necess√°rio pass√°-lo para come√ßar a calcular. Para isso, podemos separar a implementa√ß√£o da fun√ß√£o da API p√∫blica, assim:</p><pre class="refractor language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">factorialImplementation</span><span class="token punctuation">(</span><span class="token parameter">number<span class="token punctuation">,</span> product</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> product
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">factorialImplementation</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1n</span><span class="token punctuation">,</span> product <span class="token operator">*</span> number<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// A fun√ß√£o que exportamos publicamente apenas tem um argumento</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">factorialImplementation</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> <span class="token number">1n</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>Assim, nossa fun√ß√£o <code>factorial</code> s√≥ recebe um argumento. Alternativamente, poder√≠amos colocar um valor padr√£o para o segundo argumento (mas isso permitiria chamar a fun√ß√£o passando um segundo argumento errado, ainda assim).</p><h2>Exemplos em linguagens que suportam otimiza√ß√£o de chamadas de cauda</h2><p>Como eu comentei, <strong>infelizmente JavaScript n√£o tem suporte</strong> a n√£o adicionar contexto na pilha caso n√£o seja necess√°rio. Toda chamada de fun√ß√£o vai colocar algo na pilha e, eventualmente, uma recurs√£o causa um estouro.</p><p>Vamos rever o exemplo do fatorial em algumas linguagens que t√™m suporte a essa otimiza√ß√£o.</p><h3>Clojure</h3><pre class="refractor language-js"><code class="language-js"><span class="token punctuation">(</span>defn factorial
  <span class="token string">&quot;Implementa√ß√£o sem tail call optimization&quot;</span>
  <span class="token punctuation">[</span>number<span class="token punctuation">]</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>zero<span class="token operator">?</span> number<span class="token punctuation">)</span>
    <span class="token number">1</span>
    <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token function">number</span> <span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token punctuation">(</span>dec number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class="refractor language-js"><code class="language-js"><span class="token punctuation">(</span>defn factorial
  <span class="token string">&quot;Implementa√ß√£o com tail call optimization&quot;</span>
  <span class="token punctuation">[</span>number product<span class="token punctuation">]</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>zero<span class="token operator">?</span> number<span class="token punctuation">)</span>
    <span class="token function">product</span>
    <span class="token punctuation">(</span><span class="token function">recur</span> <span class="token punctuation">(</span>dec number<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> product number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Note que, em Clojure, existe uma forma especial para recurs√£o de cauda: <code>recur</code>. Usamos <code>recur</code> no lugar do nome da fun√ß√£o, para executar uma chamada recursiva. Se voc√™ tentar usar <code>recur</code> num contexto que ele n√£o seja a √∫ltima execu√ß√£o de um caminho da execu√ß√£o de c√≥digo, vai receber um erro. Se voc√™ tentar escrever recurs√µes sempre com <code>recur</code>, voc√™ tem a garantia de fazer uma recurs√£o de cauda (pois o compilador n√£o vai deixar voc√™ n√£o o fazer).</p><h3>Kotlin</h3><pre class="refractor language-js"><code class="language-js"><span class="token comment">// Implementa√ß√£o sem tail call optimization</span>
fun <span class="token function">factorial</span><span class="token punctuation">(</span>number<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token operator">:</span> Long <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token number">1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        number <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><pre class="refractor language-js"><code class="language-js"><span class="token comment">// Implementa√ß√£o com tail call optimization</span>
tailrec fun <span class="token function">factorial</span><span class="token punctuation">(</span>number<span class="token operator">:</span> Long<span class="token punctuation">,</span> product<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token operator">:</span> Long <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        product
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">factorial</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> product <span class="token operator">*</span> number<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Kotlin possui a palavra-chave <code>tailrec</code>. Se aplicada a uma fun√ß√£o, indica que a recurs√£o dessa fun√ß√£o √© de cauda. Se voc√™ aplicar esse modificador na primeira vers√£o, por exemplo, ter√° um erro, assim como o uso do <code>recur</code> em Clojure.</p><h3>Haskell</h3><pre class="refractor language-js"><code class="language-js"><span class="token operator">--</span> Implementa√ß√£o sem tail call optimization
factorial <span class="token operator">:</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">Integral a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span><span class="token operator">&gt;</span> a
fatorial <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1</span>
factorial n <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token function">factorial</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><pre class="refractor language-js"><code class="language-js"><span class="token operator">--</span> Implementa√ß√£o com tail call optimization
factorial <span class="token operator">:</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">Integral a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span><span class="token operator">&gt;</span> a <span class="token operator">-</span><span class="token operator">&gt;</span> a
fatorial <span class="token number">0</span> p <span class="token operator">=</span> p
factorial n p <span class="token operator">=</span> <span class="token function">factorial</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>p <span class="token operator">*</span> n<span class="token punctuation">)</span></code></pre><h3>Elixir</h3><p>Recentemente, eu escrevi um post sobre <a href="/casamento-de-padroes-em-elixir/">casamento de padr√µes com Elixir</a>. No final dele tem esse exemplo de fatorial usando casamento de padr√µes e recurs√£o de cauda. Ela tamb√©m deixa p√∫blica apenas a chamada da fun√ß√£o com um argumento, mantendo a vers√£o com o acumulador privada.</p><pre class="refractor language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> Math <span class="token keyword">do</span>
  <span class="token keyword">def</span> factorial<span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token keyword">do</span>
    factorial<span class="token punctuation">(</span>number<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> factorial<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> current_product<span class="token punctuation">)</span> <span class="token keyword">do</span>
    current_product
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> factorial<span class="token punctuation">(</span>number<span class="token punctuation">,</span> current_product<span class="token punctuation">)</span> <span class="token keyword">do</span>
    factorial<span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> number <span class="token operator">*</span> current_product<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span></code></pre><h2>Eu posso usar recurs√£o de cauda na minha linguagem favorita?</h2><p><strong>Depende de qual √© ela.</strong></p><p>N√£o coincidentemente, os tr√™s exemplos de linguagens que suportam otimiza√ß√£o de chamada de cauda que eu trouxe s√£o <strong>linguagens funcionais</strong>. Normalmente, programa√ß√£o funcional utiliza recurs√£o com uma frequ√™ncia superior a itera√ß√£o, e linguagens funcionais t√™m essa preocupa√ß√£o com performance e limita√ß√µes de mem√≥ria. </p><p>A Wikip√©dia tem uma <a href="https://en.wikipedia.org/wiki/Tail_call#By_language">lista com algumas linguagens que suportam essa otimiza√ß√£o</a>. Voc√™ vai ver que, em maioria, s√£o linguagens funcionais. Se essa maneira de pensar te interessou, e voc√™ nunca aprendeu uma linguagem funcional, <strong>que tal experimentar?</strong> Se aceita uma sugest√£o, d√° uma olhada em <a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/">Clojure</a> ou <a href="https://elixir-lang.org/getting-started/introduction.html">Elixir</a>!</p></div><hr/><div class="Poststyles__AfterPost-sc-12qb97v-0 tuaWG"><p class="Poststyles__AfterPostChild-sc-12qb97v-1 gkeqUt">Gostou? <a href="https://twitter.com/intent/tweet?text=%22Recurs%C3%A3o%20de%20cauda%20%E2%80%94%20ou%20como%20n%C3%A3o%20estourar%20a%20pilha%22%20por%20%40Cisneiros%0A%0Ahttps%3A%2F%2Fblog.cisne.dev%2Frecursao-de-causa-ou-como-nao-estourar-a-pilha" target="_blank" rel="noopener noreferrer">Que tal compartilhar?</a></p><p class="Poststyles__AfterPostChild-sc-12qb97v-1 Poststyles__Tags-sc-12qb97v-2 fAvgXR">Tags: <span class="Poststyles__Tag-sc-12qb97v-3 kSZCZX"><a href="/tag/conceitos">conceitos</a></span></p></div></article></div></div></main><footer class="Footer__Container-b3q04c-0 gdHjSq"><div class="ui__Fit-prwz6b-0 Footer__FooterFit-b3q04c-1 layJcq"><p>¬© <a href="https://cisne.dev">Alexandre Cisneiros</a></p><p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a></p></div></footer></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/src/containers/post\",\"sharedHashesByProp\":{},\"data\":{\"postData\":{\"title\":\"Recurs\u00E3o de cauda \u2014 ou como n\u00E3o estourar a pilha\",\"date\":\"2020-11-13T00:00:00-03:00\",\"slug\":\"recursao-de-causa-ou-como-nao-estourar-a-pilha\",\"tags\":[\"conceitos\"],\"filePath\":\"2020-11-13-recursao-de-causa-ou-como-nao-estourar-a-pilha.md\",\"content\":\"Quando precisamos realizar uma opera\u00E7\u00E3o v\u00E1rias vezes, geralmente existem duas maneiras: iterativa e recursiva. Iterativa \u00E9 quando utilizamos alguma estrutura de la\u00E7o, como um `for` ou `while`, com uma vari\u00E1vel de controle para saber quando parar. Recursiva \u00E9 quando uma fun\u00E7\u00E3o decide **executar a si mesma** por entender que ainda precisa continuar processando. Toda itera\u00E7\u00E3o pode ser escrita como uma recurs\u00E3o e vice-versa. Recurs\u00F5es por\u00E9m tem um risco associado: o **estouro da pilha**. Vamos entender o que isso significa e como escrever c\u00F3digo recursivo evitando esse problema!\\n\\n\u003C!-- summary-break -->\\n\\n## O que \u00E9 essa pilha?\\n\\nAntes de mais nada, o que \u00E9 **a pilha**? Neste contexto, n\u00E3o estamos falando de uma bateria \uD83D\uDD0B, mas de uma estrutura de dados em que podemos **empilhar** informa\u00E7\u00E3o \uD83E\uDD5E. Sempre que executamos uma fun\u00E7\u00E3o, n\u00F3s estamos movendo a execu\u00E7\u00E3o do c\u00F3digo de um ponto para o outro. Quando a fun\u00E7\u00E3o que chamamos termina, precisamos voltar para onde est\u00E1vamos com o resultado e continuar a execu\u00E7\u00E3o. Por isso, quando chamamos uma fun\u00E7\u00E3o, o ambiente de execu\u00E7\u00E3o vai guardar **o estado atual de execu\u00E7\u00E3o** em algum lugar para que possamos retornar para ele depois. Diferentes linguagens de programa\u00E7\u00E3o v\u00E3o ter diferentes ambientes de execu\u00E7\u00E3o, mas o conceito \u00E9 parecido entre elas.\\n\\nCada chamada de fun\u00E7\u00E3o adiciona esse contexto numa pilha (em ingl\u00EAs, _stack_). Usa-se uma pilha pois, se n\u00F3s executamos a fun\u00E7\u00E3o A, que chama a fun\u00E7\u00E3o B, que chama C (nessa ordem), ao final de C n\u00F3s queremos retornar para B e, ao final de B, n\u00F3s queremos retornar para A. Assim, vamos empilhando as chamadas aninhadas (chamadas dentro de chamadas) e desempilhando nos retornos. Cada contexto desse adicionado na pilha \u00E9 chamado de **quadro** (_stack frame_) e ocupa **espa\u00E7o em mem\u00F3ria**.\\n\\nMem\u00F3ria n\u00E3o \u00E9 infinita, e cada ambiente de execu\u00E7\u00E3o de c\u00F3digo vai definir um limite para o qu\u00E3o profunda uma pilha de chamadas de fun\u00E7\u00E3o pode ser. Se esse tamanho for, por exemplo, 1000, significa que voc\u00EA pode ter no m\u00E1ximo 1000 n\u00EDveis de fun\u00E7\u00F5es chamando umas as outras sem retornar, de acordo com o que a fun\u00E7\u00E3o precisar guardar na pilha. Se voc\u00EA tentar chamar mais uma fun\u00E7\u00E3o aninhada, voc\u00EA vai ter um **estouro da pilha**, de onde vem o nome do _Stack Overflow_.\\n\\n## O que isso tem a ver com recurs\u00E3o?\\n\\n\u00C9 dif\u00EDcil imaginar escrever 1000 fun\u00E7\u00F5es de maneira que uma chame a outra, consequentemente ultrapassando esse limite. Afinal de contas, voc\u00EA vai ter o limite da pr\u00F3pria quantidade de c\u00F3digo que voc\u00EA escreve. Por\u00E9m, existe algo bem mais r\u00E1pido e capaz do que n\u00F3s, humanos: **computadores**. E a\u00ED que entra recurs\u00E3o.\\n\\nImagine o seguinte cen\u00E1rio, em JavaScript. Note que estou colocando um `n` ao final dos n\u00FAmeros. Essa \u00E9 a sintaxe para `BigInt` em JS, que s\u00E3o n\u00FAmeros arbitrariamente grandes. O exemplo a seguir faz conta com n\u00FAmero muito grandes e, se usarmos n\u00FAmeros padr\u00F5es de JavaScript, chegar\u00EDamos em `Infinity` eventualmente.\\n\\n```js\\nfunction factorial(number) {\\n  if (number === 0n) {\\n    return 1n\\n  } else {\\n    return number * factorial(number - 1n)\\n  }\\n}\\n```\\n\\nTemos uma fun\u00E7\u00E3o recursiva que calcula o **fatorial de um n\u00FAmero** (o produto de todos os n\u00FAmeros entre 1 e este n\u00FAmero). Ela \u00E9 recursiva pois tem um **caso base** (se `number` for igual a zero) em que ela apenas retorna algo e um **caso recursivo** (se `number` n\u00E3o for igual a zero), em que ela faz algo e **chama a si mesma com outro argumento**.\\n\\n```js\\nfactorial(10n) // Resultado: 3628800n\\n```\\n\\nEssa fun\u00E7\u00E3o vai precisar usar a pilha `number` vezes, pois cada execu\u00E7\u00E3o dela precisa chamar uma fun\u00E7\u00E3o (ela mesma) **antes de poder retornar**. Ou seja, quando eu chamo `factorial(10)`, essa fun\u00E7\u00E3o retornar `10 * factorial(9)`. Mas ela n\u00E3o consegue retornar ainda, pois tem uma chamada de fun\u00E7\u00E3o n\u00E3o resolvida. Ela precisa esperar `factorial(9)` retornar para **depois** poder multiplicar por 10, e assim retornar tamb\u00E9m. Isso acontece sucessivamente at\u00E9 chegar em `factorial(0)`, que retorna apenas `1`. A partir da\u00ED, os contextos de execu\u00E7\u00E3o das fun\u00E7\u00F5es v\u00E3o sendo **desempilhados**, passando pelo `factorial(1)` (que aguardava o resultado do `factorial(0)`), depois `factorial(2)`, e assim at\u00E9 voltar para o original, `factorial(10)`.\\n\\nSe a entrada dessa fun\u00E7\u00E3o se tornar muito grande, vamos precisar fazer um n\u00FAmero de chamadas de fun\u00E7\u00E3o, uma dentro da outra, que pode precisar guardar mais informa\u00E7\u00E3o na pilha do que ela suporta, causando um estouro da pilha. Nos meus testes, rodando em Node.js, `factorial(10948n)` foi o ponto em que a pilha estouraria. Ao tentar executar essa fun\u00E7\u00E3o, eu recebi a mensagem: **Uncaught RangeError: Maximum call stack size exceeded**.\\n\\nO motivo de precisarmos guardar informa\u00E7\u00E3o na pilha de chamadas de fun\u00E7\u00E3o \u00E9 que **essa fun\u00E7\u00E3o precisa fazer algo com o resultado da chamada recursiva**. Mais especificamente, olhando para essa linha dentro do `else`:\\n\\n```js\\n    return number * factorial(number - 1n)\\n```\\n\\nA fun\u00E7\u00E3o precisa que a chamada recursiva retorne **para depois** conseguir fazer a multiplica\u00E7\u00E3o. Para visualizar, vamos diminuir a entrada para `5n`. A execu\u00E7\u00E3o aconteceria, passo a passo, assim:\\n\\n```js\\nfactorial(5n)\\n5n * factorial(4n)\\n5n * 4n * factorial(3n)\\n5n * 4n * 3n * factorial(2n)\\n5n * 4n * 3n * 2n * factorial(1n)\\n5n * 4n * 3n * 2n * 1n * factorial(0n)\\n5n * 4n * 3n * 2n * 1n * 1n // Chegamos no caso base\\n5n * 4n * 3n * 2n * 1n\\n5n * 4n * 3n * 2n\\n5n * 4n * 6n\\n5n * 24n\\n120n\\n```\\n\\n\u00C9 a\u00ED que entra o conceito de **recurs\u00E3o de cauda**, ou **otimiza\u00E7\u00E3o de chamada de cauda** (_tail call optimization_).\\n\\n## Como fazer essa recurs\u00E3o n\u00E3o estourar?\\n\\nAlgumas linguagens de programa\u00E7\u00E3o conseguem identificar chamadas de fun\u00E7\u00F5es que **n\u00E3o precisam guardar contexto na pilha**. Quando isso acontece, \u00E9 poss\u00EDvel ter uma recurs\u00E3o que, independentemente da profundidade, n\u00E3o vai causar um estouro da pilha.\\n\\n**Infelizmente, JavaScript n\u00E3o \u00E9 uma delas.** As implementa\u00E7\u00F5es atuais n\u00E3o suportam esse tipo de otimiza\u00E7\u00E3o. Para fins ilustrativos, vamos rever como seria o exemplo acima se JavaScript tivesse suporte a recurs\u00E3o de cauda. Depois, vamos ver o mesmo exemplo em **linguagens que de fato suportam**.\\n\\nVamos re-escrever a fun\u00E7\u00E3o do fatorial de maneira que **ela n\u00E3o precise esperar pelo retorno da recurs\u00E3o para retornar**. O segredo est\u00E1 em fazer com que, em todos os poss\u00EDveis caminhos para o c\u00F3digo, n\u00F3s retornemos apenas **valores** ou **a pr\u00F3pria chamada recursiva**.\\n\\n```js\\nfunction factorial(number, product) {\\n  if (number === 0n) {\\n    return product\\n  } else {\\n    return factorial(number - 1n, product * number)\\n  }\\n}\\n```\\n\\nA fun\u00E7\u00E3o acima tem dois caminhos poss\u00EDveis de execu\u00E7\u00E3o. O primeiro caminho, se `number` for zero, retorna apenas um valor (a vari\u00E1vel `product`). O segundo, se `number` n\u00E3o for zero, \u00E9 o que modificamos. Ao inv\u00E9s de retornar o valor atual multiplicado pelo retorno da recurs\u00E3o, n\u00F3s **calculamos a multiplica\u00E7\u00E3o primeiro** e s\u00F3 depois fazemos a chamada recursiva.\\n\\nPara isso, introduzimos um segundo argumento a essa fun\u00E7\u00E3o, o `product`. Ele funciona aqui como um **acumulador**, que guarda o resultado intermedi\u00E1rio. Esse acumulador vai guardando cada multiplica\u00E7\u00E3o e \u00E9 retornado no caso base, quando chegamos no fim da recurs\u00E3o. Como n\u00F3s passamos esse resultado intermedi\u00E1rio na chamada recursiva, nosso `return` **n\u00E3o faz nada com o resultado da recurs\u00E3o**, apenas retorna-o diretamente. O interpretador do JavaScript poderia perceber isso e **n\u00E3o guardar nada na pilha**. \\n\\nVamos ver como ficaria a sequ\u00EAncia de execu\u00E7\u00E3o dessa nova fun\u00E7\u00E3o. Note que, como ela tem um acumulador (segundo par\u00E2metro), precisamos passar algum **valor inicial** para esse par\u00E2metro. Como \u00E9 uma multiplica\u00E7\u00E3o, podemos passar `1n` (pois 1 n\u00E3o afeta um produto).\\n\\n```js\\nfactorial(5n, 1n)\\nfactorial(4n, 5n)\\nfactorial(3n, 20n)\\nfactorial(2n, 60n)\\nfactorial(1n, 120n)\\nfactorial(0n, 120n)\\n120n\\n```\\n\\nSobre esse segundo argumento, idealmente n\u00E3o gostar\u00EDamos que fosse necess\u00E1rio pass\u00E1-lo para come\u00E7ar a calcular. Para isso, podemos separar a implementa\u00E7\u00E3o da fun\u00E7\u00E3o da API p\u00FAblica, assim:\\n\\n```js\\nfunction factorialImplementation(number, product) {\\n  if (number === 0n) {\\n    return product\\n  } else {\\n    return factorialImplementation(number - 1n, product * number)\\n  }\\n}\\n\\n// A fun\u00E7\u00E3o que exportamos publicamente apenas tem um argumento\\nexport function factorial(number) {\\n  return factorialImplementation(number, 1n)\\n}\\n```\\n\\nAssim, nossa fun\u00E7\u00E3o `factorial` s\u00F3 recebe um argumento. Alternativamente, poder\u00EDamos colocar um valor padr\u00E3o para o segundo argumento (mas isso permitiria chamar a fun\u00E7\u00E3o passando um segundo argumento errado, ainda assim).\\n\\n## Exemplos em linguagens que suportam otimiza\u00E7\u00E3o de chamadas de cauda\\n\\nComo eu comentei, **infelizmente JavaScript n\u00E3o tem suporte** a n\u00E3o adicionar contexto na pilha caso n\u00E3o seja necess\u00E1rio. Toda chamada de fun\u00E7\u00E3o vai colocar algo na pilha e, eventualmente, uma recurs\u00E3o causa um estouro.\\n\\nVamos rever o exemplo do fatorial em algumas linguagens que t\u00EAm suporte a essa otimiza\u00E7\u00E3o.\\n\\n### Clojure\\n\\n```clj\\n(defn factorial\\n  \\\"Implementa\u00E7\u00E3o sem tail call optimization\\\"\\n  [number]\\n  (if (zero? number)\\n    1\\n    (* number (factorial (dec number)))))\\n```\\n\\n```clj\\n(defn factorial\\n  \\\"Implementa\u00E7\u00E3o com tail call optimization\\\"\\n  [number product]\\n  (if (zero? number)\\n    product\\n    (recur (dec number) (* product number))))\\n```\\n\\nNote que, em Clojure, existe uma forma especial para recurs\u00E3o de cauda: `recur`. Usamos `recur` no lugar do nome da fun\u00E7\u00E3o, para executar uma chamada recursiva. Se voc\u00EA tentar usar `recur` num contexto que ele n\u00E3o seja a \u00FAltima execu\u00E7\u00E3o de um caminho da execu\u00E7\u00E3o de c\u00F3digo, vai receber um erro. Se voc\u00EA tentar escrever recurs\u00F5es sempre com `recur`, voc\u00EA tem a garantia de fazer uma recurs\u00E3o de cauda (pois o compilador n\u00E3o vai deixar voc\u00EA n\u00E3o o fazer).\\n\\n### Kotlin\\n\\n```kt\\n// Implementa\u00E7\u00E3o sem tail call optimization\\nfun factorial(number: Long) : Long {\\n    return if (number === 0) {\\n        1\\n    } else {\\n        number * factorial(number - 1)\\n    }\\n}\\n```\\n\\n```kt\\n// Implementa\u00E7\u00E3o com tail call optimization\\ntailrec fun factorial(number: Long, product: Long) : Long {\\n    return if (number === 0) {\\n        product\\n    } else {\\n        factorial(number - 1, product * number)\\n    }\\n}\\n```\\n\\nKotlin possui a palavra-chave `tailrec`. Se aplicada a uma fun\u00E7\u00E3o, indica que a recurs\u00E3o dessa fun\u00E7\u00E3o \u00E9 de cauda. Se voc\u00EA aplicar esse modificador na primeira vers\u00E3o, por exemplo, ter\u00E1 um erro, assim como o uso do `recur` em Clojure.\\n\\n### Haskell\\n\\n```haskell\\n-- Implementa\u00E7\u00E3o sem tail call optimization\\nfactorial :: (Integral a) => a -> a\\nfatorial 0 = 1\\nfactorial n = n * factorial (n - 1)\\n```\\n\\n```haskell\\n-- Implementa\u00E7\u00E3o com tail call optimization\\nfactorial :: (Integral a) => a -> a -> a\\nfatorial 0 p = p\\nfactorial n p = factorial (n - 1) (p * n)\\n```\\n\\n### Elixir\\n\\nRecentemente, eu escrevi um post sobre [casamento de padr\u00F5es com Elixir](/casamento-de-padroes-em-elixir/). No final dele tem esse exemplo de fatorial usando casamento de padr\u00F5es e recurs\u00E3o de cauda. Ela tamb\u00E9m deixa p\u00FAblica apenas a chamada da fun\u00E7\u00E3o com um argumento, mantendo a vers\u00E3o com o acumulador privada.\\n\\n```elixir\\ndefmodule Math do\\n  def factorial(number) do\\n    factorial(number, 1)\\n  end\\n\\n  defp factorial(0, current_product) do\\n    current_product\\n  end\\n\\n  defp factorial(number, current_product) do\\n    factorial(number - 1, number * current_product)\\n  end\\nend\\n```\\n\\n## Eu posso usar recurs\u00E3o de cauda na minha linguagem favorita?\\n\\n**Depende de qual \u00E9 ela.**\\n\\nN\u00E3o coincidentemente, os tr\u00EAs exemplos de linguagens que suportam otimiza\u00E7\u00E3o de chamada de cauda que eu trouxe s\u00E3o **linguagens funcionais**. Normalmente, programa\u00E7\u00E3o funcional utiliza recurs\u00E3o com uma frequ\u00EAncia superior a itera\u00E7\u00E3o, e linguagens funcionais t\u00EAm essa preocupa\u00E7\u00E3o com performance e limita\u00E7\u00F5es de mem\u00F3ria. \\n\\nA Wikip\u00E9dia tem uma [lista com algumas linguagens que suportam essa otimiza\u00E7\u00E3o](https://en.wikipedia.org/wiki/Tail_call#By_language). Voc\u00EA vai ver que, em maioria, s\u00E3o linguagens funcionais. Se essa maneira de pensar te interessou, e voc\u00EA nunca aprendeu uma linguagem funcional, **que tal experimentar?** Se aceita uma sugest\u00E3o, d\u00E1 uma olhada em [Clojure](https://www.braveclojure.com/clojure-for-the-brave-and-true/) ou [Elixir](https://elixir-lang.org/getting-started/introduction.html)!\\n\",\"readingTime\":10,\"summary\":\"Quando precisamos realizar uma opera\u00E7\u00E3o v\u00E1rias vezes, geralmente existem duas maneiras: iterativa e recursiva. Iterativa \u00E9 quando utilizamos alguma estrutura de la\u00E7o, como um `for` ou `while`, com uma vari\u00E1vel de controle para saber quando parar. Recursiva \u00E9 quando uma fun\u00E7\u00E3o decide **executar a si mesma** por entender que ainda precisa continuar processando. Toda itera\u00E7\u00E3o pode ser escrita como uma recurs\u00E3o e vice-versa. Recurs\u00F5es por\u00E9m tem um risco associado: o **estouro da pilha**. Vamos entender o que isso significa e como escrever c\u00F3digo recursivo evitando esse problema!\\n\\n\"}},\"path\":\"recursao-de-causa-ou-como-nao-estourar-a-pilha\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/vendors~__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.207edc50.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/post~__react_static_root__/src/containers/postList.a04ea84b.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/post.d8dd52db.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.272ae1d1.js"></script><script defer="" type="text/javascript" src="/main.f19d4c14.js"></script></body></html>